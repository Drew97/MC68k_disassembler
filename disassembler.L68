00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.14.00
Created On: 2/21/2014 10:23:25 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Disassembler
00000000                             3  * Written by : Robert Brandenburg, Danielle Jenkins, Shahin Nahar
00000000                             4  * Date       : 2/13/14
00000000                             5  * Description: Disassemble hex machine code instructions into 68K instructions
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8  * TODO: write disassembler
00000000                             9  * TODO: more specific TODOs for our plan
00000000                            10  * TODO: comments saying who is working where
00000000                            11  
00000000                            12  
00000000                            13  * Commenting Key: 
00000000                            14  *    "----------"  <-- subroutine commenting
00000000                            15  *    "##########"  <-- section/role commenting
00000000                            16  
00000000                            17  * Notes on saving registers on run:
00000000                            18  *    MOVEM.L A0-A3/D0-D7, -(A7) * copies all working registers to stack
00000000                            19  *    MOVEM.L (A7)+, A0-A3/D0-D7 *Restore the registers
00000000                            20  
00000000                            21  * Notes on AND filters (bit masking):
00000000                            22  * Example:
00000000                            23  *       0001 000 001 111 100   (say you want "001")
00000000                            24  *   AND 0000 000 111 000 000   (0 <-- don't want, 1 <-- do want)
00000000                            25  *       --------------------
00000000                            26  *     = 0000 000 001 000 000
00000000                            27  *
00000000                            28  * Relevant wiki page:
00000000                            29  *   https://en.wikipedia.org/wiki/Mask_(computing)#Masking_bits_to_0
00000000                            30  *
00000000                            31  *################ TODO LIST ################################
00000000                            32  *----------------OPcode TODOS (ROBERT)-----------------------------
00000000                            33  *
00000000                            34  * Fix the current bugs with MOVEs performed on absolute addresses. Not sure why these errors occur.
00000000                            35  *   -consult the bug report before trying to debug.
00000000                            36  * Continue decoding OPcodes in the following order: (with sizes)
00000000                            37  *   NOTE: I will delete OPcodes from this list as I implement them.
00000000                            38  
00000000                            39  *   -MOVEM  (W,L)
00000000                            40  *   -ADD    (B,W,L) (will need shahin's size filter for this and below)
00000000                            41  *   -ADDA   (W,L)
00000000                            42  *   -ADDI   (B,W,L)
00000000                            43  *   -SUB    (B,W,L)
00000000                            44  *   -SUBA   (W,L)
00000000                            45  *   -SUBQ   (B,W,L)
00000000                            46  *   -MULS   (W)     (not MULU?)
00000000                            47  *   -DIVU   (W      (not DIVU?)
00000000                            48  *   -LEA    (?)
00000000                            49  *   -CLR    (B,W,L)
00000000                            50  *   -AND    (B,W,L)
00000000                            51  *   -ANDI   (B,W,L)
00000000                            52  *   -EOR    (B,W,L)
00000000                            53  *   -EORI   (B,W,L)
00000000                            54  *   -ASR    (B,W,L) (no ASL?)
00000000                            55  *   -LSL    (B,W,L) (no LSR?)
00000000                            56  *   -ROL    (B,W,L)
00000000                            57  *   -ROR    (B,W,L)
00000000                            58  *   -BCHG   (?)
00000000                            59  *   -CMP    (B,W,L)
00000000                            60  *   -CMPA   (W,L)
00000000                            61  *   -CMPI   (B,W,L)
00000000                            62  *   -JSR    (N/A)
00000000                            63  *   (add others if we have time)
00000000                            64  *
00000000                            65  *----------------I/O TODOS (DANIELLE)-----------------------------
00000000                            66  * (TODOs for I/O go here.)
00000000                            67  *   - Complete display buffer
00000000                            68  *   - Print only a screenful at a time
00000000                            69  *   - At the end ask the user if they want to restart
00000000                            70  *   - Drop dollar sign if it appears in input
00000000                            71  *
00000000                            72  *----------------EA TODOS  (SHAHIN)-----------------------------
00000000                            73  * (TODOs for EA go here.)
00000000                            74  *################ BEGIN MAIN ###############################
00000000                            75  *** All subroutine calls are made here ***
00001000                            76  START                   ORG        $1000       ; first instruction of program
00001000  6000 0006                 77                          BRA        PROMPT_INPUT            ; prompt the user for input
00001004                            78                   
00001004  4E72 2700                 79  STOP                    STOP       #$2700          ; halt simulator, end of main
00001008                            80  
00001008                            81  *################ END MAIN ###############################
00001008                            82  *################ BEGIN IO ###############################
00001008                            83  *** IO Subroutines are kept here ***
00001008                            84  
00001008                            85  *-------------------- Print ASCII logo ----------------------
00001008  6000 0002                 86  PROMPT_INPUT            BRA         TAKE_USER_IN_S ;TODO: change to welcome/ASCII logo
0000100C                            87  *------------------- Prompt user for input -------------------
0000100C                            88  
0000100C                            89                  
0000100C  163C 0001                 90  TAKE_USER_IN_S          MOVE.B      #1,D3
00001010  43F9 00001ACB             91                          LEA         START_ADDR_MSG,A1  ; Prompt user for starting address
00001016  103C 000E                 92                          MOVE.B      #14,D0
0000101A  4E4F                      93                          TRAP        #15
0000101C                            94  
0000101C  6000 0016                 95                          BRA         TAKE_USER_INPUT
00001020                            96  
00001020  163C 0000                 97  TAKE_USER_IN_E          MOVE.B      #0,D3
00001024  43F9 00001AFF             98                          LEA         END_ADDR_MSG,A1  ; prompt user for ending address
0000102A  103C 000E                 99                          MOVE.B      #14,D0
0000102E  4E4F                     100                          TRAP        #15
00001030                           101                          
00001030  6000 0002                102                          BRA         TAKE_USER_INPUT
00001034                           103                          
00001034  7200                     104  TAKE_USER_INPUT         MOVE.L      #$00000000,D1   ; need to clear out the data registers we are about to use to avoid junk data.   
00001036  7A00                     105                          MOVE.L      #$00000000,D5    
00001038  7C00                     106                          MOVE.L      #$00000000,D6
0000103A  7E00                     107                          MOVE.L      #$00000000,D7
0000103C                           108  
0000103C  103C 0002                109                          MOVE.B      #2,D0           ; Take user input for next address.
00001040  327C 2000                110                          MOVEA.W     #$2000,A1       ; Store the ascii input in A1,(note that we might not want to use 2000 here)
00001044  4E4F                     111                          TRAP        #15             ; and the length in D1.W.  
00001046                           112  
00001046  327C 2001                113  COUNT_INPUT_DIGITS      MOVEA.W     #$2001,A1
0000104A  B27C 0001                114                          CMP         #1,D1
0000104E  6700 0064                115                          BEQ         ASCII_TO_HEX  ;start converting if we have 1 digit.
00001052                           116            
00001052  327C 2002                117                          MOVEA.W     #$2002,A1
00001056  B27C 0002                118                          CMP         #2,D1
0000105A  6700 0058                119                          BEQ         ASCII_TO_HEX  ;start converting if we have 2 digits.
0000105E                           120            
0000105E  327C 2003                121                          MOVEA.W     #$2003,A1
00001062  B27C 0003                122                          CMP         #3,D1
00001066  6700 004C                123                          BEQ         ASCII_TO_HEX  ;start converting if we have 3 digits.
0000106A                           124            
0000106A  327C 2004                125                          MOVEA.W     #$2004,A1
0000106E  B27C 0004                126                          CMP         #4,D1
00001072  6700 0040                127                          BEQ         ASCII_TO_HEX  ;start converting if we have 4 digits.
00001076                           128            
00001076  327C 2005                129                          MOVEA.W     #$2005,A1
0000107A  B27C 0005                130                          CMP         #5,D1
0000107E  6700 0034                131                          BEQ         ASCII_TO_HEX  ;start converting if we have 5 digits.
00001082                           132            
00001082  327C 2006                133                          MOVEA.W     #$2006,A1
00001086  B27C 0006                134                          CMP         #6,D1
0000108A  6700 0028                135                          BEQ         ASCII_TO_HEX  ;start converting if we have 6 digits.
0000108E                           136            
0000108E  327C 2007                137                          MOVEA.W     #$2007,A1
00001092  B27C 0007                138                          CMP         #7,D1
00001096  6700 001C                139                          BEQ         ASCII_TO_HEX  ;start converting if we have 7 digits.
0000109A                           140            
0000109A  327C 2008                141                          MOVEA.W     #$2008,A1
0000109E  B27C 0008                142                          CMP         #8,D1
000010A2  6700 0010                143                          BEQ         ASCII_TO_HEX  ;start converting if we have 8 digits.
000010A6                           144            
000010A6  43F9 00001B32            145                          LEA         INVALID_LEN_MSG,A1         ; If we get an invalid length, give and error message and... branch back asking user for input again
000010AC  103C 000E                146                          MOVE.B      #14,D0
000010B0  4E4F                     147                          TRAP        #15
000010B2                           148  
000010B2  6780                     149                          BEQ         TAKE_USER_INPUT               
000010B4                           150  
000010B4                           151  
000010B4                           152  
000010B4                           153  *------------------- Convert to hex subroutine -------------------
000010B4                           154  
000010B4  7C00                     155  ASCII_TO_HEX            MOVE.L      #$00000000,D6      ; running total of converted hex number
000010B6                           156                  
000010B6                           157                          ;first digit
000010B6  1A21                     158                          MOVE.B      -(A1),D5  ; Move the raw ascii value of first digit into 3007.
000010B8  BA7C 0030                159                          CMP         #$30,D5
000010BC  6D00 01B2                160                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
000010C0  BA7C 0040                161                          CMP         #$40,D5
000010C4  6700 01AA                162                          BEQ         INVALID_ADDR_INPUT
000010C8  BA7C 0046                163                          CMP         #$46,D5
000010CC  6E00 01A2                164                          BGT         INVALID_ADDR_INPUT   
000010D0                           165                          ; Convert ascii to hex for that digit.
000010D0  0445 0030                166                          SUB         #$30,D5   ;
000010D4  BA7C 000A                167                          CMP         #$A,D5
000010D8  6D00 0004                168                          BLT         DIG_CONV_DONE_1 ; Necessary to convert some ASCII values.
000010DC  5F05                     169                          SUB.B       #7, D5                      ; TODO: errors for invalid ASCII values.
000010DE                           170                  
000010DE  DC45                     171  DIG_CONV_DONE_1         ADD.W       D5,D6
000010E0  B27C 0001                172                          CMP         #1,D1
000010E4  6700 01CA                173                          BEQ         CONVERSION_DONE
000010E8                           174                  
000010E8                           175                          ;second digit
000010E8  7A00                     176                          MOVE.L      #$00000000,D5
000010EA  1A21                     177                          MOVE.B      -(A1),D5
000010EC  BA7C 0030                178                          CMP         #$30,D5
000010F0  6D00 017E                179                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
000010F4  BA7C 0040                180                          CMP         #$40,D5
000010F8  6700 0176                181                          BEQ         INVALID_ADDR_INPUT
000010FC  BA7C 0046                182                          CMP         #$46,D5
00001100  6E00 016E                183                          BGT         INVALID_ADDR_INPUT   
00001104  0445 0030                184                          SUB         #$30,D5
00001108  BA7C 000A                185                          CMP         #$A,D5            
0000110C  6D00 0004                186                          BLT         DIG_CONV_DONE_2    ;digit conversion done 1
00001110  5F05                     187                          SUB.B       #7, D5             ; if we have A or greater, then we need to subtract 1.
00001112                           188               
00001112  CAFC 0010                189  DIG_CONV_DONE_2         MULU.W      #$00000010,D5  ; this part adds $10 * (2nd digit) to our running total.
00001116  DC45                     190                          ADD.W       D5,D6 
00001118                           191                    
00001118  B27C 0002                192                          CMP         #2,D1
0000111C  6700 0192                193                          BEQ         CONVERSION_DONE
00001120                           194                  
00001120                           195                          ;third digit
00001120  7A00                     196                          MOVE.L      #$00000000,D5
00001122  1A21                     197                          MOVE.B      -(A1),D5
00001124  BA7C 0030                198                          CMP         #$30,D5
00001128  6D00 0146                199                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
0000112C  BA7C 0040                200                          CMP         #$40,D5
00001130  6700 013E                201                          BEQ         INVALID_ADDR_INPUT
00001134  BA7C 0046                202                          CMP         #$46,D5
00001138  6E00 0136                203                          BGT         INVALID_ADDR_INPUT   
0000113C  0445 0030                204                          SUB         #$30,D5
00001140  BA7C 000A                205                          CMP         #$A,D5
00001144  6D00 0004                206                          BLT         DIG_CONV_DONE_3 
00001148  5F05                     207                          SUB.B       #7, D5
0000114A                           208                  
0000114A  CAFC 0100                209  DIG_CONV_DONE_3         MULU.W      #$00000100,D5
0000114E  DC45                     210                          ADD.W       D5,D6 
00001150                           211      
00001150  B27C 0003                212                          CMP         #3,D1
00001154  6700 015A                213                          BEQ         CONVERSION_DONE
00001158                           214                  
00001158                           215                          ;fourth digit
00001158  7A00                     216                          MOVE.L      #$00000000,D5
0000115A  1A21                     217                          MOVE.B      -(A1),D5
0000115C  BA7C 0030                218                          CMP         #$30,D5
00001160  6D00 010E                219                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
00001164  BA7C 0040                220                          CMP         #$40,D5
00001168  6700 0106                221                          BEQ         INVALID_ADDR_INPUT
0000116C  BA7C 0046                222                          CMP         #$46,D5
00001170  6E00 00FE                223                          BGT         INVALID_ADDR_INPUT   
00001174  0445 0030                224                          SUB         #$30,D5
00001178  BA7C 000A                225                          CMP         #$A,D5
0000117C  6D00 0004                226                          BLT         DIG_CONV_DONE_4
00001180  5F05                     227                          SUB.B       #7,D5
00001182                           228                  
00001182  CAFC 1000                229  DIG_CONV_DONE_4         MULU.W      #$00001000,D5
00001186  DC45                     230                          ADD.W       D5,D6 
00001188                           231      
00001188  B27C 0004                232                          CMP         #4,D1
0000118C  6700 0122                233                          BEQ         CONVERSION_DONE
00001190                           234                  
00001190                           235                          ;fifth digit
00001190  7A00                     236                          MOVE.L      #$00000000,D5
00001192  1A21                     237                          MOVE.B      -(A1),D5
00001194  BA7C 0030                238                          CMP         #$30,D5
00001198  6D00 00D6                239                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
0000119C  BA7C 0040                240                          CMP         #$40,D5
000011A0  6700 00CE                241                          BEQ         INVALID_ADDR_INPUT
000011A4  BA7C 0046                242                          CMP         #$46,D5
000011A8  6E00 00C6                243                          BGT         INVALID_ADDR_INPUT   
000011AC  0445 0030                244                          SUB         #$30,D5
000011B0  BA7C 000A                245                          CMP         #$A,D5
000011B4  6D00 0004                246                          BLT         DIG_CONV_DONE_5
000011B8  5F05                     247                          SUB.B       #$7, D5
000011BA                           248                  
000011BA  CAFC 0001                249  DIG_CONV_DONE_5         MULU.W      #$0001,D5
000011BE  DE45                     250                          ADD.W       D5,D7 
000011C0                           251  
000011C0  B27C 0005                252                          CMP         #5,D1
000011C4  6700 00EA                253                          BEQ         CONVERSION_DONE
000011C8                           254                  
000011C8                           255                          ;sixth digit
000011C8  7A00                     256                          MOVE.L      #$00000000,D5
000011CA  1A21                     257                          MOVE.B      -(A1),D5
000011CC  BA7C 0030                258                          CMP         #$30,D5
000011D0  6D00 009E                259                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
000011D4  BA7C 0040                260                          CMP         #$40,D5
000011D8  6700 0096                261                          BEQ         INVALID_ADDR_INPUT
000011DC  BA7C 0046                262                          CMP         #$46,D5
000011E0  6E00 008E                263                          BGT         INVALID_ADDR_INPUT   
000011E4  0445 0030                264                          SUB         #$30,D5
000011E8  BA7C 000A                265                          CMP         #$A,D5
000011EC  6D00 0004                266                          BLT         DIG_CONV_DONE_6
000011F0  5F05                     267                          SUB.B       #$7, D5
000011F2                           268                  
000011F2  CAFC 0010                269  DIG_CONV_DONE_6         MULU.W      #$0010,D5
000011F6  DE45                     270                          ADD.W       D5,D7
000011F8                           271      
000011F8  B27C 0006                272                          CMP         #6,D1
000011FC  6700 00B2                273                          BEQ         CONVERSION_DONE
00001200                           274                  
00001200                           275                          ;seventh digit
00001200  7A00                     276                          MOVE.L      #$00000000,D5
00001202  1A21                     277                          MOVE.B      -(A1),D5
00001204  BA7C 0030                278                          CMP         #$30,D5
00001208  6D00 0066                279                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
0000120C  BA7C 0040                280                          CMP         #$40,D5
00001210  6700 005E                281                          BEQ         INVALID_ADDR_INPUT
00001214  BA7C 0046                282                          CMP         #$46,D5
00001218  6E00 0056                283                          BGT         INVALID_ADDR_INPUT   
0000121C  0445 0030                284                          SUB         #$30,D5
00001220  BA7C 000A                285                          CMP         #$A,D5
00001224  6D00 0004                286                          BLT         DIG_CONV_DONE_7
00001228  5F05                     287                          SUB.B       #7, D5
0000122A                           288                  
0000122A  CAFC 0100                289  DIG_CONV_DONE_7         MULU.W      #$0100,D5
0000122E  DE45                     290                          ADD.W       D5,D7
00001230                           291      
00001230  B27C 0007                292                          CMP         #7,D1
00001234  6700 007A                293                          BEQ         CONVERSION_DONE
00001238                           294                  
00001238                           295                          ;eighth digit
00001238  7A00                     296                          MOVE.L      #$00000000,D5
0000123A  1A21                     297                          MOVE.B      -(A1),D5
0000123C  BA7C 0030                298                          CMP         #$30,D5
00001240  6D00 002E                299                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
00001244  BA7C 0040                300                          CMP         #$40,D5
00001248  6700 0026                301                          BEQ         INVALID_ADDR_INPUT
0000124C  BA7C 0046                302                          CMP         #$46,D5
00001250  6E00 001E                303                          BGT         INVALID_ADDR_INPUT   
00001254  0445 0030                304                          SUB         #$30,D5
00001258  BA7C 000A                305                          CMP         #$A,D5
0000125C  6D00 0004                306                          BLT         DIG_CONV_DONE_8
00001260  5F05                     307                          SUB.B       #7, D5
00001262                           308                  
00001262  CAFC 1000                309  DIG_CONV_DONE_8         MULU.W      #$1000,D5
00001266  DE45                     310                          ADD.W       D5,D7
00001268                           311      
00001268  B27C 0008                312                          CMP         #8,D1
0000126C  6700 0042                313                          BEQ         CONVERSION_DONE    ;the input was valid and we are done with the conversion
00001270                           314                  
00001270  43F9 00001B80            315  INVALID_ADDR_INPUT      LEA         INVALID_ADDR_MSG,A1    ;tell the user the address was invalid and prompt input again.
00001276  103C 000E                316                          MOVE.B      #14,D0
0000127A  4E4F                     317                          TRAP        #15
0000127C                           318                          
0000127C  6000 FDB6                319                          BRA         TAKE_USER_INPUT
00001280                           320                          
00001280  43F9 00001BB6            321  INVALID_END_ADDR        LEA         INVALID_END_ADDR_MSG,A1
00001286  103C 000E                322                          MOVE.B      #14,D0
0000128A  4E4F                     323                          TRAP        #15
0000128C                           324                          
0000128C  6000 FDA6                325                          BRA         TAKE_USER_INPUT
00001290                           326                          
00001290  43F9 00001C07            327  INVALID_ADDR_LOW        LEA         INVALID_ADDR_L_MSG,A1    ;tell the user the address was invalid and prompt input again.
00001296  103C 000E                328                          MOVE.B      #14,D0
0000129A  4E4F                     329                          TRAP        #15
0000129C                           330                          
0000129C  6000 FD96                331                          BRA         TAKE_USER_INPUT
000012A0                           332  
000012A0  43F9 00001C47            333  INVALID_ADDR_HIGH       LEA         INVALID_ADDR_H_MSG,A1    ;tell the user the address was invalid and prompt input again.
000012A6  103C 000E                334                          MOVE.B      #14,D0
000012AA  4E4F                     335                          TRAP        #15
000012AC                           336                          
000012AC  6000 FD86                337                          BRA         TAKE_USER_INPUT
000012B0                           338                 
000012B0  E18F                     339  CONVERSION_DONE         LSL.L       #8,D7   ; Prepare for concatenation
000012B2  E18F                     340                          LSL.L       #8,D7   ; Got to perform the same operation twice to get it all the way to the left
000012B4  DE46                     341                          ADD.W       D6,D7  ; concatenate the two data registers into one value
000012B6                           342                          
000012B6  BEBC 00003000            343                          CMP.L       #MIN_ADDRESS,D7
000012BC  6DD2                     344                          BLT         INVALID_ADDR_LOW ;Not a valid address-- too low.
000012BE                           345                          
000012BE  BEBC 0FFF0000            346                          CMP.L       #MAX_ADDRESS,D7
000012C4  6EDA                     347                          BGT         INVALID_ADDR_HIGH  ;Not a valid address-- too high.
000012C6                           348                          
000012C6  0C43 0001                349  VALID_ADDR              CMPI        #1,D3
000012CA                           350                          
000012CA  6700 0006                351                          BEQ         SET_START_ADDR
000012CE  6000 0008                352                          BRA         SET_END_ADDR              
000012D2                           353                                                 
000012D2  2A47                     354  SET_START_ADDR          MOVEA.L     D7,A5  ;when a valid start address is inputted, store and ask the user for an end address.
000012D4  6000 FD4A                355                          BRA         TAKE_USER_IN_E
000012D8                           356  
000012D8  BE8D                     357  SET_END_ADDR            CMP.L       A5,D7    ;if end address is lower than start address, we get an error.
000012DA  6DA4                     358                          BLT         INVALID_END_ADDR           
000012DC                           359                          
000012DC  2C47                     360                          MOVEA.L     D7,A6  ;when a valid start address is inputted, store and ask the user for an end address.
000012DE  6000 0002                361                          BRA         BEGIN_READ
000012E2                           362                          
000012E2  284D                     363  BEGIN_READ              MOVEA.L      A5,A4 ; keep track of address to print with A4. TODO: could also add this value to the display buffer.
000012E4  33DD 00001D04            364                          MOVE.W      (A5)+,CURRENT_WORD ;look at the first instruction word at the starting address.
000012EA  6000 0002                365                          BRA         PREPARE_DISPLAY
000012EE                           366  
000012EE                           367  *------------------- Add to display buffer -------------------
000012EE                           368  ;At this point A5 is a valid start address and A6 is a valid end address.
000012EE                           369  ;TODO: prepare the display buffer
000012EE  6000 0030                370  PREPARE_DISPLAY         BRA         READ_CURRENT_OP    ;TEMP (though we might still call this after the display buffer is prepared)                       
000012F2                           371                 
000012F2                           372  *------------------- Move address pointer for data reading -------------------
000012F2                           373  ; This method is specifically for reading the next OPword.
000012F2  6000 0014                374  GO_TO_NEXT_OP           BRA         CHECK_DONE_READING
000012F6                           375                           
000012F6  4279 00001D04            376  CONFIRMED_NEXT_OP       CLR         CURRENT_WORD
000012FC  284D                     377                          MOVEA.L      A5,A4 ; keep track of address to print with A4. 
000012FE  33DD 00001D04            378                          MOVE.W      (A5)+,CURRENT_WORD
00001304  6000 001A                379                          BRA         READ_CURRENT_OP
00001308                           380                          
00001308                           381  *------------------- Print display buffer -------------------
00001308                           382  
00001308                           383  ;TODO
00001308                           384  
00001308                           385  *------------------- Check if end of data -------------------
00001308  BACE                     386  CHECK_DONE_READING      CMPA        A6,A5       ; TODO: this comparison is not sufficient, because it will say that $8000 is less than $7000 (since $8000 is negative.)
0000130A  6DEA                     387                          BLT         CONFIRMED_NEXT_OP
0000130C  6000 0002                388                          BRA         DONE_READING
00001310                           389                          
00001310                           390  *------------------- Confirm end of data -------------------
00001310  43F9 00001C88            391  DONE_READING            LEA         DONE_READING_MSG,A1 ; when we reach the end address, say so and halt the program. TODO: ask user whether we want to read the data again.
00001316  103C 000E                392                          MOVE.B      #14,D0
0000131A  4E4F                     393                          TRAP        #15
0000131C  4EF8 1004                394                          JMP         STOP
00001320                           395                          
00001320                           396  *################## END IO  #####################################
00001320                           397  *################## BEGIN OPCODE ##########################
00001320                           398  *** OPcode Subroutines are kept here ***
00001320                           399  
00001320                           400  ; planned process for reading hex instructions:
00001320                           401          ; NOTE: this process is tentative and subject to change as OPcode person implements. 
00001320                           402                  ;           1) Go to start of instruction reading loop, passing in the address of next instruction.
00001320                           403                  ;           2) Store a word (16 bits) from that address.
00001320                           404                  ;           3) Read the first 4 bits of the word using a filter.
00001320                           405                  ;           4) branch to one of the following paths based on these bits:
00001320                           406                  ;               a) 0000: Read the next 3 bits (i.e., the destination mode). Branch:
00001320                           407                  ;                   i.   000: Read the bits at 0000 0000 XXXX XXXX (may want to make this filter) Branch:
00001320                           408                  ;                       1) 00 111 100: ORI TO CCR (need to read data, I think)
00001320                           409                  ;                       2) 01 111 100: ORI TO SR (need to read data, I think)
00001320                           410                  ;                       3) (default) ORI. Now, read and store:
00001320                           411                  ;                           SIZE:       0000 0000 XX00 0000 (need to make this filter)
00001320                           412                  ;                           MODE:       0000 0000 00XX X000 (need to make this filter)
00001320                           413                  ;                           REGISTER:   0000 0000 0000 0XXX (need to make this filter)
00001320                           414                  ;                           only mandatory additional data is the immediate data.
00001320                           415                  ;                   ii.  001: Read the bits at 0000 0000 XXXX XXXX (may want to make this filter) Branch:
00001320                           416                  ;                       1) 00 111 100: ANDI TO CCR (need to read data, I think)
00001320                           417                  ;                       2) 01 111 100: ANDI TO SR (need to read data, I think)
00001320                           418                  ;                       3) (default) ANDI. Now, read and store:
00001320                           419                  ;                           SIZE:       0000 0000 XX00 0000 (need to make this filter)
00001320                           420                  ;                           MODE:       0000 0000 00XX X000 (need to make this filter)
00001320                           421                  ;                           REGISTER:   0000 0000 0000 0XXX (need to make this filter)
00001320                           422                  ;                           only mandatory additional data is the immediate data.
00001320                           423                  ;                   iii. 101: Read the bits at 0000 0000 XXXX XXXX (may want to make this filter) Branch:
00001320                           424                  ;                       1) 00 111 100: EORI TO CCR (need to read data, I think)
00001320                           425                  ;                       2) 01 111 100: EORI TO SR (need to read data, I think)
00001320                           426                  ;                       3) (default) EORI. Now, read and store:
00001320                           427                  ;                           SIZE:       0000 0000 XX00 0000 (need to make this filter)
00001320                           428                  ;                           MODE:       0000 0000 00XX X000 (FILT_SRC_MODE)
00001320                           429                  ;                           REGISTER:   0000 0000 0000 0XXX (FILT_SRC_REG)
00001320                           430                  ;                           only mandatory additional data is the immediate data.
00001320                           431                  ;                   iv.  011: ADDI. Now read and store:
00001320                           432                  ;                           SIZE:       0000 0000 XX00 0000 (need to make this filter)
00001320                           433                  ;                           MODE:       0000 0000 00XX X000 (FILT_SRC_MODE)
00001320                           434                  ;                           REGISTER:   0000 0000 0000 0XXX (FILT_SRC_REG)
00001320                           435                  ;                           only mandatory additional data is the immediate data.
00001320                           436                  ;                   v.   010: SUBI. Now read and store:
00001320                           437                  ;                           SIZE:       0000 0000 XX00 0000 (need to make this filter)
00001320                           438                  ;                           MODE:       0000 0000 00XX X000 (FILT_SRC_MODE)
00001320                           439                  ;                           REGISTER:   0000 0000 0000 0XXX (FILT_SRC_REG)
00001320                           440                  ;                           only mandatory additional data is the immediate data.
00001320                           441                  ;                   vi.  110: CMPI. Now read and store:
00001320                           442                  ;                           SIZE:       0000 0000 XX00 0000 (need to make this filter)
00001320                           443                  ;                           MODE:       0000 0000 00XX X000 (FILT_SRC_MODE)
00001320                           444                  ;                           REGISTER:   0000 0000 0000 0XXX (FILT_SRC_REG)
00001320                           445                  ;                           only mandatory additional data is the immediate data.
00001320                           446                  ;                   vii. 100: BTST, BCHG, BCLR, BSET (TODO: expand this section if we need these OPcodes)
00001320                           447                  ;                   viii.(default): BTST, BCHG, BCLR, BSET (with data register)(TODO: expand this section if we need these OPcodes)
00001320                           448                  ;               b) 0001: (MOVE.B). Now read and store:
00001320                           449                  ;                           DESTINATION REGISTER: 0000 XXX0 0000 0000 (FILT_DEST_REG)
00001320                           450                  ;                           DESTINATION MODE:     0000 000X XX00 0000 (FILT_DEST_MODE)
00001320                           451                  ;                           SOURCE MODE:          0000 0000 00XX X000 (FILT_SCR_MODE)
00001320                           452                  ;                           SOURCE REGISTER:      0000 0000 0000 0XXX (FILT_SRC_REG)
00001320                           453                  ;                           The modes (and maybe register) will tell us whether we need to read additional data for this MOVE.
00001320                           454                  ;               c) 0011: (MOVE.W). Now read and store:
00001320                           455                  ;                           DESTINATION REGISTER: 0000 XXX0 0000 0000 (FILT_DEST_REG)
00001320                           456                  ;                           DESTINATION MODE:     0000 000X XX00 0000 (FILT_DEST_MODE)
00001320                           457                  ;                           SOURCE MODE:          0000 0000 00XX X000 (FILT_SCR_MODE)
00001320                           458                  ;                           SOURCE REGISTER:      0000 0000 0000 0XXX (FILT_SRC_REG)
00001320                           459                  ;                           The modes (and maybe register) will tell us whether we need to read additional data for this MOVE.
00001320                           460                  ;               d) 0010: (MOVE.L). Now read and store:
00001320                           461                  ;                           DESTINATION REGISTER: 0000 XXX0 0000 0000 (FILT_DEST_REG)
00001320                           462                  ;                           DESTINATION MODE:     0000 000X XX00 0000 (FILT_DEST_MODE)
00001320                           463                  ;                           SOURCE MODE:          0000 0000 00XX X000 (FILT_SCR_MODE)
00001320                           464                  ;                           SOURCE REGISTER:      0000 0000 0000 0XXX (FILT_SRC_REG)
00001320                           465                  ;                           The modes (and maybe register) will tell us whether we need to read additional data for this MOVE.
00001320                           466                  ;               e) 0100: Read the bits at 0000 XXXX 0000 0000 (need filter) Branch:
00001320                           467                  ;                   i.      0000: Read the bits at 0000 0000 XX00 0000 (need filter) Branch:
00001320                           468                  ;                               1. 11: MOVE from SR. (TODO)
00001320                           469                  ;                               2. (DEFAULT) NEGX. (the two bits are size) (TODO)
00001320                           470                  ;                   ii.     0100: Read the bits at 0000 0000 XX00 0000 (need filter) Branch:
00001320                           471                  ;                               1. 11 MOVE to CCR. (TODO)
00001320                           472                  ;                               2. (DEFAULT) NEG. (the two bits are size) (TODO)
00001320                           473                  ;                   iii.    0110: Read the bits at 0000 0000 XX00 0000 (need filter) Branch:
00001320                           474                  ;                               1. 11 MOVE to SR. (TODO)
00001320                           475                  ;                               2. (DEFAULT) NOT. (the two bits are size) (TODO)
00001320                           476                  ;                   iv.     0010: CLR. (TODO)
00001320                           477                  ;                    v.     1000: (EXT, NBCD, SWAP, PEA, MOVEM (dir 0)) (TODO)
00001320                           478                  ;                   vi.     1010: Check the bits at 0000 XX00 0000 0000 (need filter) Branch:
00001320                           479                  ;                           1. 11: check the bits at 0000 00XX XXXX XXXX (need filter) Branch:
00001320                           480                  ;                               a. 11 1100: ILLEGAL (TODO)
00001320                           481                  ;                               b. (default) TAS (TODO)
00001320                           482                  ;                           2. (default) TST (TODO)
00001320                           483                  ;                  vii.     1110: (TRAP, LINK, UNLK, MOVE USP, RESET, NOP, STOP, RTE, RTS, TRAPV, RTR, JSR, JMP) (TODO)
00001320                           484                  ;                 viii.     (DEFAULT): (MOVEM, LEA, CHK,) (TODO)    
00001320                           485                  ;               f) 0101: (ADDQ, SUBQ, Scc, DBcc): Read the bits at 0000 0000 XX00 0000 (need filter) Branch:
00001320                           486                  ;                    i. 11: Read the bit at 0000 000X 0000 0000 (need filter) Branch:
00001320                           487                  ;                           1. 0: ADDQ (TODO)
00001320                           488                  ;                           2. 1: SUBQ (TODO)
00001320                           489                  ;                   ii. (default) (bits are size) read the bits at 0000 00XX X000 (FILT_SRC_MODE). Branch:
00001320                           490                  ;                           1. 001: DBCC (TODO)
00001320                           491                  ;                           2. (default): Scc (TODO)
00001320                           492                  ;               g) 0110: Read the bit at 0000 XXXX 0000 0000 (need filter) Branch:
00001320                           493                  ;                    i. 0000: BRA (TODO)
00001320                           494                  ;                   ii. 0001: BSR (TODO)
00001320                           495                  ;                  iii. (default) Bcc (TODO)
00001320                           496                  ;               h) 0111: MOVEQ (TODO)
00001320                           497                  ;               i) 1000: (DIVU, DIVS, SBCD, OR) (TODO)
00001320                           498                  ;               j) 1001: (SUB, SUBX, SUBA) (TODO)
00001320                           499                  ;               k) 1011: (EOR, CMPM, CMP, CMPA) (TODO)
00001320                           500                  ;               l) 1100: (MULU, MULS, ABCD, EXG, AND) (TODO)
00001320                           501                  ;               m) 1101: (ADD, ADDX, ADDA) (TODO)
00001320                           502                  ;               n) 1110: (ASd, LSd, ROXd, ROd, ASd, LSd, ROXd, ROd) (TODO)
00001320                           503                  ;               o) (default) The code is invalid. Not yet sure what we do in this case.
00001320                           504                  ;   
00001320                           505                  ;   
00001320                           506                  ;
00001320                           507                  
00001320                           508                  ;TODO: Use AND operations with filters to create values which can be
00001320                           509                  ;      checked against constants to narrow down OPcodes.
00001320                           510                  
00001320                           511                  ;TODO: Since it will take a while to decode every possible OPcode, we
00001320                           512                  ;      should first have a default "Error" subroutine which the program
00001320                           513                  ;      branches to once all other possibilities have been ruled out.
00001320                           514  
00001320                           515  *------------------- Read current OPcode -------------------
00001320                           516  ; By this point, CURRENT_WORD should store a potential beginning of an instruction, so we should not increment A5.
00001320  6000 0028                517  READ_CURRENT_OP         BRA         CHECK_CONSTANTS
00001324                           518                          
00001324                           519    
00001324                           520  *------------------- Display current address we are reading -------------------
00001324  43F9 00001ABD            521  DISPLAY_CURRENT_ADDRESS LEA         DOLLAR,A1       ; '$'
0000132A  103C 000E                522                          MOVE.B      #14,D0
0000132E  4E4F                     523                          TRAP        #15
00001330                           524                  
00001330  220C                     525                          MOVE.L      A4,D1           ; display the address the instruction was found at
00001332  143C 0010                526                          MOVE.B      #16,D2
00001336  103C 000F                527                          MOVE.B      #15,D0
0000133A  4E4F                     528                          TRAP        #15
0000133C                           529  
0000133C  43F9 00001ABB            530                          LEA         SPACE,A1        ; ' '
00001342  103C 000E                531                          MOVE.B      #14,D0      
00001346  4E4F                     532                          TRAP        #15     
00001348                           533                          
00001348  4E75                     534                          RTS
0000134A                           535   
0000134A                           536  *------------------ Check current word for constants---------
0000134A                           537  ; By this point, the current word should store a potential beginning of an instruction.                   
0000134A  0C79 4E70 00001D04       538  CHECK_CONSTANTS         CMP         #RESET_CODE,(CURRENT_WORD)
00001352  6700 001E                539                          BEQ         RESET_FOUND
00001356  0C79 4E71 00001D04       540                          CMP         #NOP_CODE,(CURRENT_WORD)
0000135E  6700 0030                541                          BEQ         NOP_FOUND
00001362  0C79 4E72 00001D04       542                          CMP         #STOP_CODE,(CURRENT_WORD)
0000136A  6700 0042                543                          BEQ         STOP_FOUND
0000136E  6000 0042                544                          BRA         CHECK_NON_CONSTANTS     ;Once we rule out all the constants we know of, we check for non-constants.
00001372                           545  
00001372                           546  ; TODO: change the structure of these subroutines to be like the nice structure used in EA SRs.
00001372                           547                         
00001372  61B0                     548  RESET_FOUND             BSR         DISPLAY_CURRENT_ADDRESS
00001374                           549  
00001374  43F9 00001CAD            550                          LEA         RESET_MSG,A1    ; 'RESET'
0000137A  103C 000E                551                          MOVE.B      #14,D0
0000137E  4E4F                     552                          TRAP        #15
00001380                           553                          
00001380  43F9 00001AB8            554                          LEA         RETURN,A1       ; (return)
00001386  103C 000E                555                          MOVE.B      #14,D0
0000138A  4E4F                     556                          TRAP        #15
0000138C                           557                 
0000138C  6000 FF64                558                          BRA         GO_TO_NEXT_OP   
00001390                           559   
00001390                           560  ; NOTE: this SR is temporary. Once we have the display buffer, it will work differently.                 
00001390  6192                     561  NOP_FOUND               BSR         DISPLAY_CURRENT_ADDRESS
00001392                           562  
00001392  43F9 00001CB3            563                          LEA         NOP_MSG,A1    ; 'NOP'
00001398  103C 000E                564                          MOVE.B      #14,D0
0000139C  4E4F                     565                          TRAP        #15
0000139E                           566                          
0000139E  43F9 00001AB8            567                          LEA         RETURN,A1     ; (return)
000013A4  103C 000E                568                          MOVE.B      #14,D0
000013A8  4E4F                     569                          TRAP        #15
000013AA                           570                 
000013AA  6000 FF46                571                          BRA         GO_TO_NEXT_OP   ; when we are done parsing and displaying the NOP instruction, go to the next OPcode.
000013AE                           572  
000013AE  4EF8 1004                573  STOP_FOUND              JMP         STOP  ;TODO: case for stop found. (NOTE that STOP instructions have additional data.)               
000013B2                           574  
000013B2                           575  ;TODO: add cases for rest of valid constant OPcodes here
000013B2                           576  
000013B2                           577  *----------------- Check current word for non-constants---------
000013B2                           578  ;NOTE: we currently know that CURRENT_WORD is not a constant by the time we reach this SR.
000013B2                           579  
000013B2  6100 011C                580  CHECK_NON_CONSTANTS     BSR         CHECK_MOVE        ; MOVE is a special case because of how its first nibble is structured.     
000013B6  6100 013E                581                          BSR         CHECK_MOVEQ       ; MOVEQ is also a special case.
000013BA  6100 0150                582                          BSR         CHECK_EXT         ; need to rule out EXT before checking MOVEM, because they have very similar OPcodes.
000013BE  6100 0162                583                          BSR         CHECK_MOVEM      
000013C2  6100 000A                584                          BSR         CHECK_NIB1_0000 
000013C6  6100 001C                585                          BSR         CHECK_NIB1_0100 
000013CA                           586                          
000013CA                           587                          ; TODO: BSR to checks for other special cases, along with nibbles.
000013CA                           588                          
000013CA                           589                          ;NOTE: we do not check for most specific instructions here.
000013CA                           590  
000013CA                           591                          ; TODO: go into the subroutines below and *fully* implement the followings:
000013CA                           592                          *   -MOVEM  (W,L)
000013CA                           593                          *   -ADD    (B,W,L) (will need shahin's size filter for this and below)
000013CA                           594                          *   -ADDA   (W,L)
000013CA                           595                          *   -ADDI   (B,W,L)
000013CA                           596                          *   -SUB    (B,W,L)
000013CA                           597                          ;etc
000013CA  4EF8 1004                598                          JMP         STOP
000013CE                           599                          ;TODO: check for other instructions instead of stopping if it's not one of these.
000013CE                           600    
000013CE                           601  *-----------------------First 4bit checks go here-----------------------------------
000013CE                           602    
000013CE                           603  *-----------------------Check if the current word starts with 0000--------------------
000013CE  4243                     604  CHECK_NIB1_0000         CLR         D3
000013D0  3639 00001D04            605                          MOVE.W      CURRENT_WORD,D3
000013D6  0243 F000                606                          ANDI.W      #FILT_NIB_1,D3  ; filter out the first 4 bits of the word
000013DA  B67C 0000                607                          CMP         #CONST_ALL_0,D3 ; see if they are all 0
000013DE  6700 001A                608                          BEQ         CONFIRM_NIB1_0000
000013E2  4E75                     609                          RTS 
000013E4                           610                          
000013E4  4243                     611  CHECK_NIB1_0100         CLR         D3 
000013E6  3639 00001D04            612                          MOVE.W      CURRENT_WORD,D3
000013EC  0243 F000                613                          ANDI.W      #FILT_NIB_1,D3      ; filter out the first 4 bits of the word
000013F0  B67C 4000                614                          CMP         #CONST_NIB1_0100,D3 ; see if they are 0100
000013F4  6700 005A                615                          BEQ         CONFIRM_NIB1_0100
000013F8  4E75                     616                          RTS                        
000013FA                           617                          
000013FA                           618  *-----------------------First 4bit confirms go here--------------------------------------
000013FA                           619  
000013FA                           620  *-----------------------Cases where the current word starts with 0000--------------------                       
000013FA  4243                     621  CONFIRM_NIB1_0000       CLR         D3
000013FC  3639 00001D04            622                          MOVE.W      CURRENT_WORD,D3
00001402  0243 0100                623                          ANDI.W      #FILT_BIT_8,D3  ; turn word into 0000 000X 0000 0000
00001406  E04B                     624                          LSR.W       #8,D3           ; turn word into 0000 0000 0000 000X
00001408  B67C 0000                625                          CMP         #CONST_ALL_0,D3 ; see if the word is still 0.
0000140C  6700 0004                626                          BEQ         CONFIRM_0000_XXX0
00001410                           627                          ; if we get to here, then the word must be BCHG, BCLR, BSET, or MOVEP.
00001410                           628                          ; BCHG is required
00001410                           629                          ; if our disassembler doesn't consider any of those valid, there should be an error message here.
00001410  4E75                     630                          RTS 
00001412                           631                          
00001412                           632  ; at this point, the word is of the form 0000 XXX0...
00001412  4243                     633  CONFIRM_0000_XXX0       CLR         D3
00001414  3639 00001D04            634                          MOVE.W      CURRENT_WORD,D3
0000141A  0243 0E00                635                          ANDI.W      #FILT_DEST_REG,D3  ; turn word into 0000 XXX0 0000 0000          
0000141E                           636                          
0000141E                           637                          ; now figure out which operation we have: (note that constants have been ruled out by this point)
0000141E                           638                          
0000141E  B67C 0000                639                          CMP         #CONST_ORI_DEST_REG,D3  ; ORI 
00001422  6700 0276                640                          BEQ         ORI_FOUND           
00001426                           641                          
00001426  B67C 0200                642                          CMP         #CONST_ANDI_DEST_REG,D3 ; ANDI 
0000142A  6700 0272                643                          BEQ         ANDI_FOUND
0000142E                           644                          
0000142E  B67C 0400                645                          CMP         #CONST_SUBI_DEST_REG,D3 ; SUBI
00001432  6700 026E                646                          BEQ         SUBI_FOUND
00001436                           647                          ;
00001436  B67C 0600                648                          CMP         #CONST_ADDI_DEST_REG,D3 ; ADDI
0000143A  6700 026A                649                          BEQ         ADDI_FOUND
0000143E                           650                          
0000143E  B67C 0A00                651                          CMP         #CONST_EORI_DEST_REG,D3 ; EORI
00001442  6700 0266                652                          BEQ         EORI_FOUND
00001446                           653                          
00001446  B67C 0C00                654                          CMP         #CONST_CMPI_DEST_REG,D3 ; CMPI
0000144A  6700 0262                655                          BEQ         CMPI_FOUND
0000144E                           656                          
0000144E                           657                          ;TODO: remaining: BTST, BCHG, BCLR, or BSET. 
0000144E                           658                          ;      if none of them, an error case should occur here.
0000144E                           659                          ;     (note that BCHG is required, though we don't know which version.)
0000144E                           660                          
0000144E  4E75                     661                          RTS     ;change RTS to whatever branch instruction is appropriate here.
00001450                           662                          
00001450                           663  *-----------------------Cases where the current word starts with 0100-----------------
00001450                           664  
00001450                           665      ; if we were doing every OPcode, would start by checking for MOVE from SR, MOVE to CCR, and MOVE to SR at the top of this SR.
00001450                           666      ; instead, we start with NEGX.
00001450  4243                     667  CONFIRM_NIB1_0100       CLR         D3              
00001452  3639 00001D04            668                          MOVE.W      CURRENT_WORD,D3
00001458  0243 0800                669                          ANDI.W      #FILT_BIT_5,D3  ; turn word into 0000 X000 0000 0000
0000145C  E04B                     670                          LSR.W       #8,D3           ; turn word into 0000 0000 0000 000X
0000145E  E64B                     671                          LSR.W       #3,D3
00001460  B67C 0000                672                          CMP         #CONST_ALL_0,D3 ; see if the word is still 0.
00001464  6700 0006                673                          BEQ         CONFIRM_0100_0XXX   ; branch based on the 5th bit.
00001468  6000 0032                674                          BRA         CONFIRM_0100_1XXX
0000146C                           675                          
0000146C  4243                     676  CONFIRM_0100_0XXX       CLR         D3              
0000146E  3639 00001D04            677                          MOVE.W      CURRENT_WORD,D3
00001474  0243 0F00                678                          ANDI.W      #FILT_NIB_2,D3  ; turn word into 0000 XXXX 0000 0000
00001478                           679                          
00001478                           680                          ; now figure out which operation we have:
00001478                           681                          
00001478  B67C 0000                682                          CMP         #CONST_NEGX_OP,D3
0000147C  6700 0234                683                          BEQ         NEGX_FOUND
00001480                           684                          
00001480  B67C 0200                685                          CMP         #CONST_CLR_OP,D3
00001484  6700 0230                686                          BEQ         CLR_FOUND
00001488                           687                          
00001488  B67C 0400                688                          CMP         #CONST_NEG_OP,D3
0000148C  6700 022C                689                          BEQ         NEG_FOUND
00001490                           690                          
00001490  B67C 0600                691                          CMP         #CONST_NOT_OP,D3
00001494  6700 0228                692                          BEQ         NOT_FOUND         ; note that we could likely make a conflicting SR name with one.
00001498                           693                          
00001498                           694                          ; TODO: we definitely have an error at this point.
00001498                           695                          
00001498  4EF8 1004                696                          JMP         STOP     ;change STOP to whatever we want based on error. (probably some error case which will then branch to reading next OPcode.)
0000149C                           697                          
0000149C  4243                     698  CONFIRM_0100_1XXX       CLR         D3
0000149E  3639 00001D04            699                          MOVE.W      CURRENT_WORD,D3
000014A4  0243 0F00                700                          ANDI.W      #FILT_NIB_2,D3  ; turn word into 0000 XXXX 0000 0000
000014A8                           701                          
000014A8  B67C 0800                702                          CMP         #CONST_NIB2_1000,D3
000014AC  6700 0016                703                          BEQ         CONFIRM_0100_1000
000014B0                           704  
000014B0  B67C 0A00                705                          CMP         #CONST_NIB2_1010,D3
000014B4  6700 0012                706                          BEQ         CONFIRM_0100_1010 
000014B8                           707  
000014B8  B67C 0E00                708                          CMP         #CONST_NIB2_1110,D3
000014BC  6700 000E                709                          BEQ         CONFIRM_0100_1110 
000014C0                           710                          ; TODO: make MOVEM a special case since it has an unusual OPcode.
000014C0                           711                          ; TODO: remaining possibilities are MOVEM, LEA, or CHK. (the first two are required.)
000014C0                           712  
000014C0  4EF8 1004                713                          JMP         STOP                      
000014C4                           714                     
000014C4  4EF8 1004                715  CONFIRM_0100_1000       JMP         STOP                       
000014C8                           716  ; TODO: check for EXT, NBCD, SWAP, or PEA.               
000014C8                           717   
000014C8  4EF8 1004                718  CONFIRM_0100_1010       JMP         STOP  
000014CC                           719  ; TODO: check for TAS or TST. (ILLEGAL is already ruled out.)         
000014CC                           720         
000014CC  4EF8 1004                721  CONFIRM_0100_1110       JMP         STOP       
000014D0                           722  ; TODO: check for TRAP, LINK, UNLK, MOVE USP, JSR, or JMP. (some of these are required.)
000014D0                           723  
000014D0                           724  *-----------------------Cases where the current word starts with 0101-----------------
000014D0                           725      ;TODO: ADDQ, SUBQ, Scc, DBcc (some of these are required)
000014D0                           726   
000014D0                           727  *-----------------------Cases where the current word starts with 0110-----------------
000014D0                           728      ;TODO: BRA, BSR, Bcc (some of these are required)   
000014D0                           729      
000014D0                           730  *-----------------------Cases where the current word starts with 1000-----------------
000014D0                           731      ;TODO: DIVU, DIVS, SBCD, OR (some of these are required)   
000014D0                           732      
000014D0                           733  *-----------------------Cases where the current word starts with 1001-----------------
000014D0                           734      ;TODO: SUB, SUBX, SUBA (some of these are required) 
000014D0                           735   
000014D0                           736  *-----------------------Cases where the current word starts with 1011-----------------
000014D0                           737      ;TODO: EOR, CMPM, CMP, CMPA (some of these are required)  
000014D0                           738      
000014D0                           739  *-----------------------Cases where the current word starts with 1100-----------------
000014D0                           740      ;TODO: MULU, MULS, ABCD, EXG, AND (some of these are required) 
000014D0                           741      
000014D0                           742  *-----------------------Cases where the current word starts with 1101-----------------
000014D0                           743      ;TODO: ADD, ADDX, ADDA (some of these are required) 
000014D0                           744      
000014D0                           745  *-----------------------Cases where the current word starts with 1110-----------------
000014D0                           746      ;TODO: ASR, ASL, LSR, LSL, ROXR, ROXL, ROR, ROL (these are all repeated twice on the sheet for some reason) 
000014D0                           747                                                      ;(some of these are required) 
000014D0                           748   
000014D0                           749  *-----------------------Special OPcode (but not constants) have checks here------------
000014D0                           750  * includes MOVE, MOVEQ, etc
000014D0                           751                                  
000014D0                           752  *-----------------------Check current word for MOVE------------------------------------
000014D0                           753  *MOVE can be B,W, or L.
000014D0  4243                     754  CHECK_MOVE              CLR         D3
000014D2  3639 00001D04            755                          MOVE.W      CURRENT_WORD,D3
000014D8  0243 F000                756                          ANDI.W      #FILT_NIB_1,D3
000014DC  B67C 1000                757                          CMP         #CONST_MOVE_B,D3
000014E0  6700 0056                758                          BEQ         MOVE_B_FOUND
000014E4  B67C 3000                759                          CMP         #CONST_MOVE_W,D3
000014E8  6700 007E                760                          BEQ         MOVE_W_FOUND
000014EC  B67C 2000                761                          CMP         #CONST_MOVE_L,D3
000014F0  6700 00A6                762                          BEQ         MOVE_L_FOUND
000014F4  4E75                     763                          RTS 
000014F6                           764                          
000014F6                           765  *-----------------------Check current word for MOVEQ------------------------------------
000014F6                           766  *MOVEQ can only be L.                       
000014F6  4243                     767  CHECK_MOVEQ             CLR         D3
000014F8  3639 00001D04            768                          MOVE.W      CURRENT_WORD,D3
000014FE  0243 F000                769                          ANDI.W      #FILT_NIB_1,D3
00001502  B67C 7000                770                          CMP         #CONST_MOVEQ,D3
00001506  6700 00FC                771                          BEQ         MOVEQ_FOUND
0000150A  4E75                     772                          RTS 
0000150C                           773                          
0000150C                           774  
0000150C                           775  *-----------------------Check current word for EXT------------------------------------  
0000150C                           776  *check EXT before MOVEM, since they can be easily confused.
0000150C                           777  *EXT can be W or L.                  
0000150C  4243                     778  CHECK_EXT               CLR         D3                  
0000150E  3639 00001D04            779                          MOVE.W      CURRENT_WORD,D3
00001514  0243 FFB8                780                          ANDI.W      #FILT_EXT,D3
00001518  B67C 4880                781                          CMP         #CONST_EXT,D3
0000151C  6700 0174                782                          BEQ         EXT_FOUND
00001520  4E75                     783                          RTS 
00001522                           784                          
00001522                           785  *-----------------------Check current word for MOVEM------------------------------------  
00001522                           786  *MOVEM can be W or L.                  
00001522  4243                     787  CHECK_MOVEM             CLR         D3
00001524  3639 00001D04            788                          MOVE.W      CURRENT_WORD,D3
0000152A  0243 FB80                789                          ANDI.W      #FILT_MOVEM,D3
0000152E  B67C 8880                790                          CMP         #CONST_MOVEM,D3
00001532  6700 0162                791                          BEQ         MOVEM_FOUND
00001536  4E75                     792                          RTS 
00001538                           793                          
00001538                           794  *---------------------- END OPWORD CHECKS -----------------------------------------
00001538                           795  
00001538                           796  *---------------------- BEGIN CASES FOR FOUND OPCODES------------------------------
00001538                           797  
00001538                           798  *-----------------------MOVE-related Subroutines------------------------------------
00001538                           799  
00001538                           800  *-----------------------Cases for finding different MOVE OPcodes------------------------------------
00001538                           801  *MOVE.B
00001538  13FC 0000 00001D06       802  MOVE_B_FOUND            MOVE.B      #BYTE_SIZE,CURRENT_OP_SIZE
00001540  6100 FDE2                803                          BSR         DISPLAY_CURRENT_ADDRESS
00001544  6100 0082                804                          BSR         PARSE_MOVE_DATA                           
00001548                           805                         
00001548  43F9 00001CC1            806                          LEA         MOVE_B_MSG,A1      ; 'MOVE.B'
0000154E  103C 000E                807                          MOVE.B      #14,D0
00001552  4E4F                     808                          TRAP        #15
00001554                           809                          
00001554  43F9 00001ABB            810                          LEA         SPACE,A1           ; ' '
0000155A  103C 000E                811                          MOVE.B      #14,D0      
0000155E  4E4F                     812                          TRAP        #15
00001560                           813                          
00001560  6100 0080                814                          BSR         DISPLAY_MOVE_DATA
00001564  6000 FD8C                815                          BRA         GO_TO_NEXT_OP
00001568                           816  
00001568                           817  *MOVE.W                        
00001568  13FC 0001 00001D06       818  MOVE_W_FOUND            MOVE.B      #WORD_SIZE,CURRENT_OP_SIZE
00001570  6100 FDB2                819                          BSR         DISPLAY_CURRENT_ADDRESS
00001574  6100 0052                820                          BSR         PARSE_MOVE_DATA       
00001578                           821                          
00001578  43F9 00001CC8            822                          LEA         MOVE_W_MSG,A1      ; 'MOVE.W'
0000157E  103C 000E                823                          MOVE.B      #14,D0
00001582  4E4F                     824                          TRAP        #15
00001584                           825                          
00001584  43F9 00001ABB            826                          LEA         SPACE,A1           ; ' '
0000158A  103C 000E                827                          MOVE.B      #14,D0      
0000158E  4E4F                     828                          TRAP        #15
00001590                           829                          
00001590  6100 0050                830                          BSR         DISPLAY_MOVE_DATA
00001594  6000 FD5C                831                          BRA         GO_TO_NEXT_OP  
00001598                           832  
00001598                           833  *MOVE.L                        
00001598  13FC 0002 00001D06       834  MOVE_L_FOUND            MOVE.B      #LONG_SIZE,CURRENT_OP_SIZE
000015A0  6100 FD82                835                          BSR         DISPLAY_CURRENT_ADDRESS
000015A4  6100 0022                836                          BSR         PARSE_MOVE_DATA       
000015A8                           837                          
000015A8  43F9 00001CCF            838                          LEA         MOVE_L_MSG,A1      ; 'MOVE.L'
000015AE  103C 000E                839                          MOVE.B      #14,D0
000015B2  4E4F                     840                          TRAP        #15
000015B4                           841                          
000015B4  43F9 00001ABB            842                          LEA         SPACE,A1           ; ' '
000015BA  103C 000E                843                          MOVE.B      #14,D0      
000015BE  4E4F                     844                          TRAP        #15
000015C0                           845                          
000015C0  6100 0020                846                          BSR         DISPLAY_MOVE_DATA
000015C4  6000 FD2C                847                          BRA         GO_TO_NEXT_OP 
000015C8                           848                         
000015C8                           849  *-----------------------Parse data for any-sized MOVE instruction---------------------
000015C8                           850  *Note that the size of the MOVE is stored in CURRENT_OP_SIZE.
000015C8                           851  PARSE_MOVE_DATA         ; TODO: error checking 
000015C8                           852                          ;(maybe after reading the first 4 instruction parts, but before reading additional data)
000015C8                           853                          ;IMPORTANT: remember that different MOVE error are specific to different MOVE sizes.
000015C8                           854                          ; example: MOVE.B  A0,D3 is invalid. However, MOVE.W  A0,D3 is valid.
000015C8                           855                          ;
000015C8                           856                          ; possible errors:
000015C8                           857                          ;       CURRENT_DEST_MD = CONST_IMMEDIATE_REG (immediate data cannot be a destination)
000015C8                           858                          ;       CURRENT_SRC_MD  = CONST_ADDR_REG_MD   (byte is not a valid size for this move)
000015C8                           859                          ;       CURRENT_DEST_MD = CONST_ADDR_REG_MD   (byte is not a valid size, although we should be using MOVEA at this point, not MOVE.)
000015C8                           860                          ;       TODO: figure out other possible errors.
000015C8                           861                          
000015C8                           862                          ; after we confirm that there are no errors, we know that we can safely check for additional data and display the instruction.
000015C8                           863                          
000015C8                           864                          
000015C8                           865                          ; at this point, need to read more information (parsed by EA, probably)
000015C8                           866                          ; now that we have a move instruction, we set our EA variables accordingly:
000015C8  6100 00F8                867                          BSR         READ_DEST_REG      ; EA will set CURRENT_DEST_REG.
000015CC  6100 0112                868                          BSR         READ_DEST_MODE     ; EA will set CURRENT_DEST_MD.
000015D0  6100 012A                869                          BSR         READ_SOURCE_MODE   ; EA will set CURRENT_SRC_MD.
000015D4  6100 0142                870                          BSR         READ_SOURCE_REG    ; EA will set CURRENT_SRC_REG.
000015D8                           871                          
000015D8                           872                          ; need to check whether we need to read additional data before we start displaying the
000015D8                           873                          ; instruction (for instance, this is necessary for MOVE.B #10,D0).
000015D8  6100 0158                874                          BSR         READ_SOURCE_DATA   ; EA will set CURRENT_SOURCE_DATA if necessary.
000015DC  6100 018E                875                          BSR         READ_DEST_DATA     ; EA will set CURRENT_DEST_DATA if necessary. 
000015E0  4E75                     876                          RTS         
000015E2                           877  
000015E2  6100 0256                878  DISPLAY_MOVE_DATA       BSR         DISPLAY_SOURCE     ; Tell EA to parse and display the source. EX: (A1)   D3    #10   $1000 etc
000015E6                           879                          
000015E6  43F9 00001ABF            880                          LEA         COMMA,A1           ; ','
000015EC  103C 000E                881                          MOVE.B      #14,D0      
000015F0  4E4F                     882                          TRAP        #15
000015F2                           883                          
000015F2  6100 027C                884                          BSR         DISPLAY_DEST       ; Tell EA to parse and display the destination.
000015F6                           885                          
000015F6  43F9 00001AB8            886                          LEA         RETURN,A1          ; (return)
000015FC  103C 000E                887                          MOVE.B      #14,D0
00001600  4E4F                     888                          TRAP        #15
00001602                           889  
00001602  4E75                     890                          RTS        
00001604                           891                           
00001604                           892  *-----------------------MOVEQ-related Subroutines------------------------------------
00001604                           893  
00001604                           894  *-----------------------Case for finding MOVEQ------------------------------------
00001604  13FC 0002 00001D06       895  MOVEQ_FOUND             MOVE.B      #LONG_SIZE,CURRENT_OP_SIZE
0000160C  6100 FD16                896                          BSR         DISPLAY_CURRENT_ADDRESS
00001610  6100 0022                897                          BSR         PARSE_MOVEQ_DATA       
00001614                           898                          
00001614  43F9 00001CD6            899                          LEA         MOVEQ_MSG,A1      ; 'MOVEQ'
0000161A  103C 000E                900                          MOVE.B      #14,D0
0000161E  4E4F                     901                          TRAP        #15
00001620                           902                          
00001620  43F9 00001ABB            903                          LEA         SPACE,A1           ; ' '
00001626  103C 000E                904                          MOVE.B      #14,D0      
0000162A  4E4F                     905                          TRAP        #15
0000162C                           906                          
0000162C  6100 0028                907                          BSR         DISPLAY_MOVEQ_DATA
00001630  6000 FCC0                908                          BRA         GO_TO_NEXT_OP  
00001634                           909  
00001634                           910  PARSE_MOVEQ_DATA        ;TODO: check that 0000 000X 0000 0000 equals zero. If not, error.
00001634                           911                          
00001634  6100 008C                912                          BSR         READ_DEST_REG                       ; EA will set CURRENT_DEST_REG.
00001638  13FC 0000 00001D0B       913                          MOVE.B      #CONST_DATA_REG_MD,CURRENT_DEST_MD  ; data register is the only allowed destination for MOVEQ.
00001640  6100 0036                914                          BSR         READ_MOVEQ_DATA                     ; 0000 0000 XXXX XXXX will set CURRENT_SOURCE_DATA (I think.)
00001644                           915                          
00001644  13FC 0007 00001D09       916                          MOVE.B      #CONST_ADDR_MISC_MD,CURRENT_SRC_MD
0000164C  13FC 0004 00001D0A       917                          MOVE.B      #CONST_IMMEDIATE_REG,CURRENT_SRC_REG
00001654                           918                          
00001654  4E75                     919                          RTS 
00001656                           920  
00001656  6100 01E2                921  DISPLAY_MOVEQ_DATA      BSR         DISPLAY_SOURCE     ; Tell EA to parse and display the source. 
0000165A                           922                          
0000165A  43F9 00001ABF            923                          LEA         COMMA,A1           ; ','
00001660  103C 000E                924                          MOVE.B      #14,D0      
00001664  4E4F                     925                          TRAP        #15
00001666                           926                          
00001666  6100 0208                927                          BSR         DISPLAY_DEST       ; Tell EA to parse and display the destination.
0000166A                           928                          
0000166A  43F9 00001AB8            929                          LEA         RETURN,A1          ; (return)
00001670  103C 000E                930                          MOVE.B      #14,D0
00001674  4E4F                     931                          TRAP        #15
00001676                           932  
00001676  4E75                     933                          RTS        
00001678                           934  
00001678                           935  ;NOTE: this SR is stored here and not in EA because it is specific to MOVEQ.
00001678  4244                     936  READ_MOVEQ_DATA         CLR         D4
0000167A  4279 00001D12            937                          CLR         CURRENT_SRC_DATA
00001680  3839 00001D04            938                          MOVE.W      CURRENT_WORD,D4
00001686  0244 00FF                939                          ANDI.W      #FILT_MOVEQ_DATA,D4        ; turn D4 into 0000 0000 XXXX XXXX (no shift necessary)
0000168A  33C4 00001D12            940                          MOVE.W      D4,CURRENT_SRC_DATA
00001690  4E75                     941                          RTS
00001692                           942                      
00001692                           943    ; TODO: (in order)
00001692                           944      *   -MOVEM  (W,L)
00001692                           945      *   -ADD    (B,W,L) (will need shahin's size filter for this and below)
00001692                           946      *   -ADDA   (W,L)
00001692                           947      *   -ADDI   (B,W,L)
00001692                           948      *   -SUB    (B,W,L)
00001692                           949    ; see comment block at the top of the program for the full list of codes.
00001692                           950    ; see huge comment block at the top of OPcode section for tentative OPcode parsing implementation plan.
00001692                           951   
00001692                           952  *-----------------------EXT-related Subroutines------------------------------------
00001692  4EF8 1004                953  EXT_FOUND               JMP         STOP ;TODO: case for EXT found
00001696                           954  
00001696                           955  *-----------------------MOVEM-related Subroutines------------------------------------
00001696  4EF8 1004                956  MOVEM_FOUND             JMP         STOP ;TODO: case for MOVEM found (currently the next goal)      
0000169A                           957    
0000169A                           958  *-----------------------ORI-related Subroutines------------------------------------
0000169A  4EF8 1004                959  ORI_FOUND               JMP         STOP ;TODO: case for ORI found
0000169E                           960  
0000169E                           961   *----------------------ANDI-related Subroutines------------------------------------
0000169E  4EF8 1004                962  ANDI_FOUND              JMP         STOP ;TODO: case for ANDI found
000016A2                           963  
000016A2                           964   *----------------------SUBI-related Subroutines------------------------------------
000016A2  4EF8 1004                965  SUBI_FOUND              JMP         STOP ;TODO: case for SUBI found
000016A6                           966  
000016A6                           967   *----------------------ADDI-related Subroutines------------------------------------
000016A6  4EF8 1004                968  ADDI_FOUND              JMP         STOP ;TODO: case for ADDI found
000016AA                           969   
000016AA                           970  *-----------------------EORI-related Subroutines------------------------------------
000016AA  4EF8 1004                971  EORI_FOUND              JMP         STOP ;TODO: case for EORI found
000016AE                           972   
000016AE                           973  *-----------------------CMPI-related Subroutines------------------------------------
000016AE  4EF8 1004                974  CMPI_FOUND              JMP         STOP ;TODO: case for CMPI found
000016B2                           975  
000016B2                           976  *-----------------------NEGX-related Subroutines------------------------------------
000016B2  4EF8 1004                977  NEGX_FOUND              JMP         STOP ;TODO: case for NEGX found 
000016B6                           978  
000016B6                           979  *-----------------------CLR-related Subroutines------------------------------------
000016B6  4EF8 1004                980  CLR_FOUND               JMP         STOP ;TODO: case for CLR found 
000016BA                           981  
000016BA                           982  *-----------------------NEG-related Subroutines------------------------------------
000016BA  4EF8 1004                983  NEG_FOUND               JMP         STOP ;TODO: case for NEG found 
000016BE                           984  
000016BE                           985  *-----------------------NOT-related Subroutines------------------------------------
000016BE  4EF8 1004                986  NOT_FOUND               JMP         STOP ;TODO: case for NOT found 
000016C2                           987                      
000016C2                           988  *###################### END OPCODE ##################################
000016C2                           989  *###################### BEGIN EA ##################################
000016C2                           990  *** EA Subroutines are kept here ***
000016C2                           991  *----------------------Check the destination register of the current word.-------------
000016C2  4244                     992  READ_DEST_REG           CLR         D4
000016C4  4239 00001D0C            993                          CLR.B       CURRENT_DEST_REG
000016CA  3839 00001D04            994                          MOVE.W      CURRENT_WORD,D4
000016D0  0244 0E00                995                          ANDI.W      #FILT_DEST_REG,D4       ; turn D4 into 0000 XXX0 0000 0000
000016D4  E04C                     996                          LSR.W       #8,D4                   ; turn D4 into 0000 0000 0000 0XXX
000016D6  E24C                     997                          LSR.W       #1,D4                   ; 9 would be invalid, so we shift 8, then 1
000016D8  13C4 00001D0C            998                          MOVE.B      D4,CURRENT_DEST_REG
000016DE  4E75                     999                          RTS
000016E0                          1000  
000016E0                          1001  *----------------------Check the destination mode of the current word.-------------
000016E0                          1002  *(assuming the destination is where it would be in MOVE).
000016E0  4244                    1003  READ_DEST_MODE          CLR         D4
000016E2  4239 00001D0B           1004                          CLR.B       CURRENT_DEST_MD
000016E8  3839 00001D04           1005                          MOVE.W      CURRENT_WORD,D4
000016EE  0244 01C0               1006                          ANDI.W      #FILT_DEST_MD,D4        ; turn D4 into 0000 000X XX00 0000
000016F2  EC4C                    1007                          LSR.W       #6,D4                   ; turn D4 into 0000 0000 0000 0XXX
000016F4  13C4 00001D0B           1008                          MOVE.B      D4,CURRENT_DEST_MD
000016FA  4E75                    1009                          RTS
000016FC                          1010  
000016FC                          1011  ;By this point, CURRENT WORD holds the first 16 bits of an instruction we are looking at.
000016FC                          1012  ;(we should already know the OPcode by this point, so this will be called by various OPcode subroutines.)
000016FC                          1013  *---------------------- Check the source mode of the current word.--------------------
000016FC                          1014  *(assuming the source is where it would be in MOVE).
000016FC  4244                    1015  READ_SOURCE_MODE        CLR         D4
000016FE  4239 00001D09           1016                          CLR.B       CURRENT_SRC_MD
00001704  3839 00001D04           1017                          MOVE.W      CURRENT_WORD,D4
0000170A  0244 0038               1018                          ANDI.W      #FILT_SRC_MD,D4                 ; turn source mode into 0000 0000 00XX X000
0000170E  E64C                    1019                          LSR.W       #3,D4                           ; turn source mode into 0000 0000 0000 0XXX
00001710  13C4 00001D09           1020                          MOVE.B      D4,CURRENT_SRC_MD
00001716  4E75                    1021                          RTS
00001718                          1022                          
00001718                          1023  *----------------------Check the source register of the current word.-----------------
00001718  4244                    1024  READ_SOURCE_REG         CLR         D4
0000171A  4239 00001D0A           1025                          CLR.B       CURRENT_SRC_REG
00001720  3839 00001D04           1026                          MOVE.W      CURRENT_WORD,D4
00001726  0244 0007               1027                          ANDI.W      #FILT_SRC_REG,D4        ; turn D4 into 0000 0000 0000 0XXX. (no need for LSR in this case.)
0000172A  13C4 00001D0A           1028                          MOVE.B      D4,CURRENT_SRC_REG
00001730  4E75                    1029                          RTS
00001732                          1030  *--------TODO: READ_OP_SIZE---------
00001732                          1031                         
00001732                          1032  *----------------------Read additional source data associated with the current word (if necessary).----------------- 
00001732                          1033  *This needs to postincrement A5 as necessary.
00001732  4279 00001D12           1034  READ_SOURCE_DATA        CLR         CURRENT_SRC_DATA
00001738  4279 00001D0E           1035                          CLR         CURRENT_DATA
0000173E  0C39 0007 00001D09      1036                          CMP.B       #CONST_ADDR_MISC_MD,CURRENT_SRC_MD ; check the source mode
00001746  6700 0004               1037                          BEQ         CONFIRM_READ_SRC_DATA              ; see if we have a source mode that requires additional data.               
0000174A  4E75                    1038                          RTS
0000174C                          1039                          
0000174C  4239 00001D08           1040  CONFIRM_READ_SRC_DATA   CLR.B       CURRENT_REG
00001752  13F9 00001D0A 00001D08  1041                          MOVE.B      CURRENT_SRC_REG,CURRENT_REG
0000175C  6100 0048               1042                          BSR         CONFIRM_READ_DATA
00001760  23F9 00001D0E 00001D12  1043                          MOVE.L      CURRENT_DATA,CURRENT_SRC_DATA
0000176A  4E75                    1044                          RTS
0000176C                          1045   
0000176C                          1046  *----------------------Read additional destination data associated with the current word (if necessary).----------------- 
0000176C                          1047  *This needs to postincrement A5 as necessary.                       
0000176C  4279 00001D16           1048  READ_DEST_DATA          CLR         CURRENT_DEST_DATA
00001772  4279 00001D0E           1049                          CLR         CURRENT_DATA
00001778  0C39 0007 00001D0B      1050                          CMP.B       #CONST_ADDR_MISC_MD,CURRENT_DEST_MD  ; check the destination mode.
00001780  6700 0004               1051                          BEQ         CONFIRM_READ_DEST_DATA               ; see if we have a destination mode that requires additional data.                  
00001784  4E75                    1052                          RTS
00001786                          1053                                              
00001786  4239 00001D08           1054  CONFIRM_READ_DEST_DATA  CLR.B       CURRENT_REG
0000178C  13F9 00001D0C 00001D08  1055                          MOVE.B      CURRENT_DEST_REG,CURRENT_REG
00001796  6100 000E               1056                          BSR         CONFIRM_READ_DATA
0000179A  23F9 00001D0E 00001D16  1057                          MOVE.L      CURRENT_DATA,CURRENT_DEST_DATA
000017A4  4E75                    1058                          RTS
000017A6                          1059  
000017A6                          1060  *-----------------------Read some additional data.----------------------------------------------------------
000017A6                          1061        ; This same subroutine is used for reading source and destination data.
000017A6                          1062        ; By this point, CURRENT_REG holds whatever register we currently care about. (could also use CURRENT_REG)         
000017A6  0C39 0002 00001D08      1063  CONFIRM_READ_DATA       CMP.B       #CONST_COUNTR_DISPLC_REG,CURRENT_REG      ; see if we are reading counter w/ displacement
000017AE  6700 0034               1064                          BEQ         READ_COUNTR_DISPLC_DATA
000017B2                          1065                     
000017B2  0C39 0003 00001D08      1066                          CMP.B       #CONST_COUNTR_INDEX_REG,CURRENT_REG       ; see if we are reading counter w/ index
000017BA  6700 002A               1067                          BEQ         READ_COUNTR_INDEX_DATA
000017BE                          1068                          
000017BE  0C39 0000 00001D08      1069                          CMP.B       #CONST_ABS_SHORT_REG,CURRENT_REG          ; see if we are reading absolute short address
000017C6  6700 0020               1070                          BEQ         READ_ABS_SHORT_DATA
000017CA                          1071                          
000017CA  0C39 0001 00001D08      1072                          CMP.B       #CONST_ABS_LONG_REG,CURRENT_REG           ; see if we are reading absolute long address
000017D2  6700 001C               1073                          BEQ         READ_ABS_LONG_DATA 
000017D6                          1074                          
000017D6  0C39 0004 00001D08      1075                          CMP.B       #CONST_IMMEDIATE_REG,CURRENT_REG          ; see if we are reading immediate data
000017DE  6700 0018               1076                          BEQ         READ_IMMEDIATE_DATA
000017E2                          1077       
000017E2  4E75                    1078                          RTS
000017E4                          1079                          
000017E4                          1080  ; TODO: each of these SRs should increment A5 by the proper amount while also storing the correct data in CURRENT_DATA.
000017E4  4E75                    1081  READ_COUNTR_DISPLC_DATA RTS ; TODO: read data for counter w/ displacement (d16,PC)
000017E6                          1082  
000017E6  4E75                    1083  READ_COUNTR_INDEX_DATA  RTS ; TODO: read data for counter w/ index        (d16,PC,Xn)
000017E8                          1084  
000017E8                          1085  *-----------------------Read additional absolute word address---------------------------
000017E8  33DD 00001D0E           1086  READ_ABS_SHORT_DATA     MOVE.W      (A5)+,CURRENT_DATA ; read data for absolute short address  (xxx).W
000017EE  4E75                    1087                          RTS
000017F0                          1088                          
000017F0                          1089  *-----------------------Read additional absolute long address---------------------------
000017F0  23DD 00001D0E           1090  READ_ABS_LONG_DATA      MOVE.L      (A5)+,CURRENT_DATA ; read data for absolute long address   (xxx).L
000017F6  4E75                    1091                          RTS 
000017F8                          1092  
000017F8                          1093  *-----------------------Read additional immediate data---------------------------
000017F8  0C39 0000 00001D06      1094  READ_IMMEDIATE_DATA     CMP.B       #BYTE_SIZE,CURRENT_OP_SIZE   ; see if we are reading immediate byte data
00001800  6700 001C               1095                          BEQ         READ_IMMEDIATE_DATA_W
00001804                          1096                          
00001804  0C39 0001 00001D06      1097                          CMP.B       #WORD_SIZE,CURRENT_OP_SIZE   ; see if we are reading immediate word data
0000180C  6700 0010               1098                          BEQ         READ_IMMEDIATE_DATA_W
00001810                          1099                          
00001810  0C39 0002 00001D06      1100                          CMP.B       #LONG_SIZE,CURRENT_OP_SIZE   ; see if we are reading immediate long data
00001818  6700 0012               1101                          BEQ         READ_IMMEDIATE_DATA_L
0000181C                          1102                          ;TODO: error case goes here
0000181C  4E75                    1103                          RTS
0000181E                          1104  
0000181E  4279 00001D0E           1105  READ_IMMEDIATE_DATA_W   CLR         CURRENT_DATA
00001824  33DD 00001D0E           1106                          MOVE.W      (A5)+,CURRENT_DATA
0000182A  4E75                    1107                          RTS
0000182C                          1108                          
0000182C  4279 00001D0E           1109  READ_IMMEDIATE_DATA_L   CLR         CURRENT_DATA
00001832  23DD 00001D0E           1110                          MOVE.L      (A5)+,CURRENT_DATA
00001838  4E75                    1111                          RTS
0000183A                          1112                          
0000183A                          1113  *----------------------Display the source for the current instruction.-----------------
0000183A                          1114  *by this point, error checking should already be done and CURRENT_SRC_MD and CURRENT_SRC_REG should have the data we need.
0000183A  4239 00001D07           1115  DISPLAY_SOURCE          CLR.B       CURRENT_MD
00001840  4239 00001D08           1116                          CLR.B       CURRENT_REG
00001846  42B9 00001D0E           1117                          CLR.L       CURRENT_DATA
0000184C                          1118                          
0000184C  13F9 00001D09 00001D07  1119                          MOVE.B      CURRENT_SRC_MD,CURRENT_MD
00001856  13F9 00001D0A 00001D08  1120                          MOVE.B      CURRENT_SRC_REG,CURRENT_REG    
00001860  23F9 00001D12 00001D0E  1121                          MOVE.L      CURRENT_SRC_DATA,CURRENT_DATA
0000186A  6100 003A               1122                          BSR         CHECK_ADDRESSING_MODES   
0000186E  4E75                    1123                          RTS  
00001870                          1124                          
00001870                          1125  *----------------------Display the destination for the current instruction.-----------------
00001870                          1126  *by this point, error checking should already be done and CURRENT_DEST_MD and CURRENT_DEST_REG should have the data we need.
00001870  4239 00001D07           1127  DISPLAY_DEST            CLR.B       CURRENT_MD
00001876  4239 00001D08           1128                          CLR.B       CURRENT_REG
0000187C  42B9 00001D0E           1129                          CLR.L       CURRENT_DATA
00001882                          1130                          
00001882  13F9 00001D0B 00001D07  1131                          MOVE.B      CURRENT_DEST_MD,CURRENT_MD
0000188C  13F9 00001D0C 00001D08  1132                          MOVE.B      CURRENT_DEST_REG,CURRENT_REG    
00001896  23F9 00001D16 00001D0E  1133                          MOVE.L      CURRENT_DEST_DATA,CURRENT_DATA
000018A0  6100 0004               1134                          BSR         CHECK_ADDRESSING_MODES     
000018A4  4E75                    1135                          RTS  
000018A6                          1136                          
000018A6                          1137  
000018A6                          1138                          
000018A6                          1139  *-----------------------Mode checks (for displaying)---------
000018A6                          1140  *these do not care whether the mode is for source or destination.
000018A6  0C39 0000 00001D07      1141  CHECK_ADDRESSING_MODES  CMP.B       #CONST_DATA_REG_MD,CURRENT_MD   ; check for CURRENT_MD = ...0000
000018AE  6700 0058               1142                          BEQ         DISPLAY_DATA_REG
000018B2  0C39 0001 00001D07      1143                          CMP.B       #CONST_ADDR_REG_MD,CURRENT_MD    ; check for CURRENT_MD = ...0001
000018BA  6700 006C               1144                          BEQ         DISPLAY_ADDR_REG
000018BE  0C39 0002 00001D07      1145                          CMP.B       #CONST_ADDR_IND_MD,CURRENT_MD    ; check for CURRENT_MD = ...0010
000018C6  6700 0080               1146                          BEQ         DISPLAY_ADDR_IND
000018CA  0C39 0003 00001D07      1147                          CMP.B       #CONST_ADDR_INCR_MD,CURRENT_MD   ; check for CURRENT_MD = ...0011
000018D2  6700 00AC               1148                          BEQ         DISPLAY_ADDR_INCR
000018D6  0C39 0004 00001D07      1149                          CMP.B       #CONST_ADDR_DECR_MD,CURRENT_MD   ; check for CURRENT_MD = ...0100
000018DE  6700 00E4               1150                          BEQ         DISPLAY_ADDR_DECR
000018E2  0C39 0005 00001D07      1151                          CMP.B       #CONST_ADDR_DISPLC_MD,CURRENT_MD ; check for CURRENT_MD = ...0101
000018EA  6700 011C               1152                          BEQ         DISPLAY_ADDR_DISPLC
000018EE  0C39 0006 00001D07      1153                          CMP.B       #CONST_ADDR_INDEX_MD,CURRENT_MD  ; check for CURRENT_MD = ...0110
000018F6  6700 0112               1154                          BEQ         DISPLAY_ADDR_INDEX
000018FA  0C39 0007 00001D07      1155                          CMP.B       #CONST_ADDR_MISC_MD,CURRENT_MD   ; check for CURRENT_MD = ...0111
00001902  6700 0108               1156                          BEQ         CHECK_MISC_ADDRESSINGS
00001906                          1157                          ;TODO: error cases? 
00001906  4E75                    1158                          RTS
00001908                          1159  
00001908                          1160  ; case for displaying data register.          
00001908  43F9 00001CDC           1161  DISPLAY_DATA_REG        LEA         MSG_D,A1               ; print out 'D' (later, send this to dislpay buffer)
0000190E  103C 000E               1162                          MOVE.B      #14,D0
00001912  4E4F                    1163                          TRAP        #15
00001914                          1164                          
00001914  4241                    1165                          CLR         D1
00001916  1239 00001D08           1166                          MOVE.B      (CURRENT_REG),D1      ; print out the number of the data register.
0000191C  143C 0010               1167                          MOVE.B      #16,D2
00001920  103C 000F               1168                          MOVE.B      #15,D0
00001924  4E4F                    1169                          TRAP        #15
00001926                          1170                          
00001926  4E75                    1171                          RTS
00001928                          1172  
00001928                          1173  ; case for displaying address register. 
00001928  43F9 00001CDE           1174  DISPLAY_ADDR_REG        LEA         MSG_A,A1               ; print out 'A'
0000192E  103C 000E               1175                          MOVE.B      #14,D0
00001932  4E4F                    1176                          TRAP        #15
00001934                          1177                          
00001934  4241                    1178                          CLR         D1
00001936  1239 00001D08           1179                          MOVE.B      (CURRENT_REG),D1       ; print out the number of the data register.
0000193C  143C 0010               1180                          MOVE.B      #16,D2
00001940  103C 000F               1181                          MOVE.B      #15,D0
00001944  4E4F                    1182                          TRAP        #15
00001946                          1183                          
00001946  4E75                    1184                          RTS
00001948                          1185  
00001948                          1186  ; case for displaying address register indirect.                        
00001948  43F9 00001AC3           1187  DISPLAY_ADDR_IND        LEA         OPEN_PARENS,A1         ; print out '(' (later, send this to dislpay buffer)
0000194E  103C 000E               1188                          MOVE.B      #14,D0
00001952  4E4F                    1189                          TRAP        #15
00001954                          1190                          
00001954  43F9 00001CDE           1191                          LEA         MSG_A,A1               ; print out 'A'
0000195A  103C 000E               1192                          MOVE.B      #14,D0
0000195E  4E4F                    1193                          TRAP        #15
00001960                          1194                          
00001960  4241                    1195                          CLR         D1
00001962  1239 00001D08           1196                          MOVE.B      (CURRENT_REG),D1      ; print out the number of the data register.
00001968  143C 0010               1197                          MOVE.B      #16,D2
0000196C  103C 000F               1198                          MOVE.B      #15,D0
00001970  4E4F                    1199                          TRAP        #15
00001972                          1200                          
00001972  43F9 00001AC5           1201                          LEA         CLOSE_PARENS,A1       ; print out ')'
00001978  103C 000E               1202                          MOVE.B      #14,D0
0000197C  4E4F                    1203                          TRAP        #15
0000197E                          1204                          
0000197E  4E75                    1205                          RTS
00001980                          1206  
00001980                          1207  ; case for displaying address indirect postincrement.
00001980  43F9 00001AC3           1208  DISPLAY_ADDR_INCR       LEA         OPEN_PARENS,A1        ; print out '(' (later, send this to dislpay buffer)
00001986  103C 000E               1209                          MOVE.B      #14,D0
0000198A  4E4F                    1210                          TRAP        #15
0000198C                          1211                          
0000198C  43F9 00001CDE           1212                          LEA         MSG_A,A1              ; print out 'A'
00001992  103C 000E               1213                          MOVE.B      #14,D0
00001996  4E4F                    1214                          TRAP        #15
00001998                          1215                          
00001998  4241                    1216                          CLR         D1
0000199A  1239 00001D08           1217                          MOVE.B      (CURRENT_REG),D1      ; print out the number of the data register.
000019A0  143C 0010               1218                          MOVE.B      #16,D2
000019A4  103C 000F               1219                          MOVE.B      #15,D0
000019A8  4E4F                    1220                          TRAP        #15
000019AA                          1221                          
000019AA  43F9 00001AC5           1222                          LEA         CLOSE_PARENS,A1       ; print out ')'
000019B0  103C 000E               1223                          MOVE.B      #14,D0
000019B4  4E4F                    1224                          TRAP        #15
000019B6                          1225                          
000019B6  43F9 00001AC7           1226                          LEA         PLUS,A1               ; print out '+'
000019BC  103C 000E               1227                          MOVE.B      #14,D0
000019C0  4E4F                    1228                          TRAP        #15
000019C2                          1229                          
000019C2  4E75                    1230                          RTS
000019C4                          1231                          
000019C4                          1232  ; case for displaying address indirect preedecrement mode.
000019C4  43F9 00001AC9           1233  DISPLAY_ADDR_DECR       LEA         MINUS,A1               ; print out '-'
000019CA  103C 000E               1234                          MOVE.B      #14,D0
000019CE  4E4F                    1235                          TRAP        #15                                           
000019D0                          1236  
000019D0  43F9 00001AC3           1237                          LEA         OPEN_PARENS,A1        ; print out '(' (later, send this to dislpay buffer)
000019D6  103C 000E               1238                          MOVE.B      #14,D0
000019DA  4E4F                    1239                          TRAP        #15
000019DC                          1240                          
000019DC  43F9 00001CDE           1241                          LEA         MSG_A,A1              ; print out 'A'
000019E2  103C 000E               1242                          MOVE.B      #14,D0
000019E6  4E4F                    1243                          TRAP        #15
000019E8                          1244                          
000019E8  4241                    1245                          CLR         D1
000019EA  1239 00001D08           1246                          MOVE.B      (CURRENT_REG),D1      ; print out the number of the data register.
000019F0  143C 0010               1247                          MOVE.B      #16,D2
000019F4  103C 000F               1248                          MOVE.B      #15,D0
000019F8  4E4F                    1249                          TRAP        #15
000019FA                          1250                          
000019FA  43F9 00001AC5           1251                          LEA         CLOSE_PARENS,A1       ; print out ')'
00001A00  103C 000E               1252                          MOVE.B      #14,D0
00001A04  4E4F                    1253                          TRAP        #15
00001A06                          1254                          
00001A06  4E75                    1255                          RTS     
00001A08                          1256  
00001A08                          1257  DISPLAY_ADDR_DISPLC     ;TODO: case for source mode is address with displacement mode.
00001A08  4E75                    1258                          RTS    
00001A0A                          1259  
00001A0A                          1260  DISPLAY_ADDR_INDEX      ;TODO: case for source mode is address with index mode.
00001A0A  4E75                    1261                          RTS 
00001A0C                          1262  
00001A0C                          1263  *-----------------------Register checks (for displaying only)---------
00001A0C                          1264  *these do not care whether the register is for source or destination.
00001A0C                          1265  *not for cases where reg is simply a number (like D5, A5, (A5), etc),
00001A0C                          1266  *only for miscellaneous addressings where mode is 111.                        
00001A0C  0C39 0002 00001D08      1267  CHECK_MISC_ADDRESSINGS  CMP.B       #CONST_COUNTR_DISPLC_REG,CURRENT_REG
00001A14  6700 0034               1268                          BEQ         DISPLAY_COUNTR_DISPLC
00001A18                          1269                          
00001A18  0C39 0003 00001D08      1270                          CMP.B       #CONST_COUNTR_INDEX_REG,CURRENT_REG
00001A20  6700 002A               1271                          BEQ         DISPLAY_COUNTR_INDEX
00001A24                          1272                          
00001A24  0C39 0000 00001D08      1273                          CMP.B       #CONST_ABS_SHORT_REG,CURRENT_REG
00001A2C  6700 0020               1274                          BEQ         DISPLAY_ABS_SHORT
00001A30                          1275                          
00001A30  0C39 0001 00001D08      1276                          CMP.B       #CONST_ABS_LONG_REG,CURRENT_REG
00001A38  6700 0034               1277                          BEQ         DISPLAY_ABS_LONG
00001A3C                          1278                          
00001A3C  0C39 0004 00001D08      1279                          CMP.B       #CONST_IMMEDIATE_REG,CURRENT_REG
00001A44  6700 0048               1280                          BEQ         DISPLAY_IMMEDIATE
00001A48                          1281                          
00001A48                          1282                          ; TODO: error case?
00001A48                          1283                          
00001A48  4E75                    1284                          RTS
00001A4A                          1285                          
00001A4A  4E75                    1286  DISPLAY_COUNTR_DISPLC   RTS         ;TODO   
00001A4C                          1287  
00001A4C  4E75                    1288  DISPLAY_COUNTR_INDEX    RTS         ;TODO   
00001A4E                          1289  
00001A4E  43F9 00001ABD           1290  DISPLAY_ABS_SHORT       LEA         DOLLAR,A1             ; print out '$'. 
00001A54  103C 000E               1291                          MOVE.B      #14,D0
00001A58  4E4F                    1292                          TRAP        #15
00001A5A                          1293  
00001A5A  4241                    1294                          CLR         D1
00001A5C  3239 00001D0E           1295                          MOVE.W      (CURRENT_DATA),D1     ; print out the absolute short address we are concerned with in hex. 
00001A62  143C 0010               1296                          MOVE.B      #16,D2
00001A66  103C 000F               1297                          MOVE.B      #15,D0
00001A6A  4E4F                    1298                          TRAP        #15
00001A6C                          1299                          
00001A6C  4E75                    1300                          RTS 
00001A6E                          1301  
00001A6E  43F9 00001ABD           1302  DISPLAY_ABS_LONG        LEA         DOLLAR,A1             ; print out '$'. 
00001A74  103C 000E               1303                          MOVE.B      #14,D0
00001A78  4E4F                    1304                          TRAP        #15
00001A7A                          1305  
00001A7A  4241                    1306                          CLR         D1
00001A7C  2239 00001D0E           1307                          MOVE.L      (CURRENT_DATA),D1     ; print out the absolute long address we are concerned with in hex. 
00001A82  143C 0010               1308                          MOVE.B      #16,D2
00001A86  103C 000F               1309                          MOVE.B      #15,D0
00001A8A  4E4F                    1310                          TRAP        #15
00001A8C                          1311                          
00001A8C  4E75                    1312                          RTS 
00001A8E                          1313  
00001A8E  43F9 00001AC1           1314  DISPLAY_IMMEDIATE       LEA         HASH,A1               ; print out '#'. (NOTE: should send this to display buffer instead.)
00001A94  103C 000E               1315                          MOVE.B      #14,D0
00001A98  4E4F                    1316                          TRAP        #15
00001A9A                          1317                          
00001A9A  43F9 00001ABD           1318                          LEA         DOLLAR,A1             ; print out '$'. (this saves time since we can more easily find the hex value of the immediate data.)
00001AA0  103C 000E               1319                          MOVE.B      #14,D0
00001AA4  4E4F                    1320                          TRAP        #15
00001AA6                          1321                          
00001AA6  3239 00001D0E           1322                          MOVE.W      (CURRENT_DATA),D1     ; print out the immediate data we are concerned with in hex. 
00001AAC  143C 0010               1323                          MOVE.B      #16,D2
00001AB0  103C 000F               1324                          MOVE.B      #15,D0
00001AB4  4E4F                    1325                          TRAP        #15
00001AB6                          1326                          
00001AB6  4E75                    1327                          RTS
00001AB8                          1328                          
00001AB8                          1329  *###################### END EA ##################################
00001AB8                          1330  *############# BEGIN VARIABLES/CONSTANTS #########################
00001AB8                          1331  *** Variables and Constants are kept here ***
00001AB8                          1332  
00001AB8                          1333  *output characters
00001AB8  =0000000D               1334  CR                      EQU         $0D
00001AB8  =0000000A               1335  LF                      EQU         $0A
00001AB8= 0D 0A 00                1336  RETURN                  DC.B        CR,LF,0
00001ABB= 20 00                   1337  SPACE                   DC.B        ' ',0
00001ABD= 24 00                   1338  DOLLAR                  DC.B        '$',0
00001ABF= 2C 00                   1339  COMMA                   DC.B        ',',0
00001AC1= 23 00                   1340  HASH                    DC.B        '#',0
00001AC3= 28 00                   1341  OPEN_PARENS             DC.B        '(',0
00001AC5= 29 00                   1342  CLOSE_PARENS            DC.B        ')',0
00001AC7= 2B 00                   1343  PLUS                    DC.B        '+',0
00001AC9= 2D 00                   1344  MINUS                   DC.B        '-',0
00001ACB                          1345  
00001ACB                          1346  *output messages
00001ACB                          1347      ;TODO: consider also giving the user the range of valid start/end addresses
00001ACB= 50 6C 65 61 73 65 ...   1348  START_ADDR_MSG          DC.B        'Please enter a starting hex address to read from.',CR,LF,0
00001AFF= 50 6C 65 61 73 65 ...   1349  END_ADDR_MSG            DC.B        'Please enter an ending hex address to read from.',CR,LF,0
00001B32                          1350  
00001B32= 4E 6F 74 20 61 20 ...   1351  INVALID_LEN_MSG         DC.B        'Not a valid length for input address.',CR,LF
00001B59= 50 6C 65 61 73 65 ...   1352                          DC.B        'Please enter a valid-length address.',CR,LF,0
00001B80= 4E 6F 74 20 61 20 ...   1353  INVALID_ADDR_MSG        DC.B        'Not a valid address.',CR,LF
00001B96= 50 6C 65 61 73 65 ...   1354                          DC.B        'Please enter a valid address.',CR,LF,0
00001BB6= 4E 6F 74 20 61 20 ...   1355  INVALID_END_ADDR_MSG    DC.B        'Not a valid end address.',CR,LF
00001BD0= 50 6C 65 61 73 65 ...   1356                          DC.B        'Please enter an end address after the start address.',CR,LF,0
00001C07                          1357                        
00001C07= 4E 6F 74 20 61 20 ...   1358  INVALID_ADDR_L_MSG      DC.B        'Not a valid address (too low).',CR,LF
00001C27= 50 6C 65 61 73 65 ...   1359                          DC.B        'Please enter a valid address.',CR,LF,0
00001C47                          1360                          
00001C47= 4E 6F 74 20 61 20 ...   1361  INVALID_ADDR_H_MSG      DC.B        'Not a valid address (too high).',CR,LF
00001C68= 50 6C 65 61 73 65 ...   1362                          DC.B        'Please enter a valid address.',CR,LF,0
00001C88                          1363                          
00001C88= 44 6F 6E 65 20 72 ...   1364  DONE_READING_MSG        DC.B        'Done reading the program.',CR,LF,0
00001CA4                          1365  
00001CA4                          1366  *output instruction names (OPcodes)
00001CA4                          1367      ;sizes
00001CA4= 2E 42 00                1368  BYTE_SIZE_MSG           DC.B        '.B',0
00001CA7= 2E 57 00                1369  WORD_SIZE_MSG           DC.B        '.W',0
00001CAA= 2E 4C 00                1370  LONG_SIZE_MSG           DC.B        '.L',0
00001CAD                          1371  
00001CAD                          1372      ;constants
00001CAD= 52 45 53 45 54 00       1373  RESET_MSG               DC.B        'RESET',0
00001CB3= 4E 4F 50 00             1374  NOP_MSG                 DC.B        'NOP',0
00001CB7= 53 54 4F 50 00          1375  STOP_MSG                DC.B        'STOP',0
00001CBC                          1376      ;moves
00001CBC= 4D 4F 56 45 00          1377  MOVE_MSG                DC.B        'MOVE',0
00001CC1= 4D 4F 56 45 2E 42 00    1378  MOVE_B_MSG              DC.B        'MOVE.B',0
00001CC8= 4D 4F 56 45 2E 57 00    1379  MOVE_W_MSG              DC.B        'MOVE.W',0
00001CCF= 4D 4F 56 45 2E 4C 00    1380  MOVE_L_MSG              DC.B        'MOVE.L',0
00001CD6                          1381  
00001CD6= 4D 4F 56 45 51 00       1382  MOVEQ_MSG               DC.B        'MOVEQ',0
00001CDC                          1383  
00001CDC                          1384  *other output instruction message constants
00001CDC= 44 00                   1385  MSG_D                   DC.B        'D',0
00001CDE= 41 00                   1386  MSG_A                   DC.B        'A',0
00001CE0                          1387  
00001CE0                          1388  *storage locations for input
00001CE0                          1389  START_ADDR_IN           DS.B        20
00001CF4                          1390  
00001CF4                          1391  *other I/O-related variables/constants
00001CF4  =00000001               1392  INPUTTING_START         SET         1 ;if 1, we are inputting start address. If 0, we are inputting end address.
00001CF4                          1393  OPCODE_BUFFER           DS.L        1 ; can hold at most 4 characters
00001CF8                          1394  SIZE_BUFFER             DS.W        1 ;cand hold at most 2 characters
00001CFA                          1395  DISPLAY_BUFFER          DS.W        5
00001D04                          1396  
00001D04                          1397  *EA/OPcode parsed instruction variables/constants
00001D04                          1398  CURRENT_WORD            DS.W        1 ; current first 16 bits of an instruction.
00001D06                          1399  CURRENT_OP_SIZE         DS.B        1 ; current operation size. Byte = 01, Word = 11, Long = 10
00001D07                          1400  
00001D07                          1401  CURRENT_MD              DS.B        1 ; current mode we are concerened with (ex: 000 for data register mode.)
00001D08                          1402  CURRENT_REG             DS.B        1 ; current register number we are concerned with(address, data, etc) that we are looking at. Ex: D0,A5,etc
00001D09                          1403  
00001D09                          1404  CURRENT_SRC_MD          DS.B        1 ; current source mode
00001D0A                          1405  CURRENT_SRC_REG         DS.B        1 ; current source register
00001D0B                          1406  CURRENT_DEST_MD         DS.B        1 ; current desination mode
00001D0C                          1407  CURRENT_DEST_REG        DS.B        1 ; current desination register
00001D0D                          1408  
00001D0E                          1409  CURRENT_DATA            DS.L        1 ; current addition data we are concerned with
00001D12                          1410  CURRENT_SRC_DATA        DS.L        1 ; current additional data for source (like absolute addresses, immediate data, etc)
00001D16                          1411  CURRENT_DEST_DATA       DS.L        1 ; current additional data for destination (like absolute addresses, immediate data, etc) 
00001D1A                          1412  
00001D1A                          1413  *size constants
00001D1A  =00000000               1414  BYTE_SIZE                EQU         $00 ; 0000 0000
00001D1A  =00000001               1415  WORD_SIZE                EQU         $01 ; 0000 0001
00001D1A  =00000002               1416  LONG_SIZE                EQU         $02 ; 0000 0010
00001D1A                          1417  
00001D1A  =00000001               1418  BYTE_SIZE_M              EQU         $01 ; 0000 0001
00001D1A  =00000003               1419  WORD_SIZE_M              EQU         $03 ; 0000 0011
00001D1A  =00000002               1420  LONG_SIZE_M              EQU         $02 ; 0000 0010
00001D1A                          1421  
00001D1A                          1422  *address constants
00001D1A  =00003000               1423  MIN_ADDRESS             EQU         $00003000
00001D1A  =0FFF0000               1424  MAX_ADDRESS             EQU         $0FFF0000
00001D1A                          1425  
00001D1A                          1426  *address variables
00001D1A  =00007000               1427  TEST_ORIGIN             SET         $00007000
00001D1A  =00007000               1428  NEXT_ADDR               SET         TEST_ORIGIN
00001D1A  =00009000               1429  END_ADDR                SET         $00009000
00001D1A                          1430  
00001D1A                          1431  *filters for isolating parts of a hexa instruction. X means 'unknown' and can be 0 or one after ANDI filter.
00001D1A                          1432  *To filter an instruction, ANDI it with the desired filter.
00001D1A                          1433  *note: I'm not sure if it matters much whether you have the 4 leading 0s in these filters, but I don't want to
00001D1A                          1434  *risk changing it. Therefore, some filters have leading 0s and some do not.
00001D1A                          1435      * general filters
00001D1A  =0000C000               1436  FILT_2BIT_1             EQU         $0000C000   ;first 2 bits:                          XX00 0000 0000 0000
00001D1A  =0000F000               1437  FILT_NIB_1              EQU         $0000F000   ;first nibble:                          XXXX 0000 0000 0000
00001D1A  =00000F00               1438  FILT_NIB_2              EQU         $00000F00   ;second nibble:                         0000 XXXX 0000 0000
00001D1A  =00000800               1439  FILT_BIT_5              EQU         $00000800   ;5th bit:                               0000 X000 0000 0000
00001D1A  =00000100               1440  FILT_BIT_8              EQU         $00000100   ;8th bit:                               0000 000X 0000 0000
00001D1A                          1441  
00001D1A                          1442      * source/destination filters (not applicable for bidirectional operations)
00001D1A  =00000E00               1443  FILT_DEST_REG           EQU         $00000E00   ;destination register:                  0000 XXX0 0000 0000
00001D1A  =000001C0               1444  FILT_DEST_MD            EQU         $000001C0   ;destination mode:                      0000 000X XX00 0000
00001D1A  =00000038               1445  FILT_SRC_MD             EQU         $00000038   ;source mode:                           0000 0000 00XX X000
00001D1A  =00000007               1446  FILT_SRC_REG            EQU         $00000007   ;source register:                       0000 0000 0000 0XXX
00001D1A                          1447  
00001D1A                          1448      * move filters
00001D1A  =00003000               1449  FILT_MOVE_SIZE          EQU         $00003000   ;Size of a move operation:              00XX 0000 0000 0000
00001D1A  =0000FB80               1450  FILT_MOVEM              EQU         $FB80       ; check for a MOVEM instruction:        XXXX X0XX X000 0000
00001D1A                          1451  
00001D1A                          1452      * filters for BRA, BSR, BCC, and MOVEQ (the same filter, but named differently for clarity.)
00001D1A  =000000FF               1453  FILT_DISPLACEMENT       EQU         $00FF       ;Displacment of branch instruction:     0000 0000 XXXX XXXX
00001D1A  =000000FF               1454  FILT_MOVEQ_DATA         EQU         $00FF       ;Data of MOVEQ instruction:             0000 0000 XXXX XXXX
00001D1A                          1455  
00001D1A                          1456      * EXT filter
00001D1A  =0000FFB8               1457  FILT_EXT                EQU         $FFB8       ; check for an EXT instruction:         XXXX XXXX X0XX X000
00001D1A                          1458  
00001D1A                          1459      
00001D1A                          1460  
00001D1A                          1461  * constants for comparing with filtered instructions. X means 'don't care' (and will be set to 0 by previous filter)
00001D1A                          1462  *(These do not represent the complete insturctions.)
00001D1A                          1463  *(Also note that repetition is allowed for clarity's sake, so two constants can share a value.)
00001D1A                          1464      * general filters
00001D1A  =00000000               1465  CONST_ALL_0             EQU         $0000    ; all 0s:                               0000 0000 0000 0000
00001D1A  =00004000               1466  CONST_NIB1_0100         EQU         $4000    ; first nibble is 0100                  0100 XXXX XXXX XXXX
00001D1A  =00000800               1467  CONST_NIB2_1000         EQU         $0800    ; second nibble is 1000                 XXXX 1000 XXXX XXXX
00001D1A  =00000A00               1468  CONST_NIB2_1010         EQU         $0A00    ; second nibble is 1010                 XXXX 1010 XXXX XXXX
00001D1A  =00000E00               1469  CONST_NIB2_1110         EQU         $0E00    ; second nibble is 1110                 XXXX 1110 XXXX XXXX
00001D1A                          1470  
00001D1A                          1471  * Immediate operation constants
00001D1A                          1472      * ANDI
00001D1A  =00000000               1473  CONST_ORI_DEST_REG      EQU         $0000    ; confirm ORI                           XXXX 000X XXXX XXXX
00001D1A                          1474      * ANDI
00001D1A  =00000200               1475  CONST_ANDI_DEST_REG     EQU         $0200    ; confirm ANDI                          XXXX 001X XXXX XXXX
00001D1A                          1476      * SUBI
00001D1A  =00000400               1477  CONST_SUBI_DEST_REG     EQU         $0400    ; confirm SUBI                          XXXX 010X XXXX XXXX
00001D1A                          1478      * ADDI
00001D1A  =00000600               1479  CONST_ADDI_DEST_REG     EQU         $0600    ; confirm ADDI                          XXXX 011X XXXX XXXX
00001D1A                          1480      * EORI
00001D1A  =00000A00               1481  CONST_EORI_DEST_REG     EQU         $0A00    ; confirm EORI                          XXXX 101X XXXX XXXX
00001D1A                          1482      * CMPI
00001D1A  =00000C00               1483  CONST_CMPI_DEST_REG     EQU         $0C00    ; confirm CMPI                          XXXX 110X XXXX XXXX
00001D1A                          1484  
00001D1A                          1485  * Constants for matching based on 2nd nibble
00001D1A                          1486      *NEGX
00001D1A  =00000000               1487  CONST_NEGX_OP           EQU         $0000    ; confirm NEGX                          XXXX 0000 XXXX XXXX
00001D1A                          1488      *CLR
00001D1A  =00000200               1489  CONST_CLR_OP            EQU         $0200    ; confirm CLR                           XXXX 0010 XXXX XXXX
00001D1A                          1490      *NEG
00001D1A  =00000400               1491  CONST_NEG_OP            EQU         $0400    ; confirm NEG                           XXXX 0100 XXXX XXXX
00001D1A                          1492      *NOT
00001D1A  =00000600               1493  CONST_NOT_OP            EQU         $0600    ; confirm NOT                           XXXX 0110 XXXX XXXX
00001D1A                          1494  
00001D1A                          1495  * EXT constant
00001D1A  =00004880               1496  CONST_EXT               EQU         $4880    ; confirm EXT                           0100 1000 1X00 0XXX
00001D1A                          1497  
00001D1A                          1498  * Other constants
00001D1A                          1499      * BTST,BCHG,BCLR,BSET
00001D1A  =00000800               1500  CONST_B_OP              EQU         $0800    ; BTST,BCHG,BCLR,BSET                   XXXX 100X XXXX XXXX
00001D1A                          1501  
00001D1A                          1502      * MOVE
00001D1A  =00001000               1503  CONST_MOVE_B            EQU         $1000    ; MOVE.B (use first nib)                0001 XXXX XXXX XXXX
00001D1A  =00003000               1504  CONST_MOVE_W            EQU         $3000    ; MOVE.W (use first nib)                0011 XXXX XXXX XXXX
00001D1A  =00002000               1505  CONST_MOVE_L            EQU         $2000    ; MOVE.L (use first nib)                0010 XXXX XXXX XXXX
00001D1A                          1506  
00001D1A                          1507      * MOVEQ
00001D1A  =00007000               1508  CONST_MOVEQ             EQU         $7000    ; MOVEQ.L (use first nib)               0111 XXXX XXXX XXXX    
00001D1A                          1509           
00001D1A                          1510      * MOVEM                      
00001D1A  =00008880               1511  CONST_MOVEM             EQU         $8880    ; confirm MOVEM (use FILT_MOVEM)        0100 1X00 1XXX XXXX            
00001D1A                          1512           
00001D1A                          1513  * Mode/register constants
00001D1A                          1514  
00001D1A                          1515      * Mode values
00001D1A  =00000000               1516  CONST_DATA_REG_MD       EQU         $00      ; Data register mode:     Dn            XXXX X000
00001D1A  =00000001               1517  CONST_ADDR_REG_MD       EQU         $01      ; Address register mode:  An            XXXX X001
00001D1A  =00000002               1518  CONST_ADDR_IND_MD       EQU         $02      ; Address indirect mode:  (An)          XXXX X010
00001D1A  =00000003               1519  CONST_ADDR_INCR_MD      EQU         $03      ; Address postincr. mode: (An)+         XXXX X011
00001D1A  =00000004               1520  CONST_ADDR_DECR_MD      EQU         $04      ; Address predecr. mode:  -(An)         XXXX X100
00001D1A  =00000005               1521  CONST_ADDR_DISPLC_MD    EQU         $05      ; Address w/ displacement:(d16,An)      XXXX X101
00001D1A  =00000006               1522  CONST_ADDR_INDEX_MD     EQU         $06      ; Address w/ index:       (d8,PC,Xn)    XXXX X110
00001D1A  =00000007               1523  CONST_ADDR_MISC_MD      EQU         $07      ; Various other addressing modes        XXXX X111
00001D1A                          1524  
00001D1A                          1525      * Constant register values (should not be necessary for register numbers like D5)
00001D1A  =00000002               1526  CONST_COUNTR_DISPLC_REG EQU         $02      ; Counter w/ displacement:(d16,PC)      XXXX X010
00001D1A  =00000003               1527  CONST_COUNTR_INDEX_REG  EQU         $03      ; Counter w/ index:       (d16,PC,Xn)   XXXX X011
00001D1A  =00000000               1528  CONST_ABS_SHORT_REG     EQU         $00      ; Absolute word:          (xxx).W       XXXX X000
00001D1A  =00000001               1529  CONST_ABS_LONG_REG      EQU         $01      ; Absolute long:          (xxx).L       XXXX X001
00001D1A  =00000004               1530  CONST_IMMEDIATE_REG     EQU         $04      ; Immediate data:         #imm          XXXX X100
00001D1A                          1531  
00001D1A                          1532  *full OPcode contstants
00001D1A  =00004E70               1533  RESET_CODE              EQU         $4E70   ; RESET                                 0100 1110 0111 0001
00001D1A  =00004E71               1534  NOP_CODE                EQU         $4E71   ; NOP                                   0100 1110 0111 0001
00001D1A  =00004E72               1535  STOP_CODE               EQU         $4E72   ; STOP                                  0100 1110 0111 0010
00001D1A                          1536  
00001D1A                          1537    
00001D1A                          1538  *############# END VARIABLES/CONSTANTS #########################
00001D1A                          1539  
00001D1A                          1540      END START        ; last line of source, very end of the program

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDI_FOUND          16A6
ANDI_FOUND          169E
ASCII_TO_HEX        10B4
BEGIN_READ          12E2
BYTE_SIZE           0
BYTE_SIZE_M         1
BYTE_SIZE_MSG       1CA4
CHECK_ADDRESSING_MODES  18A6
CHECK_CONSTANTS     134A
CHECK_DONE_READING  1308
CHECK_EXT           150C
CHECK_MISC_ADDRESSINGS  1A0C
CHECK_MOVE          14D0
CHECK_MOVEM         1522
CHECK_MOVEQ         14F6
CHECK_NIB1_0000     13CE
CHECK_NIB1_0100     13E4
CHECK_NON_CONSTANTS  13B2
CLOSE_PARENS        1AC5
CLR_FOUND           16B6
CMPI_FOUND          16AE
COMMA               1ABF
CONFIRMED_NEXT_OP   12F6
CONFIRM_0000_XXX0   1412
CONFIRM_0100_0XXX   146C
CONFIRM_0100_1000   14C4
CONFIRM_0100_1010   14C8
CONFIRM_0100_1110   14CC
CONFIRM_0100_1XXX   149C
CONFIRM_NIB1_0000   13FA
CONFIRM_NIB1_0100   1450
CONFIRM_READ_DATA   17A6
CONFIRM_READ_DEST_DATA  1786
CONFIRM_READ_SRC_DATA  174C
CONST_ABS_LONG_REG  1
CONST_ABS_SHORT_REG  0
CONST_ADDI_DEST_REG  600
CONST_ADDR_DECR_MD  4
CONST_ADDR_DISPLC_MD  5
CONST_ADDR_INCR_MD  3
CONST_ADDR_INDEX_MD  6
CONST_ADDR_IND_MD   2
CONST_ADDR_MISC_MD  7
CONST_ADDR_REG_MD   1
CONST_ALL_0         0
CONST_ANDI_DEST_REG  200
CONST_B_OP          800
CONST_CLR_OP        200
CONST_CMPI_DEST_REG  C00
CONST_COUNTR_DISPLC_REG  2
CONST_COUNTR_INDEX_REG  3
CONST_DATA_REG_MD   0
CONST_EORI_DEST_REG  A00
CONST_EXT           4880
CONST_IMMEDIATE_REG  4
CONST_MOVEM         8880
CONST_MOVEQ         7000
CONST_MOVE_B        1000
CONST_MOVE_L        2000
CONST_MOVE_W        3000
CONST_NEGX_OP       0
CONST_NEG_OP        400
CONST_NIB1_0100     4000
CONST_NIB2_1000     800
CONST_NIB2_1010     A00
CONST_NIB2_1110     E00
CONST_NOT_OP        600
CONST_ORI_DEST_REG  0
CONST_SUBI_DEST_REG  400
CONVERSION_DONE     12B0
COUNT_INPUT_DIGITS  1046
CR                  D
CURRENT_DATA        1D0E
CURRENT_DEST_DATA   1D16
CURRENT_DEST_MD     1D0B
CURRENT_DEST_REG    1D0C
CURRENT_MD          1D07
CURRENT_OP_SIZE     1D06
CURRENT_REG         1D08
CURRENT_SRC_DATA    1D12
CURRENT_SRC_MD      1D09
CURRENT_SRC_REG     1D0A
CURRENT_WORD        1D04
DIG_CONV_DONE_1     10DE
DIG_CONV_DONE_2     1112
DIG_CONV_DONE_3     114A
DIG_CONV_DONE_4     1182
DIG_CONV_DONE_5     11BA
DIG_CONV_DONE_6     11F2
DIG_CONV_DONE_7     122A
DIG_CONV_DONE_8     1262
DISPLAY_ABS_LONG    1A6E
DISPLAY_ABS_SHORT   1A4E
DISPLAY_ADDR_DECR   19C4
DISPLAY_ADDR_DISPLC  1A08
DISPLAY_ADDR_INCR   1980
DISPLAY_ADDR_IND    1948
DISPLAY_ADDR_INDEX  1A0A
DISPLAY_ADDR_REG    1928
DISPLAY_BUFFER      1CFA
DISPLAY_COUNTR_DISPLC  1A4A
DISPLAY_COUNTR_INDEX  1A4C
DISPLAY_CURRENT_ADDRESS  1324
DISPLAY_DATA_REG    1908
DISPLAY_DEST        1870
DISPLAY_IMMEDIATE   1A8E
DISPLAY_MOVEQ_DATA  1656
DISPLAY_MOVE_DATA   15E2
DISPLAY_SOURCE      183A
DOLLAR              1ABD
DONE_READING        1310
DONE_READING_MSG    1C88
END_ADDR            9000
END_ADDR_MSG        1AFF
EORI_FOUND          16AA
EXT_FOUND           1692
FILT_2BIT_1         C000
FILT_BIT_5          800
FILT_BIT_8          100
FILT_DEST_MD        1C0
FILT_DEST_REG       E00
FILT_DISPLACEMENT   FF
FILT_EXT            FFB8
FILT_MOVEM          FB80
FILT_MOVEQ_DATA     FF
FILT_MOVE_SIZE      3000
FILT_NIB_1          F000
FILT_NIB_2          F00
FILT_SRC_MD         38
FILT_SRC_REG        7
GO_TO_NEXT_OP       12F2
HASH                1AC1
INPUTTING_START     1
INVALID_ADDR_HIGH   12A0
INVALID_ADDR_H_MSG  1C47
INVALID_ADDR_INPUT  1270
INVALID_ADDR_LOW    1290
INVALID_ADDR_L_MSG  1C07
INVALID_ADDR_MSG    1B80
INVALID_END_ADDR    1280
INVALID_END_ADDR_MSG  1BB6
INVALID_LEN_MSG     1B32
LF                  A
LONG_SIZE           2
LONG_SIZE_M         2
LONG_SIZE_MSG       1CAA
MAX_ADDRESS         FFF0000
MINUS               1AC9
MIN_ADDRESS         3000
MOVEM_FOUND         1696
MOVEQ_FOUND         1604
MOVEQ_MSG           1CD6
MOVE_B_FOUND        1538
MOVE_B_MSG          1CC1
MOVE_L_FOUND        1598
MOVE_L_MSG          1CCF
MOVE_MSG            1CBC
MOVE_W_FOUND        1568
MOVE_W_MSG          1CC8
MSG_A               1CDE
MSG_D               1CDC
NEGX_FOUND          16B2
NEG_FOUND           16BA
NEXT_ADDR           7000
NOP_CODE            4E71
NOP_FOUND           1390
NOP_MSG             1CB3
NOT_FOUND           16BE
OPCODE_BUFFER       1CF4
OPEN_PARENS         1AC3
ORI_FOUND           169A
PARSE_MOVEQ_DATA    1634
PARSE_MOVE_DATA     15C8
PLUS                1AC7
PREPARE_DISPLAY     12EE
PROMPT_INPUT        1008
READ_ABS_LONG_DATA  17F0
READ_ABS_SHORT_DATA  17E8
READ_COUNTR_DISPLC_DATA  17E4
READ_COUNTR_INDEX_DATA  17E6
READ_CURRENT_OP     1320
READ_DEST_DATA      176C
READ_DEST_MODE      16E0
READ_DEST_REG       16C2
READ_IMMEDIATE_DATA  17F8
READ_IMMEDIATE_DATA_L  182C
READ_IMMEDIATE_DATA_W  181E
READ_MOVEQ_DATA     1678
READ_SOURCE_DATA    1732
READ_SOURCE_MODE    16FC
READ_SOURCE_REG     1718
RESET_CODE          4E70
RESET_FOUND         1372
RESET_MSG           1CAD
RETURN              1AB8
SET_END_ADDR        12D8
SET_START_ADDR      12D2
SIZE_BUFFER         1CF8
SPACE               1ABB
START               1000
START_ADDR_IN       1CE0
START_ADDR_MSG      1ACB
STOP                1004
STOP_CODE           4E72
STOP_FOUND          13AE
STOP_MSG            1CB7
SUBI_FOUND          16A2
TAKE_USER_INPUT     1034
TAKE_USER_IN_E      1020
TAKE_USER_IN_S      100C
TEST_ORIGIN         7000
VALID_ADDR          12C6
WORD_SIZE           1
WORD_SIZE_M         3
WORD_SIZE_MSG       1CA7
