00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.14.00
Created On: 2/20/2014 7:05:31 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Disassembler
00000000                             3  * Written by : Robert Brandenburg, Danielle Jenkins, Shahin Nahar
00000000                             4  * Date       : 2/13/14
00000000                             5  * Description: Disassemble hex machine code instructions into 68K instructions
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8  * TODO: write disassembler
00000000                             9  * TODO: more specific TODOs for our plan
00000000                            10  * TODO: comments saying who is working where
00000000                            11  
00000000                            12  
00000000                            13  * Commenting Key: 
00000000                            14  *    "----------"  <-- subroutine commenting
00000000                            15  *    "##########"  <-- section/role commenting
00000000                            16  
00000000                            17  * Notes on saving registers on run:
00000000                            18  *    MOVEM.L A0-A3/D0-D7, -(A7) * copies all working registers to stack
00000000                            19  *    MOVEM.L (A7)+, A0-A3/D0-D7 *Restore the registers
00000000                            20  
00000000                            21  * Notes on AND filters (bit masking):
00000000                            22  * Example:
00000000                            23  *       0001 000 001 111 100   (say you want "001")
00000000                            24  *   AND 0000 000 111 000 000   (0 <-- don't want, 1 <-- do want)
00000000                            25  *       --------------------
00000000                            26  *     = 0000 000 001 000 000
00000000                            27  *
00000000                            28  * Relevant wiki page:
00000000                            29  *   https://en.wikipedia.org/wiki/Mask_(computing)#Masking_bits_to_0
00000000                            30  *
00000000                            31  
00000000                            32  *################ BEGIN MAIN ###############################
00000000                            33  *** All subroutine calls are made here ***
00001000                            34  START                   ORG        $1000       ; first instruction of program
00001000  6000 0006                 35                          BRA        PROMPT_INPUT            ; prompt the user for input
00001004                            36                   
00001004  4E72 2700                 37  STOP                    STOP       #$2700          ; halt simulator, end of main
00001008                            38  
00001008                            39  *################ END MAIN ###############################
00001008                            40  *################ BEGIN IO ###############################
00001008                            41  *** IO Subroutines are kept here ***
00001008                            42  
00001008                            43  *-------------------- Print ASCII logo ----------------------
00001008  6000 0002                 44  PROMPT_INPUT            BRA         TAKE_USER_IN_S ;TODO: change to welcome/ASCII logo
0000100C                            45  *------------------- Prompt user for input -------------------
0000100C                            46  
0000100C                            47                  
0000100C  163C 0001                 48  TAKE_USER_IN_S          MOVE.B      #1,D3
00001010  43F9 000016CF             49                          LEA         START_ADDR_MSG,A1  ; Prompt user for starting address
00001016  103C 000E                 50                          MOVE.B      #14,D0
0000101A  4E4F                      51                          TRAP        #15
0000101C                            52  
0000101C  6000 0016                 53                          BRA         TAKE_USER_INPUT
00001020                            54  
00001020  163C 0000                 55  TAKE_USER_IN_E          MOVE.B      #0,D3
00001024  43F9 00001703             56                          LEA         END_ADDR_MSG,A1  ; prompt user for ending address
0000102A  103C 000E                 57                          MOVE.B      #14,D0
0000102E  4E4F                      58                          TRAP        #15
00001030                            59                          
00001030  6000 0002                 60                          BRA         TAKE_USER_INPUT
00001034                            61                          
00001034  7200                      62  TAKE_USER_INPUT         MOVE.L      #$00000000,D1   ; need to clear out the data registers we are about to use to avoid junk data.   
00001036  7A00                      63                          MOVE.L      #$00000000,D5    
00001038  7C00                      64                          MOVE.L      #$00000000,D6
0000103A  7E00                      65                          MOVE.L      #$00000000,D7
0000103C                            66  
0000103C  103C 0002                 67                          MOVE.B      #2,D0           ; Take user input for next address.
00001040  327C 2000                 68                          MOVEA.W     #$2000,A1       ; Store the ascii input in A1,(note that we might not want to use 2000 here)
00001044  4E4F                      69                          TRAP        #15             ; and the length in D1.W.  
00001046                            70  
00001046  327C 2001                 71  COUNT_INPUT_DIGITS      MOVEA.W     #$2001,A1
0000104A  B27C 0001                 72                          CMP         #1,D1
0000104E  6700 0064                 73                          BEQ         ASCII_TO_HEX  ;start converting if we have 1 digit.
00001052                            74            
00001052  327C 2002                 75                          MOVEA.W     #$2002,A1
00001056  B27C 0002                 76                          CMP         #2,D1
0000105A  6700 0058                 77                          BEQ         ASCII_TO_HEX  ;start converting if we have 2 digits.
0000105E                            78            
0000105E  327C 2003                 79                          MOVEA.W     #$2003,A1
00001062  B27C 0003                 80                          CMP         #3,D1
00001066  6700 004C                 81                          BEQ         ASCII_TO_HEX  ;start converting if we have 3 digits.
0000106A                            82            
0000106A  327C 2004                 83                          MOVEA.W     #$2004,A1
0000106E  B27C 0004                 84                          CMP         #4,D1
00001072  6700 0040                 85                          BEQ         ASCII_TO_HEX  ;start converting if we have 4 digits.
00001076                            86            
00001076  327C 2005                 87                          MOVEA.W     #$2005,A1
0000107A  B27C 0005                 88                          CMP         #5,D1
0000107E  6700 0034                 89                          BEQ         ASCII_TO_HEX  ;start converting if we have 5 digits.
00001082                            90            
00001082  327C 2006                 91                          MOVEA.W     #$2006,A1
00001086  B27C 0006                 92                          CMP         #6,D1
0000108A  6700 0028                 93                          BEQ         ASCII_TO_HEX  ;start converting if we have 6 digits.
0000108E                            94            
0000108E  327C 2007                 95                          MOVEA.W     #$2007,A1
00001092  B27C 0007                 96                          CMP         #7,D1
00001096  6700 001C                 97                          BEQ         ASCII_TO_HEX  ;start converting if we have 7 digits.
0000109A                            98            
0000109A  327C 2008                 99                          MOVEA.W     #$2008,A1
0000109E  B27C 0008                100                          CMP         #8,D1
000010A2  6700 0010                101                          BEQ         ASCII_TO_HEX  ;start converting if we have 8 digits.
000010A6                           102            
000010A6  43F9 00001736            103                          LEA         INVALID_LEN_MSG,A1         ; If we get an invalid length, give and error message and... branch back asking user for input again
000010AC  103C 000E                104                          MOVE.B      #14,D0
000010B0  4E4F                     105                          TRAP        #15
000010B2                           106  
000010B2  6780                     107                          BEQ         TAKE_USER_INPUT               
000010B4                           108  
000010B4                           109  
000010B4                           110  
000010B4                           111  *------------------- Convert to hex subroutine -------------------
000010B4                           112  
000010B4  7C00                     113  ASCII_TO_HEX            MOVE.L      #$00000000,D6      ; running total of converted hex number
000010B6                           114                  
000010B6                           115                          ;first digit
000010B6  1A21                     116                          MOVE.B      -(A1),D5  ; Move the raw ascii value of first digit into 3007.
000010B8  BA7C 0030                117                          CMP         #$30,D5
000010BC  6D00 01B2                118                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
000010C0  BA7C 0040                119                          CMP         #$40,D5
000010C4  6700 01AA                120                          BEQ         INVALID_ADDR_INPUT
000010C8  BA7C 0046                121                          CMP         #$46,D5
000010CC  6E00 01A2                122                          BGT         INVALID_ADDR_INPUT   
000010D0                           123                          ; Convert ascii to hex for that digit.
000010D0  0445 0030                124                          SUB         #$30,D5   ;
000010D4  BA7C 000A                125                          CMP         #$A,D5
000010D8  6D00 0004                126                          BLT         DIG_CONV_DONE_1 ; Necessary to convert some ASCII values.
000010DC  5F05                     127                          SUB.B       #7, D5                      ; TODO: errors for invalid ASCII values.
000010DE                           128                  
000010DE  DC45                     129  DIG_CONV_DONE_1         ADD.W       D5,D6
000010E0  B27C 0001                130                          CMP         #1,D1
000010E4  6700 01CA                131                          BEQ         CONVERSION_DONE
000010E8                           132                  
000010E8                           133                          ;second digit
000010E8  7A00                     134                          MOVE.L      #$00000000,D5
000010EA  1A21                     135                          MOVE.B      -(A1),D5
000010EC  BA7C 0030                136                          CMP         #$30,D5
000010F0  6D00 017E                137                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
000010F4  BA7C 0040                138                          CMP         #$40,D5
000010F8  6700 0176                139                          BEQ         INVALID_ADDR_INPUT
000010FC  BA7C 0046                140                          CMP         #$46,D5
00001100  6E00 016E                141                          BGT         INVALID_ADDR_INPUT   
00001104  0445 0030                142                          SUB         #$30,D5
00001108  BA7C 000A                143                          CMP         #$A,D5            
0000110C  6D00 0004                144                          BLT         DIG_CONV_DONE_2    ;digit conversion done 1
00001110  5F05                     145                          SUB.B       #7, D5             ; if we have A or greater, then we need to subtract 1.
00001112                           146               
00001112  CAFC 0010                147  DIG_CONV_DONE_2         MULU.W      #$00000010,D5  ; this part adds $10 * (2nd digit) to our running total.
00001116  DC45                     148                          ADD.W       D5,D6 
00001118                           149                    
00001118  B27C 0002                150                          CMP         #2,D1
0000111C  6700 0192                151                          BEQ         CONVERSION_DONE
00001120                           152                  
00001120                           153                          ;third digit
00001120  7A00                     154                          MOVE.L      #$00000000,D5
00001122  1A21                     155                          MOVE.B      -(A1),D5
00001124  BA7C 0030                156                          CMP         #$30,D5
00001128  6D00 0146                157                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
0000112C  BA7C 0040                158                          CMP         #$40,D5
00001130  6700 013E                159                          BEQ         INVALID_ADDR_INPUT
00001134  BA7C 0046                160                          CMP         #$46,D5
00001138  6E00 0136                161                          BGT         INVALID_ADDR_INPUT   
0000113C  0445 0030                162                          SUB         #$30,D5
00001140  BA7C 000A                163                          CMP         #$A,D5
00001144  6D00 0004                164                          BLT         DIG_CONV_DONE_3 
00001148  5F05                     165                          SUB.B       #7, D5
0000114A                           166                  
0000114A  CAFC 0100                167  DIG_CONV_DONE_3         MULU.W      #$00000100,D5
0000114E  DC45                     168                          ADD.W       D5,D6 
00001150                           169      
00001150  B27C 0003                170                          CMP         #3,D1
00001154  6700 015A                171                          BEQ         CONVERSION_DONE
00001158                           172                  
00001158                           173                          ;fourth digit
00001158  7A00                     174                          MOVE.L      #$00000000,D5
0000115A  1A21                     175                          MOVE.B      -(A1),D5
0000115C  BA7C 0030                176                          CMP         #$30,D5
00001160  6D00 010E                177                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
00001164  BA7C 0040                178                          CMP         #$40,D5
00001168  6700 0106                179                          BEQ         INVALID_ADDR_INPUT
0000116C  BA7C 0046                180                          CMP         #$46,D5
00001170  6E00 00FE                181                          BGT         INVALID_ADDR_INPUT   
00001174  0445 0030                182                          SUB         #$30,D5
00001178  BA7C 000A                183                          CMP         #$A,D5
0000117C  6D00 0004                184                          BLT         DIG_CONV_DONE_4
00001180  5F05                     185                          SUB.B       #7,D5
00001182                           186                  
00001182  CAFC 1000                187  DIG_CONV_DONE_4         MULU.W      #$00001000,D5
00001186  DC45                     188                          ADD.W       D5,D6 
00001188                           189      
00001188  B27C 0004                190                          CMP         #4,D1
0000118C  6700 0122                191                          BEQ         CONVERSION_DONE
00001190                           192                  
00001190                           193                          ;fifth digit
00001190  7A00                     194                          MOVE.L      #$00000000,D5
00001192  1A21                     195                          MOVE.B      -(A1),D5
00001194  BA7C 0030                196                          CMP         #$30,D5
00001198  6D00 00D6                197                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
0000119C  BA7C 0040                198                          CMP         #$40,D5
000011A0  6700 00CE                199                          BEQ         INVALID_ADDR_INPUT
000011A4  BA7C 0046                200                          CMP         #$46,D5
000011A8  6E00 00C6                201                          BGT         INVALID_ADDR_INPUT   
000011AC  0445 0030                202                          SUB         #$30,D5
000011B0  BA7C 000A                203                          CMP         #$A,D5
000011B4  6D00 0004                204                          BLT         DIG_CONV_DONE_5
000011B8  5F05                     205                          SUB.B       #$7, D5
000011BA                           206                  
000011BA  CAFC 0001                207  DIG_CONV_DONE_5         MULU.W      #$0001,D5
000011BE  DE45                     208                          ADD.W       D5,D7 
000011C0                           209  
000011C0  B27C 0005                210                          CMP         #5,D1
000011C4  6700 00EA                211                          BEQ         CONVERSION_DONE
000011C8                           212                  
000011C8                           213                          ;sixth digit
000011C8  7A00                     214                          MOVE.L      #$00000000,D5
000011CA  1A21                     215                          MOVE.B      -(A1),D5
000011CC  BA7C 0030                216                          CMP         #$30,D5
000011D0  6D00 009E                217                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
000011D4  BA7C 0040                218                          CMP         #$40,D5
000011D8  6700 0096                219                          BEQ         INVALID_ADDR_INPUT
000011DC  BA7C 0046                220                          CMP         #$46,D5
000011E0  6E00 008E                221                          BGT         INVALID_ADDR_INPUT   
000011E4  0445 0030                222                          SUB         #$30,D5
000011E8  BA7C 000A                223                          CMP         #$A,D5
000011EC  6D00 0004                224                          BLT         DIG_CONV_DONE_6
000011F0  5F05                     225                          SUB.B       #$7, D5
000011F2                           226                  
000011F2  CAFC 0010                227  DIG_CONV_DONE_6         MULU.W      #$0010,D5
000011F6  DE45                     228                          ADD.W       D5,D7
000011F8                           229      
000011F8  B27C 0006                230                          CMP         #6,D1
000011FC  6700 00B2                231                          BEQ         CONVERSION_DONE
00001200                           232                  
00001200                           233                          ;seventh digit
00001200  7A00                     234                          MOVE.L      #$00000000,D5
00001202  1A21                     235                          MOVE.B      -(A1),D5
00001204  BA7C 0030                236                          CMP         #$30,D5
00001208  6D00 0066                237                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
0000120C  BA7C 0040                238                          CMP         #$40,D5
00001210  6700 005E                239                          BEQ         INVALID_ADDR_INPUT
00001214  BA7C 0046                240                          CMP         #$46,D5
00001218  6E00 0056                241                          BGT         INVALID_ADDR_INPUT   
0000121C  0445 0030                242                          SUB         #$30,D5
00001220  BA7C 000A                243                          CMP         #$A,D5
00001224  6D00 0004                244                          BLT         DIG_CONV_DONE_7
00001228  5F05                     245                          SUB.B       #7, D5
0000122A                           246                  
0000122A  CAFC 0100                247  DIG_CONV_DONE_7         MULU.W      #$0100,D5
0000122E  DE45                     248                          ADD.W       D5,D7
00001230                           249      
00001230  B27C 0007                250                          CMP         #7,D1
00001234  6700 007A                251                          BEQ         CONVERSION_DONE
00001238                           252                  
00001238                           253                          ;eighth digit
00001238  7A00                     254                          MOVE.L      #$00000000,D5
0000123A  1A21                     255                          MOVE.B      -(A1),D5
0000123C  BA7C 0030                256                          CMP         #$30,D5
00001240  6D00 002E                257                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
00001244  BA7C 0040                258                          CMP         #$40,D5
00001248  6700 0026                259                          BEQ         INVALID_ADDR_INPUT
0000124C  BA7C 0046                260                          CMP         #$46,D5
00001250  6E00 001E                261                          BGT         INVALID_ADDR_INPUT   
00001254  0445 0030                262                          SUB         #$30,D5
00001258  BA7C 000A                263                          CMP         #$A,D5
0000125C  6D00 0004                264                          BLT         DIG_CONV_DONE_8
00001260  5F05                     265                          SUB.B       #7, D5
00001262                           266                  
00001262  CAFC 1000                267  DIG_CONV_DONE_8         MULU.W      #$1000,D5
00001266  DE45                     268                          ADD.W       D5,D7
00001268                           269      
00001268  B27C 0008                270                          CMP         #8,D1
0000126C  6700 0042                271                          BEQ         CONVERSION_DONE    ;the input was valid and we are done with the conversion
00001270                           272                  
00001270  43F9 00001784            273  INVALID_ADDR_INPUT      LEA         INVALID_ADDR_MSG,A1    ;tell the user the address was invalid and prompt input again.
00001276  103C 000E                274                          MOVE.B      #14,D0
0000127A  4E4F                     275                          TRAP        #15
0000127C                           276                          
0000127C  6000 FDB6                277                          BRA         TAKE_USER_INPUT
00001280                           278                          
00001280  43F9 000017BA            279  INVALID_END_ADDR        LEA         INVALID_END_ADDR_MSG,A1
00001286  103C 000E                280                          MOVE.B      #14,D0
0000128A  4E4F                     281                          TRAP        #15
0000128C                           282                          
0000128C  6000 FDA6                283                          BRA         TAKE_USER_INPUT
00001290                           284                          
00001290  43F9 0000180B            285  INVALID_ADDR_LOW        LEA         INVALID_ADDR_L_MSG,A1    ;tell the user the address was invalid and prompt input again.
00001296  103C 000E                286                          MOVE.B      #14,D0
0000129A  4E4F                     287                          TRAP        #15
0000129C                           288                          
0000129C  6000 FD96                289                          BRA         TAKE_USER_INPUT
000012A0                           290  
000012A0  43F9 0000184B            291  INVALID_ADDR_HIGH       LEA         INVALID_ADDR_H_MSG,A1    ;tell the user the address was invalid and prompt input again.
000012A6  103C 000E                292                          MOVE.B      #14,D0
000012AA  4E4F                     293                          TRAP        #15
000012AC                           294                          
000012AC  6000 FD86                295                          BRA         TAKE_USER_INPUT
000012B0                           296                 
000012B0  E18F                     297  CONVERSION_DONE         LSL.L       #8,D7   ; Prepare for concatenation
000012B2  E18F                     298                          LSL.L       #8,D7   ; Got to perform the same operation twice to get it all the way to the left
000012B4  DE46                     299                          ADD.W       D6,D7  ; concatenate the two data registers into one value
000012B6                           300                          
000012B6  BEBC 00003000            301                          CMP.L       #MIN_ADDRESS,D7
000012BC  6DD2                     302                          BLT         INVALID_ADDR_LOW ;Not a valid address-- too low.
000012BE                           303                          
000012BE  BEBC 0FFF0000            304                          CMP.L       #MAX_ADDRESS,D7
000012C4  6EDA                     305                          BGT         INVALID_ADDR_HIGH  ;Not a valid address-- too high.
000012C6                           306                          
000012C6  0C43 0001                307  VALID_ADDR              CMPI        #1,D3
000012CA                           308                          
000012CA  6700 0006                309                          BEQ         SET_START_ADDR
000012CE  6000 0008                310                          BRA         SET_END_ADDR              
000012D2                           311                                                 
000012D2  2A47                     312  SET_START_ADDR          MOVEA.L     D7,A5  ;when a valid start address is inputted, store and ask the user for an end address.
000012D4  6000 FD4A                313                          BRA         TAKE_USER_IN_E
000012D8                           314  
000012D8  BE8D                     315  SET_END_ADDR            CMP.L       A5,D7    ;if end address is lower than start address, we get an error.
000012DA  6DA4                     316                          BLT         INVALID_END_ADDR           
000012DC                           317                          
000012DC  2C47                     318                          MOVEA.L     D7,A6  ;when a valid start address is inputted, store and ask the user for an end address.
000012DE  6000 0002                319                          BRA         BEGIN_READ
000012E2                           320                          
000012E2  284D                     321  BEGIN_READ              MOVEA.L      A5,A4 ; keep track of address to print with A4. TODO: could also add this value to the display buffer.
000012E4  33DD 000018EE            322                          MOVE.W      (A5)+,CURRENT_WORD ;look at the first instruction word at the starting address.
000012EA  6000 0002                323                          BRA         PREPARE_DISPLAY
000012EE                           324  
000012EE                           325  *------------------- Add to display buffer -------------------
000012EE                           326  ;At this point A5 is a valid start address and A6 is a valid end address.
000012EE                           327  ;TODO: prepare the display buffer
000012EE  6000 0030                328  PREPARE_DISPLAY         BRA         READ_CURRENT_OP    ;TEMP (though we might still call this after the display buffer is prepared)                       
000012F2                           329                 
000012F2                           330  *------------------- Move address pointer for data reading -------------------
000012F2                           331  ; This method is specifically for reading the next OPword.
000012F2  6000 0014                332  GO_TO_NEXT_OP           BRA         CHECK_DONE_READING
000012F6                           333                           
000012F6  4279 000018EE            334  CONFIRMED_NEXT_OP       CLR         CURRENT_WORD
000012FC  284D                     335                          MOVEA.L      A5,A4 ; keep track of address to print with A4. 
000012FE  33DD 000018EE            336                          MOVE.W      (A5)+,CURRENT_WORD
00001304  6000 001A                337                          BRA         READ_CURRENT_OP
00001308                           338  *------------------- Print display buffer -------------------
00001308                           339  
00001308                           340  ;TODO
00001308                           341  
00001308                           342  *------------------- Check if end of data -------------------
00001308  BACE                     343  CHECK_DONE_READING      CMPA        A6,A5       ; TODO: this comparison is not sufficient, because it will say that $8000 is less than $7000 (since $8000 is negative.)
0000130A  6DEA                     344                          BLT         CONFIRMED_NEXT_OP
0000130C  6000 0002                345                          BRA         DONE_READING
00001310                           346  *------------------- Ask user for input -------------------
00001310  43F9 0000188C            347  DONE_READING            LEA         DONE_READING_MSG,A1 ; when we reach the end address, say so and halt the program. TODO: ask user whether we want to read the data again.
00001316  103C 000E                348                          MOVE.B      #14,D0
0000131A  4E4F                     349                          TRAP        #15
0000131C  4EF8 1004                350                          JMP         STOP
00001320                           351  *################## END IO  #####################################
00001320                           352  *################## BEGIN OPCODE ##########################
00001320                           353  *** OPcode Subroutines are kept here ***
00001320                           354  
00001320                           355  ;TODO: process for reading hex instructions:
00001320                           356                  ;           1) Go to start of instruction reading loop, passing in the address of next instruction.
00001320                           357                  ;           2) Store a word (16 bits) from that address.
00001320                           358                  ;           3) Read the first 4 bits of the word using a filter.
00001320                           359                  ;           4) branch to one of the following paths based on these bits:
00001320                           360                  ;               a) 0000: Read the next 3 bits (i.e., the destination mode). Branch:
00001320                           361                  ;                   i.   000: Read the bits at 0000 0000 XXXX XXXX (may want to make this filter) Branch:
00001320                           362                  ;                       1) 00 111 100: ORI TO CCR (need to read data, I think)
00001320                           363                  ;                       2) 01 111 100: ORI TO SR (need to read data, I think)
00001320                           364                  ;                       3) (default) ORI. Now, read and store:
00001320                           365                  ;                           SIZE:       0000 0000 XX00 0000 (need to make this filter)
00001320                           366                  ;                           MODE:       0000 0000 00XX X000 (need to make this filter)
00001320                           367                  ;                           REGISTER:   0000 0000 0000 0XXX (need to make this filter)
00001320                           368                  ;                           only mandatory additional data is the immediate data.
00001320                           369                  ;                   ii.  001: Read the bits at 0000 0000 XXXX XXXX (may want to make this filter) Branch:
00001320                           370                  ;                       1) 00 111 100: ANDI TO CCR (need to read data, I think)
00001320                           371                  ;                       2) 01 111 100: ANDI TO SR (need to read data, I think)
00001320                           372                  ;                       3) (default) ANDI. Now, read and store:
00001320                           373                  ;                           SIZE:       0000 0000 XX00 0000 (need to make this filter)
00001320                           374                  ;                           MODE:       0000 0000 00XX X000 (need to make this filter)
00001320                           375                  ;                           REGISTER:   0000 0000 0000 0XXX (need to make this filter)
00001320                           376                  ;                           only mandatory additional data is the immediate data.
00001320                           377                  ;                   iii. 101: Read the bits at 0000 0000 XXXX XXXX (may want to make this filter) Branch:
00001320                           378                  ;                       1) 00 111 100: EORI TO CCR (need to read data, I think)
00001320                           379                  ;                       2) 01 111 100: EORI TO SR (need to read data, I think)
00001320                           380                  ;                       3) (default) EORI. Now, read and store:
00001320                           381                  ;                           SIZE:       0000 0000 XX00 0000 (need to make this filter)
00001320                           382                  ;                           MODE:       0000 0000 00XX X000 (FILT_SRC_MODE)
00001320                           383                  ;                           REGISTER:   0000 0000 0000 0XXX (FILT_SRC_REG)
00001320                           384                  ;                           only mandatory additional data is the immediate data.
00001320                           385                  ;                   iv.  011: ADDI. Now read and store:
00001320                           386                  ;                           SIZE:       0000 0000 XX00 0000 (need to make this filter)
00001320                           387                  ;                           MODE:       0000 0000 00XX X000 (FILT_SRC_MODE)
00001320                           388                  ;                           REGISTER:   0000 0000 0000 0XXX (FILT_SRC_REG)
00001320                           389                  ;                           only mandatory additional data is the immediate data.
00001320                           390                  ;                   v.   010: SUBI. Now read and store:
00001320                           391                  ;                           SIZE:       0000 0000 XX00 0000 (need to make this filter)
00001320                           392                  ;                           MODE:       0000 0000 00XX X000 (FILT_SRC_MODE)
00001320                           393                  ;                           REGISTER:   0000 0000 0000 0XXX (FILT_SRC_REG)
00001320                           394                  ;                           only mandatory additional data is the immediate data.
00001320                           395                  ;                   vi.  110: CMPI. Now read and store:
00001320                           396                  ;                           SIZE:       0000 0000 XX00 0000 (need to make this filter)
00001320                           397                  ;                           MODE:       0000 0000 00XX X000 (FILT_SRC_MODE)
00001320                           398                  ;                           REGISTER:   0000 0000 0000 0XXX (FILT_SRC_REG)
00001320                           399                  ;                           only mandatory additional data is the immediate data.
00001320                           400                  ;                   vii. 100: BTST, BCHG, BCLR, BSET (TODO: expand this section if we need these OPcodes)
00001320                           401                  ;                   viii.(default): BTST, BCHG, BCLR, BSET (with data register)(TODO: expand this section if we need these OPcodes)
00001320                           402                  ;               b) 0001: (MOVE.B). Now read and store:
00001320                           403                  ;                           DESTINATION REGISTER: 0000 XXX0 0000 0000 (FILT_DEST_REG)
00001320                           404                  ;                           DESTINATION MODE:     0000 000X XX00 0000 (FILT_DEST_MODE)
00001320                           405                  ;                           SOURCE MODE:          0000 0000 00XX X000 (FILT_SCR_MODE)
00001320                           406                  ;                           SOURCE REGISTER:      0000 0000 0000 0XXX (FILT_SRC_REG)
00001320                           407                  ;                           The modes (and maybe register) will tell us whether we need to read additional data for this MOVE.
00001320                           408                  ;               c) 0011: (MOVE.W). Now read and store:
00001320                           409                  ;                           DESTINATION REGISTER: 0000 XXX0 0000 0000 (FILT_DEST_REG)
00001320                           410                  ;                           DESTINATION MODE:     0000 000X XX00 0000 (FILT_DEST_MODE)
00001320                           411                  ;                           SOURCE MODE:          0000 0000 00XX X000 (FILT_SCR_MODE)
00001320                           412                  ;                           SOURCE REGISTER:      0000 0000 0000 0XXX (FILT_SRC_REG)
00001320                           413                  ;                           The modes (and maybe register) will tell us whether we need to read additional data for this MOVE.
00001320                           414                  ;               d) 0010: (MOVE.L). Now read and store:
00001320                           415                  ;                           DESTINATION REGISTER: 0000 XXX0 0000 0000 (FILT_DEST_REG)
00001320                           416                  ;                           DESTINATION MODE:     0000 000X XX00 0000 (FILT_DEST_MODE)
00001320                           417                  ;                           SOURCE MODE:          0000 0000 00XX X000 (FILT_SCR_MODE)
00001320                           418                  ;                           SOURCE REGISTER:      0000 0000 0000 0XXX (FILT_SRC_REG)
00001320                           419                  ;                           The modes (and maybe register) will tell us whether we need to read additional data for this MOVE.
00001320                           420                  ;               e) 0100: Read the bits at 0000 XXXX 0000 0000 (need filter) Branch:
00001320                           421                  ;                   i.      0000: Read the bits at 0000 0000 XX00 0000 (need filter) Branch:
00001320                           422                  ;                               1. 11: MOVE from SR. (TODO)
00001320                           423                  ;                               2. (DEFAULT) NEGX. (the two bits are size) (TODO)
00001320                           424                  ;                   ii.     0100: Read the bits at 0000 0000 XX00 0000 (need filter) Branch:
00001320                           425                  ;                               1. 11 MOVE to CCR. (TODO)
00001320                           426                  ;                               2. (DEFAULT) NEG. (the two bits are size) (TODO)
00001320                           427                  ;                   iii.    0110: Read the bits at 0000 0000 XX00 0000 (need filter) Branch:
00001320                           428                  ;                               1. 11 MOVE to SR. (TODO)
00001320                           429                  ;                               2. (DEFAULT) NOT. (the two bits are size) (TODO)
00001320                           430                  ;                   iv.     0010: CLR. (TODO)
00001320                           431                  ;                    v.     1000: (EXT, NBCD, SWAP, PEA, MOVEM (dir 0)) (TODO)
00001320                           432                  ;                   vi.     1010: Check the bits at 0000 XX00 0000 0000 (need filter) Branch:
00001320                           433                  ;                           1. 11: check the bits at 0000 00XX XXXX XXXX (need filter) Branch:
00001320                           434                  ;                               a. 11 1100: ILLEGAL (TODO)
00001320                           435                  ;                               b. (default) TAS (TODO)
00001320                           436                  ;                           2. (default) TST (TODO)
00001320                           437                  ;                  vii.     1110: (TRAP, LINK, UNLK, MOVE USP, RESET, NOP, STOP, RTE, RTS, TRAPV, RTR, JSR, JMP) (TODO)
00001320                           438                  ;                 viii.     (DEFAULT): (MOVEM, LEA, CHK,) (TODO)    
00001320                           439                  ;               f) 0101: (ADDQ, SUBQ, Scc, DBcc): Read the bits at 0000 0000 XX00 0000 (need filter) Branch:
00001320                           440                  ;                    i. 11: Read the bit at 0000 000X 0000 0000 (need filter) Branch:
00001320                           441                  ;                           1. 0: ADDQ (TODO)
00001320                           442                  ;                           2. 1: SUBQ (TODO)
00001320                           443                  ;                   ii. (default) (bits are size) read the bits at 0000 00XX X000 (FILT_SRC_MODE). Branch:
00001320                           444                  ;                           1. 001: DBCC (TODO)
00001320                           445                  ;                           2. (default): Scc (TODO)
00001320                           446                  ;               g) 0110: Read the bit at 0000 XXXX 0000 0000 (need filter) Branch:
00001320                           447                  ;                    i. 0000: BRA (TODO)
00001320                           448                  ;                   ii. 0001: BSR (TODO)
00001320                           449                  ;                  iii. (default) Bcc (TODO)
00001320                           450                  ;               h) 0111: MOVEQ (TODO)
00001320                           451                  ;               i) 1000: (DIVU, DIVS, SBCD, OR) (TODO)
00001320                           452                  ;               j) 1001: (SUB, SUBX, SUBA) (TODO)
00001320                           453                  ;               k) 1011: (EOR, CMPM, CMP, CMPA) (TODO)
00001320                           454                  ;               l) 1100: (MULU, MULS, ABCD, EXG, AND) (TODO)
00001320                           455                  ;               m) 1101: (ADD, ADDX, ADDA) (TODO)
00001320                           456                  ;               n) 1110: (ASd, LSd, ROXd, ROd, ASd, LSd, ROXd, ROd) (TODO)
00001320                           457                  ;               o) (default) The code is invalid. Not yet sure what we do in this case.
00001320                           458                  ;   
00001320                           459                  ;   
00001320                           460                  ;
00001320                           461                  
00001320                           462                  ;TODO: Use AND operations with filters to create values which can be
00001320                           463                  ;      checked against constants to narrow down OPcodes.
00001320                           464                  
00001320                           465                  ;TODO: Since it will take a while to decode every possible OPcode, we
00001320                           466                  ;      should first have a default "Error" subroutine which the program
00001320                           467                  ;      branches to once all other possibilities have been ruled out.
00001320                           468  
00001320                           469  *------------------- Read current OPcode -------------------
00001320                           470  ; By this point, CURRENT_WORD should store a potential beginning of an instruction, so we should not increment A5.
00001320  6000 0002                471  READ_CURRENT_OP         BRA         CHECK_CONSTANTS
00001324                           472                          ;CLR         D3  
00001324                           473                          ;CLR         D4
00001324                           474                          ;MOVE.W          
00001324                           475                          ;ANDI.W      #FILT_2BIT_1,D3 ; and A5 (current address we are reading) should have just been incremented to a point immediately after that word.
00001324                           476   
00001324                           477  *------------------ Check current word for constants---------
00001324                           478  ; By this point, the current word should store a potential beginning of an instruction                   
00001324  6000 0012                479  CHECK_CONSTANTS         BRA         CHECK_NOP
00001328                           480  
00001328  0C79 4E70 000018EE       481  CHECK_RESET             CMP         #RESET_CODE,(CURRENT_WORD) ; TODO: test that this is correct syntax
00001330  6600 0006                482                          BNE         CHECK_NOP
00001334                           483                         
00001334  4EF8 1004                484  RESET_FOUND             JMP         STOP  ;TODO: case for reset found    
00001338                           485   
00001338  0C79 4E71 000018EE       486  CHECK_NOP               CMP         #NOP_CODE,(CURRENT_WORD) ; TODO: test that this is correct syntax
00001340  6600 0042                487                          BNE         CHECK_STOP
00001344                           488  
00001344                           489  ;NOTE: this SR is temporary. Once we have the display buffer, it will work differently.                 
00001344  43F9 000016C9            490  NOP_FOUND               LEA         DOLLAR,A1     ; '$'
0000134A  103C 000E                491                          MOVE.B      #14,D0
0000134E  4E4F                     492                          TRAP        #15
00001350                           493                  
00001350  220C                     494                          MOVE.L      A4,D1         ; display the address NOP was found at
00001352  143C 0010                495                          MOVE.B      #16,D2
00001356  103C 000F                496                          MOVE.B      #15,D0
0000135A  4E4F                     497                          TRAP        #15
0000135C                           498  
0000135C  43F9 000016C7            499                          LEA         SPACE,A1      ; ' '
00001362  103C 000E                500                          MOVE.B      #14,D0      
00001366  4E4F                     501                          TRAP        #15
00001368                           502  
00001368  43F9 000018AE            503                          LEA         NOP_MSG,A1    ; 'NOP'
0000136E  103C 000E                504                          MOVE.B      #14,D0
00001372  4E4F                     505                          TRAP        #15
00001374                           506                          
00001374  43F9 000016C4            507                          LEA         RETURN,A1    ; (return)
0000137A  103C 000E                508                          MOVE.B      #14,D0
0000137E  4E4F                     509                          TRAP        #15
00001380                           510                 
00001380  6000 FF70                511                          BRA         GO_TO_NEXT_OP   ; when we are done parsing and displaying the MOVE instruction, go to the next OPcode.
00001384                           512                          
00001384  0C79 4E72 000018EE       513  CHECK_STOP              CMP         #STOP_CODE,(CURRENT_WORD)
0000138C  6600 0006                514                          BNE         CHECK_NON_CONSTANTS
00001390                           515  
00001390  4EF8 1004                516  STOP_FOUND              JMP         STOP  ;TODO: case for stop found               
00001394                           517  
00001394                           518  ;TODO: add cases for rest of valid constant OPcodes here
00001394                           519  
00001394                           520  *----------------- Check current word for non-constants---------
00001394                           521  ;NOTE: we currently know that CURRENT_WORD is not a constant by the time we reach this SR.
00001394                           522  
00001394  4243                     523  CHECK_NON_CONSTANTS     CLR         D3
00001396  6000 0002                524                          BRA         CHECK_MOVE_B
0000139A                           525                          
0000139A  3639 000018EE            526  CHECK_MOVE_B            MOVE.W      CURRENT_WORD,D3
000013A0  0243 F000                527                          ANDI.W      #FILT_NIB_1,D3
000013A4  B67C 1000                528                          CMP         #CONST_MOVE_B,D3
000013A8  6600 0082                529                          BNE         CHECK_MOVE_W
000013AC                           530                          
000013AC                           531  ;NOTE: this SR is temporary. will be different with display buffer.
000013AC  13FC 0000 000018F0       532  MOVE_B_FOUND            MOVE.B      #BYTE_SIZE,CURRENT_OP_SIZE
000013B4                           533  
000013B4  43F9 000016C9            534                          LEA         DOLLAR,A1     ; '$'
000013BA  103C 000E                535                          MOVE.B      #14,D0
000013BE  4E4F                     536                          TRAP        #15
000013C0                           537                  
000013C0  220C                     538                          MOVE.L      A4,D1           ; display the address MOVE.B was found at
000013C2  143C 0010                539                          MOVE.B      #16,D2
000013C6  103C 000F                540                          MOVE.B      #15,D0
000013CA  4E4F                     541                          TRAP        #15
000013CC                           542  
000013CC  43F9 000016C7            543                          LEA         SPACE,A1         ; ' '
000013D2  103C 000E                544                          MOVE.B      #14,D0      
000013D6  4E4F                     545                          TRAP        #15
000013D8                           546  
000013D8                           547                          ;FROM TEST:
000013D8                           548                          ;MOVE.B #10,D0
000013D8                           549                          ;MOVE.B D1, D1
000013D8                           550                          ;MOVE.B D1, $10000000
000013D8                           551                          ;MOVE.B D1, $1000
000013D8                           552                          
000013D8                           553                          ; TODO: error checking first
000013D8                           554                          ;
000013D8                           555                          ; possible errors:
000013D8                           556                          ;       CURRENT_DEST_MD = CONST_IMMEDIATE_REG (immediate data cannot be a destination)
000013D8                           557                          ;       CURRENT_SRC_MD  = CONST_ADDR_REG_MD   (byte is not a valid size for this move)
000013D8                           558                          ;       CURRENT_DEST_MD = CONST_ADDR_REG_MD   (byte is not a valid size, although we should be using MOVEA at this point, not MOVE.)
000013D8                           559                          ;       TODO: figure out other possible errors.
000013D8                           560                          
000013D8                           561                          ; after we confirm that there are no errors, we begin sending information about the MOVE instruction to our temp variables.
000013D8                           562                          
000013D8                           563                          
000013D8                           564                          ; at this point, need to read more information (parsed by EA, probably)
000013D8                           565                          ; now that we have a move instruction, we set our EA variables accordingly:
000013D8  6100 0082                566                          BSR         READ_DEST_REG      ; EA will set CURRENT_DEST_REG.
000013DC  6100 0096                567                          BSR         READ_DEST_MODE     ; EA will set CURRENT_DEST_MD.
000013E0  6100 00A8                568                          BSR         READ_SOURCE_MODE   ; EA will set CURRENT_SRC_MD.
000013E4  6100 00BA                569                          BSR         READ_SOURCE_REG    ; EA will set CURRENT_SRC_REG.
000013E8                           570                          
000013E8                           571                          ; need to check whether we need to read additional data before we start displaying the
000013E8                           572                          ; instruction (for instance, this is necessary for MOVE.B #10,D0).
000013E8  6100 00CA                573                          BSR         READ_SOURCE_DATA    ; EA will set CURRENT_SOURCE_DATA if necessary.
000013EC  6100 00FA                574                          BSR         READ_DEST_DATA      ; EA will set CURRENT_DEST_DATA if necessary. 
000013F0                           575                         
000013F0  43F9 000018B7            576                          LEA         MOVE_B_MSG,A1    ; 'MOVE.B'
000013F6  103C 000E                577                          MOVE.B      #14,D0
000013FA  4E4F                     578                          TRAP        #15
000013FC                           579                          
000013FC  43F9 000016C7            580                          LEA         SPACE,A1         ; ' '
00001402  103C 000E                581                          MOVE.B      #14,D0      
00001406  4E4F                     582                          TRAP        #15
00001408                           583                          
00001408                           584                          ; once we have the four (or five, or six) values, proceed to parse the instruction accordingly.
00001408  6100 01AC                585                          BSR         DISPLAY_SOURCE  ; Tell EA to parse and display the source. EX: (A1)   D3    #10   $1000 etc
0000140C                           586                          
0000140C  43F9 000016CB            587                          LEA         COMMA,A1         ; ','
00001412  103C 000E                588                          MOVE.B      #14,D0      
00001416  4E4F                     589                          TRAP        #15
00001418                           590                          
00001418  6100 01C0                591                          BSR         DISPLAY_DEST    ; Tell EA to parse and display the destination.
0000141C                           592                          
0000141C  43F9 000016C4            593                          LEA         RETURN,A1    ; (return)
00001422  103C 000E                594                          MOVE.B      #14,D0
00001426  4E4F                     595                          TRAP        #15
00001428                           596                 
00001428  6100 FEC8                597                          BSR         GO_TO_NEXT_OP
0000142C                           598                          
0000142C  3639 000018EE            599  CHECK_MOVE_W            MOVE.W      CURRENT_WORD,D3
00001432  0243 F000                600                          ANDI.W      #FILT_NIB_1,D3
00001436  B67C 3000                601                          CMP         #CONST_MOVE_W,D3
0000143A  6600 0006                602                          BNE         CHECK_MOVE_L
0000143E                           603                          
0000143E  4EF8 1004                604  MOVE_W_FOUND            JMP         STOP ;TODO: MOVE.W
00001442                           605                          
00001442  3639 000018EE            606  CHECK_MOVE_L            MOVE.W      CURRENT_WORD,D3
00001448  0243 F000                607                          ANDI.W      #FILT_NIB_1,D3
0000144C  B67C 2000                608                          CMP         #CONST_MOVE_L,D3
00001450                           609                          ;BNE        ;TODO: branch to next check
00001450  4EF8 1004                610                          JMP         STOP ;TODO: keep checking for more possible instructions
00001454                           611                          
00001454  4EF8 1004                612  MOVE_L_FOUND            JMP         STOP ;TODO: MOVE.L
00001458                           613                          
00001458                           614  
00001458  4EF8 1004                615                          JMP         STOP    ;TODO: CURRENT_WORD still holds current possible 16 bit instruction, so read it for current word.                                                                   
0000145C                           616         
0000145C                           617                  
0000145C                           618  
0000145C                           619  *###################### END OPCODE ##################################
0000145C                           620  *###################### BEGIN EA ##################################
0000145C                           621  *** EA Subroutines are kept here ***
0000145C                           622  *----------------------Check the destination register of the current word.-------------
0000145C  4244                     623  READ_DEST_REG           CLR         D4
0000145E  3839 000018EE            624                          MOVE.W      CURRENT_WORD,D4
00001464  0244 0E00                625                          ANDI.W      #FILT_DEST_REG,D4       ; turn D4 into 0000 XXX0 0000 0000
00001468  E04C                     626                          LSR.W       #8,D4                   ; turn D4 into 0000 0000 0000 0XXX
0000146A  E24C                     627                          LSR.W       #1,D4                   ; 9 would be invalid, so we shift 8, then 1
0000146C  13C4 000018F6            628                          MOVE.B      D4,CURRENT_DEST_REG
00001472  4E75                     629                          RTS
00001474                           630  
00001474                           631  *----------------------Check the destination mode of the current word.-------------
00001474                           632  *(assuming the destination is where it would be in MOVE).
00001474  4244                     633  READ_DEST_MODE          CLR         D4
00001476  3839 000018EE            634                          MOVE.W      CURRENT_WORD,D4
0000147C  0244 01C0                635                          ANDI.W      #FILT_DEST_MD,D4        ; turn D4 into 0000 000X XX00 0000
00001480  EC4C                     636                          LSR.W       #6,D4                   ; turn D4 into 0000 0000 0000 0XXX
00001482  13C4 000018F5            637                          MOVE.B      D4,CURRENT_DEST_MD
00001488  4E75                     638                          RTS
0000148A                           639  
0000148A                           640  ;By this point, CURRENT WORD holds the first 16 bits of an instruction we are looking at.
0000148A                           641  ;(we should already know the OPcode by this point, so this will be called by various OPcode subroutines.)
0000148A                           642  *---------------------- Check the source mode of the current word.--------------------
0000148A                           643  *(assuming the source is where it would be in MOVE).
0000148A  4244                     644  READ_SOURCE_MODE        CLR         D4
0000148C  3839 000018EE            645                          MOVE.W      CURRENT_WORD,D4
00001492  0244 0038                646                          ANDI.W      #FILT_SRC_MD,D4                 ; turn source mode into 0000 0000 00XX X000
00001496  E64C                     647                          LSR.W       #3,D4                           ; turn source mode into 0000 0000 0000 0XXX
00001498  13C4 000018F3            648                          MOVE.B      D4,CURRENT_SRC_MD
0000149E  4E75                     649                          RTS
000014A0                           650                          
000014A0                           651  *----------------------Check the source register of the current word.-----------------
000014A0  4244                     652  READ_SOURCE_REG         CLR         D4
000014A2  3839 000018EE            653                          MOVE.W      CURRENT_WORD,D4
000014A8  0244 0007                654                          ANDI.W      #FILT_SRC_REG,D4        ; turn D4 into 0000 0000 0000 0XXX. (no need for LSR in this case.)
000014AC  13C4 000018F4            655                          MOVE.B      D4,CURRENT_SRC_REG
000014B2  4E75                     656                          RTS
000014B4                           657                          
000014B4                           658  *----------------------Read additional source data associated with the current word (if necessary).----------------- 
000014B4                           659  *This needs to postincrement A5 as necessary.
000014B4  4244                     660  READ_SOURCE_DATA        CLR         D4
000014B6  3839 000018EE            661                          MOVE.W      CURRENT_WORD,D4
000014BC  0244 0038                662                          ANDI.W      #FILT_SRC_MD,D4         ; check the source mode of D4
000014C0  E64C                     663                          LSR.W       #3,D4
000014C2  B87C 0007                664                          CMP         #CONST_ADDR_MISC_MD,D4  ; see if we have a source mode that requires additional data.
000014C6  6700 0004                665                          BEQ         CONFIRM_READ_SRC_DATA   ; if so, we then we read the register for more information about the type of additional data we need to read.                    
000014CA  4E75                     666                          RTS
000014CC                           667                          
000014CC  4244                     668  CONFIRM_READ_SRC_DATA   CLR         D4                           
000014CE  3839 000018EE            669                          MOVE.W      CURRENT_WORD,D4
000014D4  0244 0007                670                          ANDI.W      #FILT_SRC_REG,D4             ; put the source register in D4  
000014D8                           671  
000014D8  6100 0046                672                          BSR         CONFIRM_READ_DATA
000014DC  23F9 000018F8 000018FC   673                          MOVE.L      CURRENT_DATA,CURRENT_SRC_DATA
000014E6  4E75                     674                          RTS
000014E8                           675                          
000014E8                           676  *--------TODO: READ_OP_SIZE---------
000014E8                           677   
000014E8                           678  *----------------------Read additional destination data associated with the current word (if necessary).----------------- 
000014E8                           679  *This needs to postincrement A5 as necessary.                       
000014E8  4244                     680  READ_DEST_DATA          CLR         D4
000014EA  3839 000018EE            681                          MOVE.W      CURRENT_WORD,D4
000014F0  0244 01C0                682                          ANDI.W      #FILT_DEST_MD,D4         ; check the destination mode of D4
000014F4  EC4C                     683                          LSR.W       #6,D4
000014F6  B87C 0007                684                          CMP         #CONST_ADDR_MISC_MD,D4   ; see if we have a destination mode that requires additional data.
000014FA  6700 0004                685                          BEQ         CONFIRM_READ_DEST_DATA   ; if so, we then we read the register for more information about the type of additional data we need to read.                    
000014FE  4E75                     686                          RTS
00001500                           687                                              
00001500  4244                     688  CONFIRM_READ_DEST_DATA  CLR         D4                           
00001502  3839 000018EE            689                          MOVE.W      CURRENT_WORD,D4
00001508  0244 0007                690                          ANDI.W      #FILT_SRC_REG,D4             ; put the destination register in D4  
0000150C  E04C                     691                          LSR.W       #8,D4
0000150E  E24C                     692                          LSR.W       #1,D4
00001510                           693                          
00001510  6100 000E                694                          BSR         CONFIRM_READ_DATA
00001514  23F9 000018F8 00001900   695                          MOVE.L      CURRENT_DATA,CURRENT_DEST_DATA
0000151E  4E75                     696                          RTS
00001520                           697  
00001520                           698  *-----------------------Read some additional data.----------------------------------------------------------
00001520                           699        ; This same subroutine is used for reading source and destination data.
00001520                           700        ; By this point, D4 holds whatever register we currently care about. (could also use CURRENT_REG)         
00001520  B87C 0002                701  CONFIRM_READ_DATA       CMP         #CONST_COUNTR_DISPLC_REG,D4  ; see if we are reading counter w/ displacement
00001524  6700 0024                702                          BEQ         READ_COUNTR_DISPLC_DATA
00001528                           703                     
00001528  B87C 0003                704                          CMP         #CONST_COUNTR_INDEX_REG,D4   ; see if we are reading counter w/ index
0000152C  6700 001E                705                          BEQ         READ_COUNTR_INDEX_DATA
00001530                           706                          
00001530  B87C 0000                707                          CMP         #CONST_ABS_SHORT_REG,D4      ; see if we are reading absolute short address
00001534  6700 0018                708                          BEQ         READ_ABS_SHORT_DATA
00001538                           709                          
00001538  B87C 0001                710                          CMP         #CONST_ABS_LONG_REG,D4       ; see if we are reading absolute long address
0000153C  6700 0012                711                          BEQ         READ_ABS_LONG_DATA 
00001540                           712                          
00001540  B87C 0004                713                          CMP         #CONST_IMMEDIATE_REG,D4       ; see if we are reading immediate data
00001544  6700 000C                714                          BEQ         READ_IMMEDIATE_DATA
00001548                           715       
00001548  4E75                     716                          RTS
0000154A                           717                          
0000154A                           718  ; TODO: each of these SRs should increment A5 by the proper amount while also storing the correct data in CURRENT_DATA.
0000154A  4E75                     719  READ_COUNTR_DISPLC_DATA RTS ; TODO: read data for counter w/ displacement (d16,PC)
0000154C                           720  
0000154C  4E75                     721  READ_COUNTR_INDEX_DATA  RTS ; TODO: read data for counter w/ index        (d16,PC,Xn)
0000154E                           722  
0000154E  4E75                     723  READ_ABS_SHORT_DATA     RTS ; TODO: read data for absolute short address  (xxx).W
00001550                           724  
00001550  4E75                     725  READ_ABS_LONG_DATA      RTS ; TODO: read data for absolute long address   (xxx).L
00001552                           726  
00001552  6100 0004                727  READ_IMMEDIATE_DATA     BSR         CHECK_IMM_BYTE
00001556  4E75                     728                          RTS
00001558                           729  
00001558                           730      ; if this is a byte operation, we read an additional word.
00001558  0C39 0000 000018F0       731  CHECK_IMM_BYTE          CMP.B       #BYTE_SIZE,CURRENT_OP_SIZE
00001560  6700 0040                732                          BEQ         READ_IMMEDIATE_DATA_W
00001564  0C39 0000 000018F0       733                          CMP.B       #BYTE_SIZE,CURRENT_OP_SIZE  ; need to check again for this SR to work
0000156C  6600 0004                734                          BNE         CHECK_IMM_WORD              ; only go to next SR if we are not reading a byte. otherwise, return now.
00001570  4E75                     735                          RTS
00001572                           736  
00001572                           737      ; if this is a word operation, we read an additional word.                        
00001572  0C39 0001 000018F0       738  CHECK_IMM_WORD          CMP.B       #WORD_SIZE,CURRENT_OP_SIZE
0000157A  6700 0026                739                          BEQ         READ_IMMEDIATE_DATA_W
0000157E  0C39 0001 000018F0       740                          CMP.B       #WORD_SIZE,CURRENT_OP_SIZE 
00001586  6600 0004                741                          BNE         CHECK_IMM_LONG
0000158A  4E75                     742                          RTS
0000158C                           743  
0000158C                           744      ; if this is a long operation, we read an additional long.                        
0000158C  0C39 0002 000018F0       745  CHECK_IMM_LONG          CMP.B       #LONG_SIZE,CURRENT_OP_SIZE
00001594  6700 0016                746                          BEQ         READ_IMMEDIATE_DATA_L
00001598  0C79 0002 000018F0       747                          CMP         #LONG_SIZE,CURRENT_OP_SIZE
000015A0                           748                          ;TODO: error case here (use BNE to branch to it)
000015A0                           749                          ;BNE         CHECK_IMM_WORD
000015A0  4E75                     750                          RTS
000015A2                           751  
000015A2  4244                     752  READ_IMMEDIATE_DATA_W   CLR         D4
000015A4  33DD 000018F8            753                          MOVE.W      (A5)+,CURRENT_DATA
000015AA                           754                          ;MOVE.W      D4,(CURRENT_DATA) ; read an additional word and store its value in CURRENT_DATA
000015AA  4E75                     755                          RTS
000015AC                           756                          
000015AC  4244                     757  READ_IMMEDIATE_DATA_L   CLR         D4
000015AE  23DD 000018F8            758                          MOVE.L      (A5)+,CURRENT_DATA
000015B4                           759                          ;MOVE.L      D4,CURRENT_DATA ; read an additional long and store its value in CURRENT_DATA
000015B4  4E75                     760                          RTS
000015B6                           761                          
000015B6                           762  ; TODO: need to check for all these possibilities
000015B6                           763  ;CONST_COUNTR_DISPLC_REG EQU         $02      ; Counter w/ displacement:      XXXX X010
000015B6                           764  ;CONST_COUNTR_INDEX_REG  EQU         $03      ; Counter w/ index:          XXXX X011
000015B6                           765  ;CONST_ABS_SHORT_REG     EQU         $00      ; Absolute word:          (xxx).W       XXXX X000
000015B6                           766  ;CONST_ABS_LONG_REG      EQU         $01      ; Absolute long:          (xxx).L       XXXX X001
000015B6                           767  ;CONST_IMMEDIATE_REG 
000015B6                           768                          ;TODO: finish writing this method (Robert)
000015B6                           769                          
000015B6                           770  *----------------------Read additional destination data associated with the current word (if necessary).----------------- 
000015B6                           771  *NOTE: pretty sure we will not use this method at all.
000015B6                           772  ;READ_DEST_DATA          CLR         D4
000015B6                           773  ;                        MOVE.W      CURRENT_WORD,D4
000015B6                           774  ;                        ;TODO: finish writing this method (Robert)
000015B6                           775                          
000015B6                           776  *----------------------Display the source for the current instruction.-----------------
000015B6                           777  *by this point, error checking should already be done and CURRENT_SRC_MD and CURRENT_SRC_REG should have the data we need.
000015B6                           778  DISPLAY_SOURCE          ;CLR.B       CURRENT_MD
000015B6                           779                          ;CLR.B       CURRENT_REG
000015B6  13F9 000018F3 000018F1   780                          MOVE.B      CURRENT_SRC_MD,CURRENT_MD
000015C0  13F9 000018F4 000018F2   781                          MOVE.B      CURRENT_SRC_REG,CURRENT_REG    
000015CA  23F9 000018FC 000018F8   782                          MOVE.L      CURRENT_SRC_DATA,CURRENT_DATA
000015D4  6100 0028                783                          BSR         CHECK_ADDRESSING_MODES   
000015D8  4E75                     784                          RTS  
000015DA                           785                          
000015DA                           786  *----------------------Display the destination for the current instruction.-----------------
000015DA                           787  *by this point, error checking should already be done and CURRENT_DEST_MD and CURRENT_DEST_REG should have the data we need.
000015DA                           788  DISPLAY_DEST            ;CLR.B       CURRENT_MD
000015DA                           789                          ;CLR.B       CURRENT_REG
000015DA  13F9 000018F5 000018F1   790                          MOVE.B      CURRENT_DEST_MD,CURRENT_MD
000015E4  13F9 000018F6 000018F2   791                          MOVE.B      CURRENT_DEST_REG,CURRENT_REG    
000015EE  23F9 00001900 000018F8   792                          MOVE.L      CURRENT_DEST_DATA,CURRENT_DATA
000015F8  6100 0004                793                          BSR         CHECK_ADDRESSING_MODES     
000015FC  4E75                     794                          RTS  
000015FE                           795                          
000015FE                           796  
000015FE                           797                          
000015FE                           798  *-----------------------Mode checks (for displaying)---------
000015FE                           799  *these do not care whether the mode is for source or destination.
000015FE  6100 0004                800  CHECK_ADDRESSING_MODES  BSR         CHECK_DATA_REG_MD
00001602  4E75                     801                          RTS
00001604                           802             
00001604  0C39 0000 000018F1       803  CHECK_DATA_REG_MD       CMP.B       #CONST_DATA_REG_MD,CURRENT_MD   ; check for CURRENT_MD = ...0000
0000160C  6600 0022                804                          BNE         CHECK_ADDR_REG_MD
00001610                           805                          ;case for source mode is data register mode.
00001610                           806                         
00001610                           807                          ;TEMP. should send some instruction to display buffer, instead.
00001610  43F9 000018CC            808                          LEA         MSG_D,A1               ; print out 'D'
00001616  103C 000E                809                          MOVE.B      #14,D0
0000161A  4E4F                     810                          TRAP        #15
0000161C                           811                          
0000161C  4241                     812                          CLR         D1
0000161E  1239 000018F2            813                          MOVE.B      (CURRENT_REG),D1      ; print out the number of the data register. (doesn't work yet)
00001624  143C 0010                814                          MOVE.B      #16,D2
00001628  103C 000F                815                          MOVE.B      #15,D0
0000162C  4E4F                     816                          TRAP        #15
0000162E                           817                          
0000162E  4E75                     818                          RTS
00001630                           819                          
00001630  0C39 0001 000018F1       820  CHECK_ADDR_REG_MD       CMP.B       #CONST_ADDR_REG_MD,CURRENT_MD   ; check for CURRENT_MD = ...0001
00001638  6600 0004                821                          BNE         CHECK_ADDR_IND_MD
0000163C                           822                          ;TODO: case for source mode is address register mode.
0000163C  4E75                     823                          RTS
0000163E                           824                          
0000163E  0C39 0002 000018F1       825  CHECK_ADDR_IND_MD       CMP.B       #CONST_ADDR_IND_MD,CURRENT_MD   ; check for CURRENT_MD = ...0010
00001646  6600 0004                826                          BNE         CHECK_ADDR_INCR_MD
0000164A                           827                          ;TODO: case for source mode is address indirect mode.
0000164A  4E75                     828                          RTS
0000164C                           829  
0000164C  0C39 0003 000018F1       830  CHECK_ADDR_INCR_MD      CMP.B       #CONST_ADDR_INCR_MD,CURRENT_MD  ; check for CURRENT_MD = ...0011
00001654  6600 0004                831                          BNE         CHECK_ADDR_DECR_MD
00001658                           832                          ;TODO: case for source mode is address indirect postincrement mode.
00001658  4E75                     833                          RTS
0000165A                           834  
0000165A  0C39 0004 000018F1       835  CHECK_ADDR_DECR_MD      CMP.B       #CONST_ADDR_DECR_MD,CURRENT_MD  ; check for CURRENT_MD = ...0100
00001662  6600 0004                836                          BNE         CHECK_ADDR_DISPLC_MD
00001666                           837                          ;TODO: case for source mode is address indirect postdecrement mode.
00001666  4E75                     838                          RTS     
00001668                           839  
00001668  0C39 0005 000018F1       840  CHECK_ADDR_DISPLC_MD    CMP.B       #CONST_ADDR_DISPLC_MD,CURRENT_MD  ; check for CURRENT_MD = ...0101
00001670  6600 0004                841                          BNE         CHECK_ADDR_INDEX_MD
00001674                           842                          ;TODO: case for source mode is address with displacement mode.
00001674  4E75                     843                          RTS    
00001676                           844  
00001676  0C39 0006 000018F1       845  CHECK_ADDR_INDEX_MD     CMP.B       #CONST_ADDR_INDEX_MD,CURRENT_MD  ; check for CURRENT_MD = ...0110
0000167E  6600 0004                846                          BNE         CHECK_ADDR_MISC_MD
00001682                           847                          ;TODO: case for source mode is address with index mode.
00001682  4E75                     848                          RTS 
00001684                           849                           
00001684  0C39 0007 000018F1       850  CHECK_ADDR_MISC_MD      CMP.B       #CONST_ADDR_MISC_MD,CURRENT_MD  ; check for CURRENT_MD = ...0111
0000168C                           851                          ;BNE         ;where to branch if it's not MISC? anything else should be impossible at this point. Maybe error?
0000168C                           852   
0000168C                           853                          ;TODO: instead of immediate, branch in order to: CHECK_COUNTR_DISPLC_REG, CHECK_COUNTR_INDEX_REG, CHECK_ABS_SHORT_REG, 
0000168C                           854                          ;       CHECK_ABS_LONG_REG, then CHECK_IMMEDIATE_REG 
0000168C  6100 0004                855                          BSR         CHECK_IMMEDIATE_REG
00001690  4E75                     856                          RTS   
00001692                           857  *-----------------------Register checks (for displaying only)---------
00001692                           858  *these do not care whether the register is for source or destination.
00001692                           859  *not for cases where reg is simply a number (like D5, A5, (A5), etc)
00001692                           860  
00001692                           861  ; TODO: change this method once we have the additional data stored in CURRENT_DATA.
00001692  0C39 0004 000018F2       862  CHECK_IMMEDIATE_REG     CMP.B       #CONST_IMMEDIATE_REG,CURRENT_REG
0000169A                           863                          ;TODO: BNE for not immediate
0000169A  43F9 000016CD            864                          LEA         HASH,A1               ; print out '#'. (NOTE: should send this to display buffer instead.)
000016A0  103C 000E                865                          MOVE.B      #14,D0
000016A4  4E4F                     866                          TRAP        #15
000016A6                           867                          
000016A6  43F9 000016C9            868                          LEA         DOLLAR,A1             ; print out '$'. (this saves time since we can more easily find the hex value of the immediate data.)
000016AC  103C 000E                869                          MOVE.B      #14,D0
000016B0  4E4F                     870                          TRAP        #15
000016B2                           871                          
000016B2  3239 000018F8            872                          MOVE.W      (CURRENT_DATA),D1     ; print out the immediate data we are concerned with in hex. 
000016B8  143C 0010                873                          MOVE.B      #16,D2
000016BC  103C 000F                874                          MOVE.B      #15,D0
000016C0  4E4F                     875                          TRAP        #15
000016C2                           876                          
000016C2                           877                          ;LEA         CURRENT_DATA,A1       ; print out the immediate data we are concerned with. (NOTE: this doesn't work right now.)
000016C2                           878                          ;MOVE.B      #14,D0  
000016C2                           879                          ;TRAP        #15
000016C2                           880                          
000016C2  4E75                     881                          RTS
000016C4                           882                          
000016C4                           883                          ;TODO: in this case, we need to use MOVE.?  (A5)+,X where ? is the correct size and X is some temp value for printing.
000016C4                           884  
000016C4                           885  *###################### END EA ##################################
000016C4                           886  *############# BEGIN VARIABLES/CONSTANTS #########################
000016C4                           887  *** Variables and Constants are kept here ***
000016C4                           888  
000016C4                           889  *output characters
000016C4  =0000000D                890  CR                      EQU         $0D
000016C4  =0000000A                891  LF                      EQU         $0A
000016C4= 0D 0A 00                 892  RETURN                  DC.B        CR,LF,0
000016C7= 20 00                    893  SPACE                   DC.B        ' ',0
000016C9= 24 00                    894  DOLLAR                  DC.B        '$',0
000016CB= 2C 00                    895  COMMA                   DC.B        ',',0
000016CD= 23 00                    896  HASH                    DC.B        '#',0
000016CF                           897  
000016CF                           898  *output messages
000016CF                           899      ;TODO: consider also giving the user the range of valid start/end addresses
000016CF= 50 6C 65 61 73 65 ...    900  START_ADDR_MSG          DC.B        'Please enter a starting hex address to read from.',CR,LF,0
00001703= 50 6C 65 61 73 65 ...    901  END_ADDR_MSG            DC.B        'Please enter an ending hex address to read from.',CR,LF,0
00001736                           902  
00001736= 4E 6F 74 20 61 20 ...    903  INVALID_LEN_MSG         DC.B        'Not a valid length for input address.',CR,LF
0000175D= 50 6C 65 61 73 65 ...    904                          DC.B        'Please enter a valid-length address.',CR,LF,0
00001784= 4E 6F 74 20 61 20 ...    905  INVALID_ADDR_MSG        DC.B        'Not a valid address.',CR,LF
0000179A= 50 6C 65 61 73 65 ...    906                          DC.B        'Please enter a valid address.',CR,LF,0
000017BA= 4E 6F 74 20 61 20 ...    907  INVALID_END_ADDR_MSG    DC.B        'Not a valid end address.',CR,LF
000017D4= 50 6C 65 61 73 65 ...    908                          DC.B        'Please enter an end address after the start address.',CR,LF,0
0000180B                           909                        
0000180B= 4E 6F 74 20 61 20 ...    910  INVALID_ADDR_L_MSG      DC.B        'Not a valid address (too low).',CR,LF
0000182B= 50 6C 65 61 73 65 ...    911                          DC.B        'Please enter a valid address.',CR,LF,0
0000184B                           912                          
0000184B= 4E 6F 74 20 61 20 ...    913  INVALID_ADDR_H_MSG      DC.B        'Not a valid address (too high).',CR,LF
0000186C= 50 6C 65 61 73 65 ...    914                          DC.B        'Please enter a valid address.',CR,LF,0
0000188C                           915                          
0000188C= 44 6F 6E 65 20 72 ...    916  DONE_READING_MSG        DC.B        'Done reading the program.',CR,LF,0
000018A8                           917  
000018A8                           918  *output instruction names (OPcodes)
000018A8                           919      ;constants
000018A8= 52 45 53 45 54 00        920  RESET_MSG               DC.B        'RESET',0
000018AE= 4E 4F 50 00              921  NOP_MSG                 DC.B        'NOP',0
000018B2= 53 54 4F 50 00           922  STOP_MSG                DC.B        'STOP',0
000018B7                           923      ;moves
000018B7= 4D 4F 56 45 2E 42 00     924  MOVE_B_MSG              DC.B        'MOVE.B',0
000018BE= 4D 4F 56 45 2E 57 00     925  MOVE_W_MSG              DC.B        'MOVE.W',0
000018C5= 4D 4F 56 45 2E 4C 00     926  MOVE_L_MSG              DC.B        'MOVE.L',0
000018CC                           927  
000018CC                           928  *other output instruction message constans
000018CC= 44 00                    929  MSG_D                   DC.B        'D',0
000018CE= 41 00                    930  MSG_A                   DC.B        'A',0
000018D0                           931  
000018D0                           932  *storage locations for input
000018D0                           933  START_ADDR_IN           DS.B        20
000018E4                           934  
000018E4                           935  *other I/O-related variables/constants
000018E4  =00000001                936  INPUTTING_START         SET         1 ;if 1, we are inputting start address. If 0, we are inputting end address.
000018E4                           937  DISPLAY_BUFFER          DS.W        5
000018EE                           938  
000018EE                           939  *EA/OPcode parsed instruction variables/constants
000018EE                           940  CURRENT_WORD            DS.W        1 ; current first 16 bits of an instruction.
000018F0                           941  CURRENT_OP_SIZE         DS.B        1 ; current operation size. Byte = 01, Word = 11, Long = 10
000018F1                           942  
000018F1                           943  CURRENT_MD              DS.B        1 ; current mode we are concerened with (ex: 000 for data register mode.)
000018F2                           944  CURRENT_REG             DS.B        1 ; current register number we are concerned with(address, data, etc) that we are looking at. Ex: D0,A5,etc
000018F3                           945  
000018F3                           946  CURRENT_SRC_MD          DS.B        1 ; current source mode
000018F4                           947  CURRENT_SRC_REG         DS.B        1 ; current source register
000018F5                           948  CURRENT_DEST_MD         DS.B        1 ; current desination mode
000018F6                           949  CURRENT_DEST_REG        DS.B        1 ; current desination register
000018F7                           950  
000018F8                           951  CURRENT_DATA            DS.L        1 ; current addition data we are concerned with
000018FC                           952  CURRENT_SRC_DATA        DS.L        1 ; current additional data for source (like absolute addresses, immediate data, etc)
00001900                           953  CURRENT_DEST_DATA       DS.L        1 ; current additional data for destination (like absolute addresses, immediate data, etc) 
00001904                           954  
00001904                           955  *size constants
00001904  =00000000                956  BYTE_SIZE                EQU         $00 ; 0000 0000
00001904  =00000001                957  WORD_SIZE                EQU         $01 ; 0000 0001
00001904  =00000002                958  LONG_SIZE                EQU         $02 ; 0000 0010
00001904                           959  
00001904  =00000001                960  BYTE_SIZE_M              EQU         $01 ; 0000 0001
00001904  =00000003                961  WORD_SIZE_M              EQU         $03 ; 0000 0011
00001904  =00000002                962  LONG_SIZE_M              EQU         $02 ; 0000 0010
00001904                           963  
00001904                           964  *address constants
00001904  =00003000                965  MIN_ADDRESS             EQU         $00003000
00001904  =0FFF0000                966  MAX_ADDRESS             EQU         $0FFF0000
00001904                           967  
00001904                           968  *address variables
00001904  =00007000                969  TEST_ORIGIN             SET         $00007000
00001904  =00007000                970  NEXT_ADDR               SET         TEST_ORIGIN
00001904  =00009000                971  END_ADDR                SET         $00009000
00001904                           972  
00001904                           973  *filters for isolating parts of a hexa instruction. X means 'unknown' and can be 0 or one after ANDI filter.
00001904                           974  *To filter an instruction, ANDI it with the desired filter.
00001904  =0000C000                975  FILT_2BIT_1             EQU         $0000C000   ;first 2 bits:                          XX00 0000 0000 0000
00001904  =0000F000                976  FILT_NIB_1              EQU         $000F000   ;first nibble:                          XXXX 0000 0000 0000
00001904  =00003000                977  FILT_MOVE_SIZE          EQU         $0003000   ;Size of a move operation:              00XX 0000 0000 0000
00001904  =00000E00                978  FILT_DEST_REG           EQU         $0000E00   ;destination register:                  0000 XXX0 0000 0000
00001904  =000001C0                979  FILT_DEST_MD            EQU         $00001C0   ;destination mode:                      0000 000X XX00 0000
00001904  =00000038                980  FILT_SRC_MD             EQU         $0000038   ;source mode:                           0000 0000 00XX X000
00001904  =00000007                981  FILT_SRC_REG            EQU         $0000007   ;source register:                       0000 0000 0000 0XXX
00001904                           982  
00001904                           983  *constants for comparing with filtered instructions. X means 'don't care' (and will be set to 0 by previous filter)
00001904                           984  *(These do not represent the complete insturctions.)
00001904                           985  *(Also note that repetition is allowed for clarity's sake, so two constants can share a value.)
00001904  =00000000                986  CONST_ALL_0             EQU         $0000   ; all 0s:                               0000 0000 0000 0000
00001904                           987      ;MOVE
00001904  =00001000                988  CONST_MOVE_B            EQU         $1000   ; MOVE.B (use first nib)                0001 0000 0000 0000
00001904  =00003000                989  CONST_MOVE_W            EQU         $3000   ; MOVE.W (use first nib)                0011 0000 0000 0000
00001904  =00002000                990  CONST_MOVE_L            EQU         $2000   ; MOVE.L (use first nib)                0010 0000 0000 0000
00001904                           991      ;Mode values
00001904  =00000000                992  CONST_DATA_REG_MD       EQU         $00      ; Data register mode:     Dn            XXXX X000
00001904  =00000001                993  CONST_ADDR_REG_MD       EQU         $01      ; Address register mode:  An            XXXX X001
00001904  =00000002                994  CONST_ADDR_IND_MD       EQU         $02      ; Address indirect mode:  (An)          XXXX X010
00001904  =00000003                995  CONST_ADDR_INCR_MD      EQU         $03      ; Address postincr. mode: (An)+         XXXX X011
00001904  =00000004                996  CONST_ADDR_DECR_MD      EQU         $04      ; Address predecr. mode:  -(An)         XXXX X100
00001904  =00000005                997  CONST_ADDR_DISPLC_MD    EQU         $05      ; Address w/ displacement:(d16,An)      XXXX X101
00001904  =00000006                998  CONST_ADDR_INDEX_MD     EQU         $06      ; Address w/ index:       (d8,PC,Xn)    XXXX X110
00001904  =00000007                999  CONST_ADDR_MISC_MD      EQU         $07      ; Various other addressing modes        XXXX X111
00001904                          1000       ;Constant register values (should not be necessary for register numbers like D5)
00001904  =00000002               1001  CONST_COUNTR_DISPLC_REG EQU         $02      ; Counter w/ displacement:(d16,PC)      XXXX X010
00001904  =00000003               1002  CONST_COUNTR_INDEX_REG  EQU         $03      ; Counter w/ index:       (d16,PC,Xn)   XXXX X011
00001904  =00000000               1003  CONST_ABS_SHORT_REG     EQU         $00      ; Absolute word:          (xxx).W       XXXX X000
00001904  =00000001               1004  CONST_ABS_LONG_REG      EQU         $01      ; Absolute long:          (xxx).L       XXXX X001
00001904  =00000004               1005  CONST_IMMEDIATE_REG     EQU         $04      ; Immediate data:         #imm          XXXX X100
00001904                          1006  
00001904                          1007  *full OPcode contstants
00001904  =00004E70               1008  RESET_CODE              EQU         $4E70   ; RESET                                 0100 1110 0111 0001
00001904  =00004E71               1009  NOP_CODE                EQU         $4E71   ; NOP                                   0100 1110 0111 0001
00001904  =00004E72               1010  STOP_CODE               EQU         $4E72   ; STOP                                  0100 1110 0111 0010
00001904                          1011  
00001904                          1012    
00001904                          1013  *############# END VARIABLES/CONSTANTS #########################
00001904                          1014  
00001904                          1015      END START        ; last line of source, very end of the program

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ASCII_TO_HEX        10B4
BEGIN_READ          12E2
BYTE_SIZE           0
BYTE_SIZE_M         1
CHECK_ADDRESSING_MODES  15FE
CHECK_ADDR_DECR_MD  165A
CHECK_ADDR_DISPLC_MD  1668
CHECK_ADDR_INCR_MD  164C
CHECK_ADDR_INDEX_MD  1676
CHECK_ADDR_IND_MD   163E
CHECK_ADDR_MISC_MD  1684
CHECK_ADDR_REG_MD   1630
CHECK_CONSTANTS     1324
CHECK_DATA_REG_MD   1604
CHECK_DONE_READING  1308
CHECK_IMMEDIATE_REG  1692
CHECK_IMM_BYTE      1558
CHECK_IMM_LONG      158C
CHECK_IMM_WORD      1572
CHECK_MOVE_B        139A
CHECK_MOVE_L        1442
CHECK_MOVE_W        142C
CHECK_NON_CONSTANTS  1394
CHECK_NOP           1338
CHECK_RESET         1328
CHECK_STOP          1384
COMMA               16CB
CONFIRMED_NEXT_OP   12F6
CONFIRM_READ_DATA   1520
CONFIRM_READ_DEST_DATA  1500
CONFIRM_READ_SRC_DATA  14CC
CONST_ABS_LONG_REG  1
CONST_ABS_SHORT_REG  0
CONST_ADDR_DECR_MD  4
CONST_ADDR_DISPLC_MD  5
CONST_ADDR_INCR_MD  3
CONST_ADDR_INDEX_MD  6
CONST_ADDR_IND_MD   2
CONST_ADDR_MISC_MD  7
CONST_ADDR_REG_MD   1
CONST_ALL_0         0
CONST_COUNTR_DISPLC_REG  2
CONST_COUNTR_INDEX_REG  3
CONST_DATA_REG_MD   0
CONST_IMMEDIATE_REG  4
CONST_MOVE_B        1000
CONST_MOVE_L        2000
CONST_MOVE_W        3000
CONVERSION_DONE     12B0
COUNT_INPUT_DIGITS  1046
CR                  D
CURRENT_DATA        18F8
CURRENT_DEST_DATA   1900
CURRENT_DEST_MD     18F5
CURRENT_DEST_REG    18F6
CURRENT_MD          18F1
CURRENT_OP_SIZE     18F0
CURRENT_REG         18F2
CURRENT_SRC_DATA    18FC
CURRENT_SRC_MD      18F3
CURRENT_SRC_REG     18F4
CURRENT_WORD        18EE
DIG_CONV_DONE_1     10DE
DIG_CONV_DONE_2     1112
DIG_CONV_DONE_3     114A
DIG_CONV_DONE_4     1182
DIG_CONV_DONE_5     11BA
DIG_CONV_DONE_6     11F2
DIG_CONV_DONE_7     122A
DIG_CONV_DONE_8     1262
DISPLAY_BUFFER      18E4
DISPLAY_DEST        15DA
DISPLAY_SOURCE      15B6
DOLLAR              16C9
DONE_READING        1310
DONE_READING_MSG    188C
END_ADDR            9000
END_ADDR_MSG        1703
FILT_2BIT_1         C000
FILT_DEST_MD        1C0
FILT_DEST_REG       E00
FILT_MOVE_SIZE      3000
FILT_NIB_1          F000
FILT_SRC_MD         38
FILT_SRC_REG        7
GO_TO_NEXT_OP       12F2
HASH                16CD
INPUTTING_START     1
INVALID_ADDR_HIGH   12A0
INVALID_ADDR_H_MSG  184B
INVALID_ADDR_INPUT  1270
INVALID_ADDR_LOW    1290
INVALID_ADDR_L_MSG  180B
INVALID_ADDR_MSG    1784
INVALID_END_ADDR    1280
INVALID_END_ADDR_MSG  17BA
INVALID_LEN_MSG     1736
LF                  A
LONG_SIZE           2
LONG_SIZE_M         2
MAX_ADDRESS         FFF0000
MIN_ADDRESS         3000
MOVE_B_FOUND        13AC
MOVE_B_MSG          18B7
MOVE_L_FOUND        1454
MOVE_L_MSG          18C5
MOVE_W_FOUND        143E
MOVE_W_MSG          18BE
MSG_A               18CE
MSG_D               18CC
NEXT_ADDR           7000
NOP_CODE            4E71
NOP_FOUND           1344
NOP_MSG             18AE
PREPARE_DISPLAY     12EE
PROMPT_INPUT        1008
READ_ABS_LONG_DATA  1550
READ_ABS_SHORT_DATA  154E
READ_COUNTR_DISPLC_DATA  154A
READ_COUNTR_INDEX_DATA  154C
READ_CURRENT_OP     1320
READ_DEST_DATA      14E8
READ_DEST_MODE      1474
READ_DEST_REG       145C
READ_IMMEDIATE_DATA  1552
READ_IMMEDIATE_DATA_L  15AC
READ_IMMEDIATE_DATA_W  15A2
READ_SOURCE_DATA    14B4
READ_SOURCE_MODE    148A
READ_SOURCE_REG     14A0
RESET_CODE          4E70
RESET_FOUND         1334
RESET_MSG           18A8
RETURN              16C4
SET_END_ADDR        12D8
SET_START_ADDR      12D2
SPACE               16C7
START               1000
START_ADDR_IN       18D0
START_ADDR_MSG      16CF
STOP                1004
STOP_CODE           4E72
STOP_FOUND          1390
STOP_MSG            18B2
TAKE_USER_INPUT     1034
TAKE_USER_IN_E      1020
TAKE_USER_IN_S      100C
TEST_ORIGIN         7000
VALID_ADDR          12C6
WORD_SIZE           1
WORD_SIZE_M         3
