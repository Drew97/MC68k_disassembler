00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.14.00
Created On: 2/22/2014 3:20:36 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Disassembler
00000000                             3  * Written by : Robert Brandenburg, Danielle Jenkins, Shahin Nahar
00000000                             4  * Date       : 2/13/14
00000000                             5  * Description: Disassemble hex machine code instructions into 68K instructions
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8  * TODO: write disassembler
00000000                             9  * TODO: more specific TODOs for our plan
00000000                            10  * TODO: comments saying who is working where
00000000                            11  
00000000                            12  
00000000                            13  * Commenting Key: 
00000000                            14  *    "----------"  <-- subroutine commenting
00000000                            15  *    "##########"  <-- section/role commenting
00000000                            16  
00000000                            17  * Notes on saving registers on run:
00000000                            18  *    MOVEM.L A0-A3/D0-D7, -(A7) * copies all working registers to stack
00000000                            19  *    MOVEM.L (A7)+, A0-A3/D0-D7 *Restore the registers
00000000                            20  
00000000                            21  * Notes on AND filters (bit masking):
00000000                            22  * Example:
00000000                            23  *       0001 000 001 111 100   (say you want "001")
00000000                            24  *   AND 0000 000 111 000 000   (0 <-- don't want, 1 <-- do want)
00000000                            25  *       --------------------
00000000                            26  *     = 0000 000 001 000 000
00000000                            27  *
00000000                            28  * Relevant wiki page:
00000000                            29  *   https://en.wikipedia.org/wiki/Mask_(computing)#Masking_bits_to_0
00000000                            30  *
00000000                            31  *################ TODO LIST ################################
00000000                            32  *----------------OPcode TODOS (ROBERT)-----------------------------
00000000                            33  *
00000000                            34  * Fix the current bugs with MOVEs performed on absolute addresses. Not sure why these errors occur.
00000000                            35  *   -consult the bug report before trying to debug.
00000000                            36  * Continue decoding OPcodes in the following order: (with sizes)
00000000                            37  *   NOTE: I will delete OPcodes from this list as I implement them.
00000000                            38  
00000000                            39  *   -MOVEM  (W,L)
00000000                            40  *   -ADD    (B,W,L) (will need shahin's size filter for this and below)
00000000                            41  *   -ADDA   (W,L)
00000000                            42  *   -ADDI   (B,W,L)
00000000                            43  *   -SUB    (B,W,L)
00000000                            44  *   -SUBA   (W,L)
00000000                            45  *   -SUBQ   (B,W,L)
00000000                            46  *   -MULS   (W)     (not MULU?)
00000000                            47  *   -DIVU   (W      (not DIVU?)
00000000                            48  *   -LEA    (?)
00000000                            49  *   -CLR    (B,W,L)
00000000                            50  *   -AND    (B,W,L)
00000000                            51  *   -ANDI   (B,W,L)
00000000                            52  *   -EOR    (B,W,L)
00000000                            53  *   -EORI   (B,W,L)
00000000                            54  *   -ASR    (B,W,L) (no ASL?)
00000000                            55  *   -LSL    (B,W,L) (no LSR?)
00000000                            56  *   -ROL    (B,W,L)
00000000                            57  *   -ROR    (B,W,L)
00000000                            58  *   -BCHG   (?)
00000000                            59  *   -CMP    (B,W,L)
00000000                            60  *   -CMPA   (W,L)
00000000                            61  *   -CMPI   (B,W,L)
00000000                            62  *   -JSR    (N/A)
00000000                            63  *   (add others if we have time)
00000000                            64  *
00000000                            65  *----------------I/O TODOS (DANIELLE)-----------------------------
00000000                            66  * (TODOs for I/O go here.)
00000000                            67  *----------------EA TODOS  (SHAHIN)-----------------------------
00000000                            68  * (TODOs for EA go here.)
00000000                            69  *################ BEGIN MAIN ###############################
00000000                            70  *** All subroutine calls are made here ***
00001000                            71  START                   ORG        $1000       ; first instruction of program
00001000  6000 0006                 72                          BRA        PROMPT_INPUT            ; prompt the user for input
00001004                            73                   
00001004  4E72 2700                 74  STOP                    STOP       #$2700          ; halt simulator, end of main
00001008                            75  
00001008                            76  *################ END MAIN ###############################
00001008                            77  *################ BEGIN IO ###############################
00001008                            78  *** IO Subroutines are kept here ***
00001008                            79  
00001008                            80  *-------------------- Print ASCII logo ----------------------
00001008  6000 0002                 81  PROMPT_INPUT            BRA         TAKE_USER_IN_S ;TODO: change to welcome/ASCII logo
0000100C                            82  *------------------- Prompt user for input -------------------
0000100C                            83  
0000100C                            84                  
0000100C  163C 0001                 85  TAKE_USER_IN_S          MOVE.B      #1,D3
00001010  43F9 00001E79             86                          LEA         START_ADDR_MSG,A1  ; Prompt user for starting address
00001016  103C 000E                 87                          MOVE.B      #14,D0
0000101A  4E4F                      88                          TRAP        #15
0000101C                            89  
0000101C  6000 0016                 90                          BRA         TAKE_USER_INPUT
00001020                            91  
00001020  163C 0000                 92  TAKE_USER_IN_E          MOVE.B      #0,D3
00001024  43F9 00001EAD             93                          LEA         END_ADDR_MSG,A1  ; prompt user for ending address
0000102A  103C 000E                 94                          MOVE.B      #14,D0
0000102E  4E4F                      95                          TRAP        #15
00001030                            96                          
00001030  6000 0002                 97                          BRA         TAKE_USER_INPUT
00001034                            98                          
00001034  7200                      99  TAKE_USER_INPUT         MOVE.L      #$00000000,D1   ; need to clear out the data registers we are about to use to avoid junk data.   
00001036  7A00                     100                          MOVE.L      #$00000000,D5    
00001038  7C00                     101                          MOVE.L      #$00000000,D6
0000103A  7E00                     102                          MOVE.L      #$00000000,D7
0000103C                           103  
0000103C  103C 0002                104                          MOVE.B      #2,D0           ; Take user input for next address.
00001040  327C 2000                105                          MOVEA.W     #$2000,A1       ; Store the ascii input in A1,(note that we might not want to use 2000 here)
00001044  4E4F                     106                          TRAP        #15             ; and the length in D1.W.  
00001046                           107  
00001046  327C 2001                108  COUNT_INPUT_DIGITS      MOVEA.W     #$2001,A1
0000104A  B27C 0001                109                          CMP         #1,D1
0000104E  6700 0064                110                          BEQ         ASCII_TO_HEX  ;start converting if we have 1 digit.
00001052                           111            
00001052  327C 2002                112                          MOVEA.W     #$2002,A1
00001056  B27C 0002                113                          CMP         #2,D1
0000105A  6700 0058                114                          BEQ         ASCII_TO_HEX  ;start converting if we have 2 digits.
0000105E                           115            
0000105E  327C 2003                116                          MOVEA.W     #$2003,A1
00001062  B27C 0003                117                          CMP         #3,D1
00001066  6700 004C                118                          BEQ         ASCII_TO_HEX  ;start converting if we have 3 digits.
0000106A                           119            
0000106A  327C 2004                120                          MOVEA.W     #$2004,A1
0000106E  B27C 0004                121                          CMP         #4,D1
00001072  6700 0040                122                          BEQ         ASCII_TO_HEX  ;start converting if we have 4 digits.
00001076                           123            
00001076  327C 2005                124                          MOVEA.W     #$2005,A1
0000107A  B27C 0005                125                          CMP         #5,D1
0000107E  6700 0034                126                          BEQ         ASCII_TO_HEX  ;start converting if we have 5 digits.
00001082                           127            
00001082  327C 2006                128                          MOVEA.W     #$2006,A1
00001086  B27C 0006                129                          CMP         #6,D1
0000108A  6700 0028                130                          BEQ         ASCII_TO_HEX  ;start converting if we have 6 digits.
0000108E                           131            
0000108E  327C 2007                132                          MOVEA.W     #$2007,A1
00001092  B27C 0007                133                          CMP         #7,D1
00001096  6700 001C                134                          BEQ         ASCII_TO_HEX  ;start converting if we have 7 digits.
0000109A                           135            
0000109A  327C 2008                136                          MOVEA.W     #$2008,A1
0000109E  B27C 0008                137                          CMP         #8,D1
000010A2  6700 0010                138                          BEQ         ASCII_TO_HEX  ;start converting if we have 8 digits.
000010A6                           139            
000010A6  43F9 00001EE0            140                          LEA         INVALID_LEN_MSG,A1         ; If we get an invalid length, give and error message and... branch back asking user for input again
000010AC  103C 000E                141                          MOVE.B      #14,D0
000010B0  4E4F                     142                          TRAP        #15
000010B2                           143  
000010B2  6780                     144                          BEQ         TAKE_USER_INPUT               
000010B4                           145  
000010B4                           146  
000010B4                           147  
000010B4                           148  *------------------- Convert to hex subroutine -------------------
000010B4                           149  
000010B4  7C00                     150  ASCII_TO_HEX            MOVE.L      #$00000000,D6      ; running total of converted hex number
000010B6                           151                  
000010B6                           152                          ;first digit
000010B6  1A21                     153                          MOVE.B      -(A1),D5  ; Move the raw ascii value of first digit into 3007.
000010B8  BA7C 0030                154                          CMP         #$30,D5
000010BC  6D00 01B2                155                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
000010C0  BA7C 0040                156                          CMP         #$40,D5
000010C4  6700 01AA                157                          BEQ         INVALID_ADDR_INPUT
000010C8  BA7C 0046                158                          CMP         #$46,D5
000010CC  6E00 01A2                159                          BGT         INVALID_ADDR_INPUT   
000010D0                           160                          ; Convert ascii to hex for that digit.
000010D0  0445 0030                161                          SUB         #$30,D5   ;
000010D4  BA7C 000A                162                          CMP         #$A,D5
000010D8  6D00 0004                163                          BLT         DIG_CONV_DONE_1 ; Necessary to convert some ASCII values.
000010DC  5F05                     164                          SUB.B       #7, D5                      ; TODO: errors for invalid ASCII values.
000010DE                           165                  
000010DE  DC45                     166  DIG_CONV_DONE_1         ADD.W       D5,D6
000010E0  B27C 0001                167                          CMP         #1,D1
000010E4  6700 01CA                168                          BEQ         CONVERSION_DONE
000010E8                           169                  
000010E8                           170                          ;second digit
000010E8  7A00                     171                          MOVE.L      #$00000000,D5
000010EA  1A21                     172                          MOVE.B      -(A1),D5
000010EC  BA7C 0030                173                          CMP         #$30,D5
000010F0  6D00 017E                174                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
000010F4  BA7C 0040                175                          CMP         #$40,D5
000010F8  6700 0176                176                          BEQ         INVALID_ADDR_INPUT
000010FC  BA7C 0046                177                          CMP         #$46,D5
00001100  6E00 016E                178                          BGT         INVALID_ADDR_INPUT   
00001104  0445 0030                179                          SUB         #$30,D5
00001108  BA7C 000A                180                          CMP         #$A,D5            
0000110C  6D00 0004                181                          BLT         DIG_CONV_DONE_2    ;digit conversion done 1
00001110  5F05                     182                          SUB.B       #7, D5             ; if we have A or greater, then we need to subtract 1.
00001112                           183               
00001112  CAFC 0010                184  DIG_CONV_DONE_2         MULU.W      #$00000010,D5  ; this part adds $10 * (2nd digit) to our running total.
00001116  DC45                     185                          ADD.W       D5,D6 
00001118                           186                    
00001118  B27C 0002                187                          CMP         #2,D1
0000111C  6700 0192                188                          BEQ         CONVERSION_DONE
00001120                           189                  
00001120                           190                          ;third digit
00001120  7A00                     191                          MOVE.L      #$00000000,D5
00001122  1A21                     192                          MOVE.B      -(A1),D5
00001124  BA7C 0030                193                          CMP         #$30,D5
00001128  6D00 0146                194                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
0000112C  BA7C 0040                195                          CMP         #$40,D5
00001130  6700 013E                196                          BEQ         INVALID_ADDR_INPUT
00001134  BA7C 0046                197                          CMP         #$46,D5
00001138  6E00 0136                198                          BGT         INVALID_ADDR_INPUT   
0000113C  0445 0030                199                          SUB         #$30,D5
00001140  BA7C 000A                200                          CMP         #$A,D5
00001144  6D00 0004                201                          BLT         DIG_CONV_DONE_3 
00001148  5F05                     202                          SUB.B       #7, D5
0000114A                           203                  
0000114A  CAFC 0100                204  DIG_CONV_DONE_3         MULU.W      #$00000100,D5
0000114E  DC45                     205                          ADD.W       D5,D6 
00001150                           206      
00001150  B27C 0003                207                          CMP         #3,D1
00001154  6700 015A                208                          BEQ         CONVERSION_DONE
00001158                           209                  
00001158                           210                          ;fourth digit
00001158  7A00                     211                          MOVE.L      #$00000000,D5
0000115A  1A21                     212                          MOVE.B      -(A1),D5
0000115C  BA7C 0030                213                          CMP         #$30,D5
00001160  6D00 010E                214                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
00001164  BA7C 0040                215                          CMP         #$40,D5
00001168  6700 0106                216                          BEQ         INVALID_ADDR_INPUT
0000116C  BA7C 0046                217                          CMP         #$46,D5
00001170  6E00 00FE                218                          BGT         INVALID_ADDR_INPUT   
00001174  0445 0030                219                          SUB         #$30,D5
00001178  BA7C 000A                220                          CMP         #$A,D5
0000117C  6D00 0004                221                          BLT         DIG_CONV_DONE_4
00001180  5F05                     222                          SUB.B       #7,D5
00001182                           223                  
00001182  CAFC 1000                224  DIG_CONV_DONE_4         MULU.W      #$00001000,D5
00001186  DC45                     225                          ADD.W       D5,D6 
00001188                           226      
00001188  B27C 0004                227                          CMP         #4,D1
0000118C  6700 0122                228                          BEQ         CONVERSION_DONE
00001190                           229                  
00001190                           230                          ;fifth digit
00001190  7A00                     231                          MOVE.L      #$00000000,D5
00001192  1A21                     232                          MOVE.B      -(A1),D5
00001194  BA7C 0030                233                          CMP         #$30,D5
00001198  6D00 00D6                234                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
0000119C  BA7C 0040                235                          CMP         #$40,D5
000011A0  6700 00CE                236                          BEQ         INVALID_ADDR_INPUT
000011A4  BA7C 0046                237                          CMP         #$46,D5
000011A8  6E00 00C6                238                          BGT         INVALID_ADDR_INPUT   
000011AC  0445 0030                239                          SUB         #$30,D5
000011B0  BA7C 000A                240                          CMP         #$A,D5
000011B4  6D00 0004                241                          BLT         DIG_CONV_DONE_5
000011B8  5F05                     242                          SUB.B       #$7, D5
000011BA                           243                  
000011BA  CAFC 0001                244  DIG_CONV_DONE_5         MULU.W      #$0001,D5
000011BE  DE45                     245                          ADD.W       D5,D7 
000011C0                           246  
000011C0  B27C 0005                247                          CMP         #5,D1
000011C4  6700 00EA                248                          BEQ         CONVERSION_DONE
000011C8                           249                  
000011C8                           250                          ;sixth digit
000011C8  7A00                     251                          MOVE.L      #$00000000,D5
000011CA  1A21                     252                          MOVE.B      -(A1),D5
000011CC  BA7C 0030                253                          CMP         #$30,D5
000011D0  6D00 009E                254                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
000011D4  BA7C 0040                255                          CMP         #$40,D5
000011D8  6700 0096                256                          BEQ         INVALID_ADDR_INPUT
000011DC  BA7C 0046                257                          CMP         #$46,D5
000011E0  6E00 008E                258                          BGT         INVALID_ADDR_INPUT   
000011E4  0445 0030                259                          SUB         #$30,D5
000011E8  BA7C 000A                260                          CMP         #$A,D5
000011EC  6D00 0004                261                          BLT         DIG_CONV_DONE_6
000011F0  5F05                     262                          SUB.B       #$7, D5
000011F2                           263                  
000011F2  CAFC 0010                264  DIG_CONV_DONE_6         MULU.W      #$0010,D5
000011F6  DE45                     265                          ADD.W       D5,D7
000011F8                           266      
000011F8  B27C 0006                267                          CMP         #6,D1
000011FC  6700 00B2                268                          BEQ         CONVERSION_DONE
00001200                           269                  
00001200                           270                          ;seventh digit
00001200  7A00                     271                          MOVE.L      #$00000000,D5
00001202  1A21                     272                          MOVE.B      -(A1),D5
00001204  BA7C 0030                273                          CMP         #$30,D5
00001208  6D00 0066                274                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
0000120C  BA7C 0040                275                          CMP         #$40,D5
00001210  6700 005E                276                          BEQ         INVALID_ADDR_INPUT
00001214  BA7C 0046                277                          CMP         #$46,D5
00001218  6E00 0056                278                          BGT         INVALID_ADDR_INPUT   
0000121C  0445 0030                279                          SUB         #$30,D5
00001220  BA7C 000A                280                          CMP         #$A,D5
00001224  6D00 0004                281                          BLT         DIG_CONV_DONE_7
00001228  5F05                     282                          SUB.B       #7, D5
0000122A                           283                  
0000122A  CAFC 0100                284  DIG_CONV_DONE_7         MULU.W      #$0100,D5
0000122E  DE45                     285                          ADD.W       D5,D7
00001230                           286      
00001230  B27C 0007                287                          CMP         #7,D1
00001234  6700 007A                288                          BEQ         CONVERSION_DONE
00001238                           289                  
00001238                           290                          ;eighth digit
00001238  7A00                     291                          MOVE.L      #$00000000,D5
0000123A  1A21                     292                          MOVE.B      -(A1),D5
0000123C  BA7C 0030                293                          CMP         #$30,D5
00001240  6D00 002E                294                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
00001244  BA7C 0040                295                          CMP         #$40,D5
00001248  6700 0026                296                          BEQ         INVALID_ADDR_INPUT
0000124C  BA7C 0046                297                          CMP         #$46,D5
00001250  6E00 001E                298                          BGT         INVALID_ADDR_INPUT   
00001254  0445 0030                299                          SUB         #$30,D5
00001258  BA7C 000A                300                          CMP         #$A,D5
0000125C  6D00 0004                301                          BLT         DIG_CONV_DONE_8
00001260  5F05                     302                          SUB.B       #7, D5
00001262                           303                  
00001262  CAFC 1000                304  DIG_CONV_DONE_8         MULU.W      #$1000,D5
00001266  DE45                     305                          ADD.W       D5,D7
00001268                           306      
00001268  B27C 0008                307                          CMP         #8,D1
0000126C  6700 0042                308                          BEQ         CONVERSION_DONE    ;the input was valid and we are done with the conversion
00001270                           309                  
00001270  43F9 00001F2E            310  INVALID_ADDR_INPUT      LEA         INVALID_ADDR_MSG,A1    ;tell the user the address was invalid and prompt input again.
00001276  103C 000E                311                          MOVE.B      #14,D0
0000127A  4E4F                     312                          TRAP        #15
0000127C                           313                          
0000127C  6000 FDB6                314                          BRA         TAKE_USER_INPUT
00001280                           315                          
00001280  43F9 00001F64            316  INVALID_END_ADDR        LEA         INVALID_END_ADDR_MSG,A1
00001286  103C 000E                317                          MOVE.B      #14,D0
0000128A  4E4F                     318                          TRAP        #15
0000128C                           319                          
0000128C  6000 FDA6                320                          BRA         TAKE_USER_INPUT
00001290                           321                          
00001290  43F9 00001FB5            322  INVALID_ADDR_LOW        LEA         INVALID_ADDR_L_MSG,A1    ;tell the user the address was invalid and prompt input again.
00001296  103C 000E                323                          MOVE.B      #14,D0
0000129A  4E4F                     324                          TRAP        #15
0000129C                           325                          
0000129C  6000 FD96                326                          BRA         TAKE_USER_INPUT
000012A0                           327  
000012A0  43F9 00001FF5            328  INVALID_ADDR_HIGH       LEA         INVALID_ADDR_H_MSG,A1    ;tell the user the address was invalid and prompt input again.
000012A6  103C 000E                329                          MOVE.B      #14,D0
000012AA  4E4F                     330                          TRAP        #15
000012AC                           331                          
000012AC  6000 FD86                332                          BRA         TAKE_USER_INPUT
000012B0                           333                 
000012B0  E18F                     334  CONVERSION_DONE         LSL.L       #8,D7   ; Prepare for concatenation
000012B2  E18F                     335                          LSL.L       #8,D7   ; Got to perform the same operation twice to get it all the way to the left
000012B4  DE46                     336                          ADD.W       D6,D7  ; concatenate the two data registers into one value
000012B6                           337                          
000012B6  BEBC 00003000            338                          CMP.L       #MIN_ADDRESS,D7
000012BC  6DD2                     339                          BLT         INVALID_ADDR_LOW ;Not a valid address-- too low.
000012BE                           340                          
000012BE  BEBC 0FFF0000            341                          CMP.L       #MAX_ADDRESS,D7
000012C4  6EDA                     342                          BGT         INVALID_ADDR_HIGH  ;Not a valid address-- too high.
000012C6                           343                          
000012C6  0C43 0001                344  VALID_ADDR              CMPI        #1,D3
000012CA                           345                          
000012CA  6700 0006                346                          BEQ         SET_START_ADDR
000012CE  6000 0008                347                          BRA         SET_END_ADDR              
000012D2                           348                                                 
000012D2  2A47                     349  SET_START_ADDR          MOVEA.L     D7,A5  ;when a valid start address is inputted, store and ask the user for an end address.
000012D4  6000 FD4A                350                          BRA         TAKE_USER_IN_E
000012D8                           351  
000012D8  BE8D                     352  SET_END_ADDR            CMP.L       A5,D7    ;if end address is lower than start address, we get an error.
000012DA  6DA4                     353                          BLT         INVALID_END_ADDR           
000012DC                           354                          
000012DC  2C47                     355                          MOVEA.L     D7,A6  ;when a valid start address is inputted, store and ask the user for an end address.
000012DE  6000 0002                356                          BRA         BEGIN_READ
000012E2                           357                          
000012E2  284D                     358  BEGIN_READ              MOVEA.L      A5,A4 ; keep track of address to print with A4. TODO: could also add this value to the display buffer.
000012E4  33DD 000020C2            359                          MOVE.W      (A5)+,CURRENT_WORD ;look at the first instruction word at the starting address.
000012EA  6000 0002                360                          BRA         PREPARE_DISPLAY
000012EE                           361  
000012EE                           362  *------------------- Add to display buffer -------------------
000012EE                           363  ;At this point A5 is a valid start address and A6 is a valid end address.
000012EE                           364  ;TODO: prepare the display buffer
000012EE  6000 0030                365  PREPARE_DISPLAY         BRA         READ_CURRENT_OP    ;TEMP (though we might still call this after the display buffer is prepared)                       
000012F2                           366                 
000012F2                           367  *------------------- Move address pointer for data reading -------------------
000012F2                           368  ; This method is specifically for reading the next OPword.
000012F2  6000 0014                369  GO_TO_NEXT_OP           BRA         CHECK_DONE_READING
000012F6                           370                           
000012F6  4279 000020C2            371  CONFIRMED_NEXT_OP       CLR         CURRENT_WORD
000012FC  284D                     372                          MOVEA.L     A5,A4 ; keep track of address to print with A4. 
000012FE  33DD 000020C2            373                          MOVE.W      (A5)+,CURRENT_WORD
00001304  6000 001A                374                          BRA         READ_CURRENT_OP
00001308                           375                          
00001308                           376  *------------------- Print display buffer -------------------
00001308                           377  
00001308                           378  ;TODO
00001308                           379  
00001308                           380  *------------------- Check if end of data -------------------
00001308  BACE                     381  CHECK_DONE_READING      CMPA        A6,A5       ; TODO: this comparison is not sufficient, because it will say that $8000 is less than $7000 (since $8000 is negative.)
0000130A  6DEA                     382                          BLT         CONFIRMED_NEXT_OP
0000130C  6000 0002                383                          BRA         DONE_READING
00001310                           384                          
00001310                           385  *------------------- Confirm end of data -------------------
00001310  43F9 00002036            386  DONE_READING            LEA         DONE_READING_MSG,A1 ; when we reach the end address, say so and halt the program. TODO: ask user whether we want to read the data again.
00001316  103C 000E                387                          MOVE.B      #14,D0
0000131A  4E4F                     388                          TRAP        #15
0000131C  4EF8 1004                389                          JMP         STOP
00001320                           390                          
00001320                           391  *################## END IO  #####################################
00001320                           392  *################## BEGIN OPCODE ##########################
00001320                           393  *** OPcode Subroutines are kept here ***
00001320                           394  
00001320                           395  ; planned process for reading hex instructions:
00001320                           396          ; NOTE: this process is tentative and subject to change as OPcode person implements. 
00001320                           397                  ;           1) Go to start of instruction reading loop, passing in the address of next instruction.
00001320                           398                  ;           2) Store a word (16 bits) from that address.
00001320                           399                  ;           3) Read the first 4 bits of the word using a filter.
00001320                           400                  ;           4) branch to one of the following paths based on these bits:
00001320                           401                  ;               a) 0000: Read the next 3 bits (i.e., the destination mode). Branch:
00001320                           402                  ;                   i.   000: Read the bits at 0000 0000 XXXX XXXX (may want to make this filter) Branch:
00001320                           403                  ;                       1) 00 111 100: ORI TO CCR (need to read data, I think)
00001320                           404                  ;                       2) 01 111 100: ORI TO SR (need to read data, I think)
00001320                           405                  ;                       3) (default) ORI. Now, read and store:
00001320                           406                  ;                           SIZE:       0000 0000 XX00 0000 (need to make this filter)
00001320                           407                  ;                           MODE:       0000 0000 00XX X000 (need to make this filter)
00001320                           408                  ;                           REGISTER:   0000 0000 0000 0XXX (need to make this filter)
00001320                           409                  ;                           only mandatory additional data is the immediate data.
00001320                           410                  ;                   ii.  001: Read the bits at 0000 0000 XXXX XXXX (may want to make this filter) Branch:
00001320                           411                  ;                       1) 00 111 100: ANDI TO CCR (need to read data, I think)
00001320                           412                  ;                       2) 01 111 100: ANDI TO SR (need to read data, I think)
00001320                           413                  ;                       3) (default) ANDI. Now, read and store:
00001320                           414                  ;                           SIZE:       0000 0000 XX00 0000 (need to make this filter)
00001320                           415                  ;                           MODE:       0000 0000 00XX X000 (need to make this filter)
00001320                           416                  ;                           REGISTER:   0000 0000 0000 0XXX (need to make this filter)
00001320                           417                  ;                           only mandatory additional data is the immediate data.
00001320                           418                  ;                   iii. 101: Read the bits at 0000 0000 XXXX XXXX (may want to make this filter) Branch:
00001320                           419                  ;                       1) 00 111 100: EORI TO CCR (need to read data, I think)
00001320                           420                  ;                       2) 01 111 100: EORI TO SR (need to read data, I think)
00001320                           421                  ;                       3) (default) EORI. Now, read and store:
00001320                           422                  ;                           SIZE:       0000 0000 XX00 0000 (need to make this filter)
00001320                           423                  ;                           MODE:       0000 0000 00XX X000 (FILT_SRC_MODE)
00001320                           424                  ;                           REGISTER:   0000 0000 0000 0XXX (FILT_SRC_REG)
00001320                           425                  ;                           only mandatory additional data is the immediate data.
00001320                           426                  ;                   iv.  011: ADDI. Now read and store:
00001320                           427                  ;                           SIZE:       0000 0000 XX00 0000 (need to make this filter)
00001320                           428                  ;                           MODE:       0000 0000 00XX X000 (FILT_SRC_MODE)
00001320                           429                  ;                           REGISTER:   0000 0000 0000 0XXX (FILT_SRC_REG)
00001320                           430                  ;                           only mandatory additional data is the immediate data.
00001320                           431                  ;                   v.   010: SUBI. Now read and store:
00001320                           432                  ;                           SIZE:       0000 0000 XX00 0000 (need to make this filter)
00001320                           433                  ;                           MODE:       0000 0000 00XX X000 (FILT_SRC_MODE)
00001320                           434                  ;                           REGISTER:   0000 0000 0000 0XXX (FILT_SRC_REG)
00001320                           435                  ;                           only mandatory additional data is the immediate data.
00001320                           436                  ;                   vi.  110: CMPI. Now read and store:
00001320                           437                  ;                           SIZE:       0000 0000 XX00 0000 (need to make this filter)
00001320                           438                  ;                           MODE:       0000 0000 00XX X000 (FILT_SRC_MODE)
00001320                           439                  ;                           REGISTER:   0000 0000 0000 0XXX (FILT_SRC_REG)
00001320                           440                  ;                           only mandatory additional data is the immediate data.
00001320                           441                  ;                   vii. 100: BTST, BCHG, BCLR, BSET (TODO: expand this section if we need these OPcodes)
00001320                           442                  ;                   viii.(default): BTST, BCHG, BCLR, BSET (with data register)(TODO: expand this section if we need these OPcodes)
00001320                           443                  ;               b) 0001: (MOVE.B). Now read and store:
00001320                           444                  ;                           DESTINATION REGISTER: 0000 XXX0 0000 0000 (FILT_DEST_REG)
00001320                           445                  ;                           DESTINATION MODE:     0000 000X XX00 0000 (FILT_DEST_MODE)
00001320                           446                  ;                           SOURCE MODE:          0000 0000 00XX X000 (FILT_SCR_MODE)
00001320                           447                  ;                           SOURCE REGISTER:      0000 0000 0000 0XXX (FILT_SRC_REG)
00001320                           448                  ;                           The modes (and maybe register) will tell us whether we need to read additional data for this MOVE.
00001320                           449                  ;               c) 0011: (MOVE.W). Now read and store:
00001320                           450                  ;                           DESTINATION REGISTER: 0000 XXX0 0000 0000 (FILT_DEST_REG)
00001320                           451                  ;                           DESTINATION MODE:     0000 000X XX00 0000 (FILT_DEST_MODE)
00001320                           452                  ;                           SOURCE MODE:          0000 0000 00XX X000 (FILT_SCR_MODE)
00001320                           453                  ;                           SOURCE REGISTER:      0000 0000 0000 0XXX (FILT_SRC_REG)
00001320                           454                  ;                           The modes (and maybe register) will tell us whether we need to read additional data for this MOVE.
00001320                           455                  ;               d) 0010: (MOVE.L). Now read and store:
00001320                           456                  ;                           DESTINATION REGISTER: 0000 XXX0 0000 0000 (FILT_DEST_REG)
00001320                           457                  ;                           DESTINATION MODE:     0000 000X XX00 0000 (FILT_DEST_MODE)
00001320                           458                  ;                           SOURCE MODE:          0000 0000 00XX X000 (FILT_SCR_MODE)
00001320                           459                  ;                           SOURCE REGISTER:      0000 0000 0000 0XXX (FILT_SRC_REG)
00001320                           460                  ;                           The modes (and maybe register) will tell us whether we need to read additional data for this MOVE.
00001320                           461                  ;               e) 0100: Read the bits at 0000 XXXX 0000 0000 (need filter) Branch:
00001320                           462                  ;                   i.      0000: Read the bits at 0000 0000 XX00 0000 (need filter) Branch:
00001320                           463                  ;                               1. 11: MOVE from SR. (TODO)
00001320                           464                  ;                               2. (DEFAULT) NEGX. (the two bits are size) (TODO)
00001320                           465                  ;                   ii.     0100: Read the bits at 0000 0000 XX00 0000 (need filter) Branch:
00001320                           466                  ;                               1. 11 MOVE to CCR. (TODO)
00001320                           467                  ;                               2. (DEFAULT) NEG. (the two bits are size) (TODO)
00001320                           468                  ;                   iii.    0110: Read the bits at 0000 0000 XX00 0000 (need filter) Branch:
00001320                           469                  ;                               1. 11 MOVE to SR. (TODO)
00001320                           470                  ;                               2. (DEFAULT) NOT. (the two bits are size) (TODO)
00001320                           471                  ;                   iv.     0010: CLR. (TODO)
00001320                           472                  ;                    v.     1000: (EXT, NBCD, SWAP, PEA, MOVEM (dir 0)) (TODO)
00001320                           473                  ;                   vi.     1010: Check the bits at 0000 XX00 0000 0000 (need filter) Branch:
00001320                           474                  ;                           1. 11: check the bits at 0000 00XX XXXX XXXX (need filter) Branch:
00001320                           475                  ;                               a. 11 1100: ILLEGAL (TODO)
00001320                           476                  ;                               b. (default) TAS (TODO)
00001320                           477                  ;                           2. (default) TST (TODO)
00001320                           478                  ;                  vii.     1110: (TRAP, LINK, UNLK, MOVE USP, RESET, NOP, STOP, RTE, RTS, TRAPV, RTR, JSR, JMP) (TODO)
00001320                           479                  ;                 viii.     (DEFAULT): (MOVEM, LEA, CHK,) (TODO)    
00001320                           480                  ;               f) 0101: (ADDQ, SUBQ, Scc, DBcc): Read the bits at 0000 0000 XX00 0000 (need filter) Branch:
00001320                           481                  ;                    i. 11: Read the bit at 0000 000X 0000 0000 (need filter) Branch:
00001320                           482                  ;                           1. 0: ADDQ (TODO)
00001320                           483                  ;                           2. 1: SUBQ (TODO)
00001320                           484                  ;                   ii. (default) (bits are size) read the bits at 0000 00XX X000 (FILT_SRC_MODE). Branch:
00001320                           485                  ;                           1. 001: DBCC (TODO)
00001320                           486                  ;                           2. (default): Scc (TODO)
00001320                           487                  ;               g) 0110: Read the bit at 0000 XXXX 0000 0000 (need filter) Branch:
00001320                           488                  ;                    i. 0000: BRA (TODO)
00001320                           489                  ;                   ii. 0001: BSR (TODO)
00001320                           490                  ;                  iii. (default) Bcc (TODO)
00001320                           491                  ;               h) 0111: MOVEQ (TODO)
00001320                           492                  ;               i) 1000: (DIVU, DIVS, SBCD, OR) (TODO)
00001320                           493                  ;               j) 1001: (SUB, SUBX, SUBA) (TODO)
00001320                           494                  ;               k) 1011: (EOR, CMPM, CMP, CMPA) (TODO)
00001320                           495                  ;               l) 1100: (MULU, MULS, ABCD, EXG, AND) (TODO)
00001320                           496                  ;               m) 1101: (ADD, ADDX, ADDA) (TODO)
00001320                           497                  ;               n) 1110: (ASd, LSd, ROXd, ROd, ASd, LSd, ROXd, ROd) (TODO)
00001320                           498                  ;               o) (default) The code is invalid. Not yet sure what we do in this case.
00001320                           499                  ;   
00001320                           500                  ;   
00001320                           501                  ;
00001320                           502                  
00001320                           503                  ;TODO: Use AND operations with filters to create values which can be
00001320                           504                  ;      checked against constants to narrow down OPcodes.
00001320                           505                  
00001320                           506                  ;TODO: Since it will take a while to decode every possible OPcode, we
00001320                           507                  ;      should first have a default "Error" subroutine which the program
00001320                           508                  ;      branches to once all other possibilities have been ruled out.
00001320                           509  
00001320                           510  *------------------- Read current OPcode -------------------
00001320                           511  ; By this point, CURRENT_WORD should store a potential beginning of an instruction, so we should not increment A5.
00001320  6000 0028                512  READ_CURRENT_OP         BRA         CHECK_CONSTANTS
00001324                           513                          
00001324                           514    
00001324                           515  *------------------- Display current address we are reading -------------------
00001324  43F9 00001E69            516  DISPLAY_CURRENT_ADDRESS LEA         DOLLAR,A1       ; '$'
0000132A  103C 000E                517                          MOVE.B      #14,D0
0000132E  4E4F                     518                          TRAP        #15
00001330                           519                  
00001330  220C                     520                          MOVE.L      A4,D1           ; display the address the instruction was found at
00001332  143C 0010                521                          MOVE.B      #16,D2
00001336  103C 000F                522                          MOVE.B      #15,D0
0000133A  4E4F                     523                          TRAP        #15
0000133C                           524  
0000133C  43F9 00001E67            525                          LEA         SPACE,A1        ; ' '
00001342  103C 000E                526                          MOVE.B      #14,D0      
00001346  4E4F                     527                          TRAP        #15     
00001348                           528                          
00001348  4E75                     529                          RTS
0000134A                           530   
0000134A                           531  *------------------ Check current word for constants---------
0000134A                           532  ; By this point, the current word should store a potential beginning of an instruction.                   
0000134A  0C79 4E70 000020C2       533  CHECK_CONSTANTS         CMP         #RESET_CODE,(CURRENT_WORD)
00001352  6700 001E                534                          BEQ         RESET_FOUND
00001356  0C79 4E71 000020C2       535                          CMP         #NOP_CODE,(CURRENT_WORD)
0000135E  6700 0030                536                          BEQ         NOP_FOUND
00001362  0C79 4E72 000020C2       537                          CMP         #STOP_CODE,(CURRENT_WORD)
0000136A  6700 0042                538                          BEQ         STOP_FOUND
0000136E  6000 0042                539                          BRA         CHECK_NON_CONSTANTS     ;Once we rule out all the constants we know of, we check for non-constants.
00001372                           540  
00001372                           541  ; TODO: change the structure of these subroutines to be like the nice structure used in EA SRs.
00001372                           542                         
00001372  61B0                     543  RESET_FOUND             BSR         DISPLAY_CURRENT_ADDRESS
00001374                           544  
00001374  43F9 0000205B            545                          LEA         RESET_MSG,A1    ; 'RESET'
0000137A  103C 000E                546                          MOVE.B      #14,D0
0000137E  4E4F                     547                          TRAP        #15
00001380                           548                          
00001380  43F9 00001E64            549                          LEA         RETURN,A1       ; (return)
00001386  103C 000E                550                          MOVE.B      #14,D0
0000138A  4E4F                     551                          TRAP        #15
0000138C                           552                 
0000138C  6000 FF64                553                          BRA         GO_TO_NEXT_OP   
00001390                           554   
00001390                           555  ; NOTE: this SR is temporary. Once we have the display buffer, it will work differently.                 
00001390  6192                     556  NOP_FOUND               BSR         DISPLAY_CURRENT_ADDRESS
00001392                           557  
00001392  43F9 00002061            558                          LEA         NOP_MSG,A1    ; 'NOP'
00001398  103C 000E                559                          MOVE.B      #14,D0
0000139C  4E4F                     560                          TRAP        #15
0000139E                           561                          
0000139E  43F9 00001E64            562                          LEA         RETURN,A1     ; (return)
000013A4  103C 000E                563                          MOVE.B      #14,D0
000013A8  4E4F                     564                          TRAP        #15
000013AA                           565                 
000013AA  6000 FF46                566                          BRA         GO_TO_NEXT_OP   ; when we are done parsing and displaying the NOP instruction, go to the next OPcode.
000013AE                           567  
000013AE  4EF8 1004                568  STOP_FOUND              JMP         STOP  ;TODO: case for stop found. (NOTE that STOP instructions have additional data.)               
000013B2                           569  
000013B2                           570  ;TODO: add cases for rest of valid constant OPcodes here
000013B2                           571  
000013B2                           572  *----------------- Check current word for non-constants---------
000013B2                           573  ;NOTE: we currently know that CURRENT_WORD is not a constant by the time we reach this SR.
000013B2                           574  
000013B2  6100 011C                575  CHECK_NON_CONSTANTS     BSR         CHECK_MOVE        ; MOVE is a special case because of how its first nibble is structured.     
000013B6  6100 013E                576                          BSR         CHECK_MOVEQ       ; MOVEQ is also a special case.
000013BA  6100 0150                577                          BSR         CHECK_EXT         ; need to rule out EXT before checking MOVEM, because they have very similar OPcodes.
000013BE  6100 0162                578                          BSR         CHECK_MOVEM      
000013C2  6100 000A                579                          BSR         CHECK_NIB1_0000 
000013C6  6100 001C                580                          BSR         CHECK_NIB1_0100 
000013CA                           581                          
000013CA                           582                          ; TODO: BSR to checks for other special cases, along with nibbles.
000013CA                           583                          
000013CA                           584                          ;NOTE: we do not check for most specific instructions here.
000013CA                           585  
000013CA                           586                          ; TODO: go into the subroutines below and *fully* implement the followings:
000013CA                           587                          *   -MOVEM  (W,L)
000013CA                           588                          *   -ADD    (B,W,L) (will need shahin's size filter for this and below)
000013CA                           589                          *   -ADDA   (W,L)
000013CA                           590                          *   -ADDI   (B,W,L)
000013CA                           591                          *   -SUB    (B,W,L)
000013CA                           592                          ;etc
000013CA  4EF8 1004                593                          JMP         STOP
000013CE                           594                          ;TODO: check for other instructions instead of stopping if it's not one of these.
000013CE                           595    
000013CE                           596  *-----------------------First 4bit checks go here-----------------------------------
000013CE                           597    
000013CE                           598  *-----------------------Check if the current word starts with 0000--------------------
000013CE  4243                     599  CHECK_NIB1_0000         CLR         D3
000013D0  3639 000020C2            600                          MOVE.W      CURRENT_WORD,D3
000013D6  0243 F000                601                          ANDI.W      #FILT_NIB_1,D3  ; filter out the first 4 bits of the word
000013DA  B67C 0000                602                          CMP         #CONST_ALL_0,D3 ; see if they are all 0
000013DE  6700 001A                603                          BEQ         CONFIRM_NIB1_0000
000013E2  4E75                     604                          RTS 
000013E4                           605                          
000013E4  4243                     606  CHECK_NIB1_0100         CLR         D3 
000013E6  3639 000020C2            607                          MOVE.W      CURRENT_WORD,D3
000013EC  0243 F000                608                          ANDI.W      #FILT_NIB_1,D3      ; filter out the first 4 bits of the word
000013F0  B67C 4000                609                          CMP         #CONST_NIB1_0100,D3 ; see if they are 0100
000013F4  6700 005A                610                          BEQ         CONFIRM_NIB1_0100
000013F8  4E75                     611                          RTS                        
000013FA                           612                          
000013FA                           613  *-----------------------First 4bit confirms go here--------------------------------------
000013FA                           614  
000013FA                           615  *-----------------------Cases where the current word starts with 0000--------------------                       
000013FA  4243                     616  CONFIRM_NIB1_0000       CLR         D3
000013FC  3639 000020C2            617                          MOVE.W      CURRENT_WORD,D3
00001402  0243 0100                618                          ANDI.W      #FILT_BIT_8,D3  ; turn word into 0000 000X 0000 0000
00001406  E04B                     619                          LSR.W       #8,D3           ; turn word into 0000 0000 0000 000X
00001408  B67C 0000                620                          CMP         #CONST_ALL_0,D3 ; see if the word is still 0.
0000140C  6700 0004                621                          BEQ         CONFIRM_0000_XXX0
00001410                           622                          ; if we get to here, then the word must be BCHG, BCLR, BSET, or MOVEP.
00001410                           623                          ; BCHG is required
00001410                           624                          ; if our disassembler doesn't consider any of those valid, there should be an error message here.
00001410  4E75                     625                          RTS 
00001412                           626                          
00001412                           627  ; at this point, the word is of the form 0000 XXX0...
00001412  4243                     628  CONFIRM_0000_XXX0       CLR         D3
00001414  3639 000020C2            629                          MOVE.W      CURRENT_WORD,D3
0000141A  0243 0E00                630                          ANDI.W      #FILT_DEST_REG,D3  ; turn word into 0000 XXX0 0000 0000          
0000141E                           631                          
0000141E                           632                          ; now figure out which operation we have: (note that constants have been ruled out by this point)
0000141E                           633                          
0000141E  B67C 0000                634                          CMP         #CONST_ORI_DEST_REG,D3  ; ORI 
00001422  6700 0542                635                          BEQ         ORI_FOUND           
00001426                           636                          
00001426  B67C 0200                637                          CMP         #CONST_ANDI_DEST_REG,D3 ; ANDI 
0000142A  6700 053E                638                          BEQ         ANDI_FOUND
0000142E                           639                          
0000142E  B67C 0400                640                          CMP         #CONST_SUBI_DEST_REG,D3 ; SUBI
00001432  6700 053A                641                          BEQ         SUBI_FOUND
00001436                           642                          ;
00001436  B67C 0600                643                          CMP         #CONST_ADDI_DEST_REG,D3 ; ADDI
0000143A  6700 0536                644                          BEQ         ADDI_FOUND
0000143E                           645                          
0000143E  B67C 0A00                646                          CMP         #CONST_EORI_DEST_REG,D3 ; EORI
00001442  6700 0532                647                          BEQ         EORI_FOUND
00001446                           648                          
00001446  B67C 0C00                649                          CMP         #CONST_CMPI_DEST_REG,D3 ; CMPI
0000144A  6700 052E                650                          BEQ         CMPI_FOUND
0000144E                           651                          
0000144E                           652                          ;TODO: remaining: BTST, BCHG, BCLR, or BSET. 
0000144E                           653                          ;      if none of them, an error case should occur here.
0000144E                           654                          ;     (note that BCHG is required, though we don't know which version.)
0000144E                           655                          
0000144E  4E75                     656                          RTS     ;change RTS to whatever branch instruction is appropriate here.
00001450                           657                          
00001450                           658  *-----------------------Cases where the current word starts with 0100-----------------
00001450                           659  
00001450                           660      ; if we were doing every OPcode, would start by checking for MOVE from SR, MOVE to CCR, and MOVE to SR at the top of this SR.
00001450                           661      ; instead, we start with NEGX.
00001450  4243                     662  CONFIRM_NIB1_0100       CLR         D3              
00001452  3639 000020C2            663                          MOVE.W      CURRENT_WORD,D3
00001458  0243 0800                664                          ANDI.W      #FILT_BIT_5,D3  ; turn word into 0000 X000 0000 0000
0000145C  E04B                     665                          LSR.W       #8,D3           ; turn word into 0000 0000 0000 000X
0000145E  E64B                     666                          LSR.W       #3,D3
00001460  B67C 0000                667                          CMP         #CONST_ALL_0,D3 ; see if the word is still 0.
00001464  6700 0006                668                          BEQ         CONFIRM_0100_0XXX   ; branch based on the 5th bit.
00001468  6000 0032                669                          BRA         CONFIRM_0100_1XXX
0000146C                           670                          
0000146C  4243                     671  CONFIRM_0100_0XXX       CLR         D3              
0000146E  3639 000020C2            672                          MOVE.W      CURRENT_WORD,D3
00001474  0243 0F00                673                          ANDI.W      #FILT_NIB_2,D3  ; turn word into 0000 XXXX 0000 0000
00001478                           674                          
00001478                           675                          ; now figure out which operation we have:
00001478                           676                          
00001478  B67C 0000                677                          CMP         #CONST_NEGX_OP,D3
0000147C  6700 0500                678                          BEQ         NEGX_FOUND
00001480                           679                          
00001480  B67C 0200                680                          CMP         #CONST_CLR_OP,D3
00001484  6700 04FC                681                          BEQ         CLR_FOUND
00001488                           682                          
00001488  B67C 0400                683                          CMP         #CONST_NEG_OP,D3
0000148C  6700 04F8                684                          BEQ         NEG_FOUND
00001490                           685                          
00001490  B67C 0600                686                          CMP         #CONST_NOT_OP,D3
00001494  6700 04F4                687                          BEQ         NOT_FOUND         ; note that we could likely make a conflicting SR name with one.
00001498                           688                          
00001498                           689                          ; TODO: we definitely have an error at this point.
00001498                           690                          
00001498  4EF8 1004                691                          JMP         STOP     ;change STOP to whatever we want based on error. (probably some error case which will then branch to reading next OPcode.)
0000149C                           692                          
0000149C  4243                     693  CONFIRM_0100_1XXX       CLR         D3
0000149E  3639 000020C2            694                          MOVE.W      CURRENT_WORD,D3
000014A4  0243 0F00                695                          ANDI.W      #FILT_NIB_2,D3  ; turn word into 0000 XXXX 0000 0000
000014A8                           696                          
000014A8  B67C 0800                697                          CMP         #CONST_NIB2_1000,D3
000014AC  6700 0016                698                          BEQ         CONFIRM_0100_1000
000014B0                           699  
000014B0  B67C 0A00                700                          CMP         #CONST_NIB2_1010,D3
000014B4  6700 0012                701                          BEQ         CONFIRM_0100_1010 
000014B8                           702  
000014B8  B67C 0E00                703                          CMP         #CONST_NIB2_1110,D3
000014BC  6700 000E                704                          BEQ         CONFIRM_0100_1110 
000014C0                           705                          ; TODO: make MOVEM a special case since it has an unusual OPcode.
000014C0                           706                          ; TODO: remaining possibilities are MOVEM, LEA, or CHK. (the first two are required.)
000014C0                           707  
000014C0  4EF8 1004                708                          JMP         STOP                      
000014C4                           709                     
000014C4  4EF8 1004                710  CONFIRM_0100_1000       JMP         STOP                       
000014C8                           711  ; TODO: check for EXT, NBCD, SWAP, or PEA.               
000014C8                           712   
000014C8  4EF8 1004                713  CONFIRM_0100_1010       JMP         STOP  
000014CC                           714  ; TODO: check for TAS or TST. (ILLEGAL is already ruled out.)         
000014CC                           715         
000014CC  4EF8 1004                716  CONFIRM_0100_1110       JMP         STOP       
000014D0                           717  ; TODO: check for TRAP, LINK, UNLK, MOVE USP, JSR, or JMP. (some of these are required.)
000014D0                           718  
000014D0                           719  *-----------------------Cases where the current word starts with 0101-----------------
000014D0                           720      ;TODO: ADDQ, SUBQ, Scc, DBcc (some of these are required)
000014D0                           721   
000014D0                           722  *-----------------------Cases where the current word starts with 0110-----------------
000014D0                           723      ;TODO: BRA, BSR, Bcc (some of these are required)   
000014D0                           724      
000014D0                           725  *-----------------------Cases where the current word starts with 1000-----------------
000014D0                           726      ;TODO: DIVU, DIVS, SBCD, OR (some of these are required)   
000014D0                           727      
000014D0                           728  *-----------------------Cases where the current word starts with 1001-----------------
000014D0                           729      ;TODO: SUB, SUBX, SUBA (some of these are required) 
000014D0                           730   
000014D0                           731  *-----------------------Cases where the current word starts with 1011-----------------
000014D0                           732      ;TODO: EOR, CMPM, CMP, CMPA (some of these are required)  
000014D0                           733      
000014D0                           734  *-----------------------Cases where the current word starts with 1100-----------------
000014D0                           735      ;TODO: MULU, MULS, ABCD, EXG, AND (some of these are required) 
000014D0                           736      
000014D0                           737  *-----------------------Cases where the current word starts with 1101-----------------
000014D0                           738      ;TODO: ADD, ADDX, ADDA (some of these are required) 
000014D0                           739      
000014D0                           740  *-----------------------Cases where the current word starts with 1110-----------------
000014D0                           741      ;TODO: ASR, ASL, LSR, LSL, ROXR, ROXL, ROR, ROL (these are all repeated twice on the sheet for some reason) 
000014D0                           742                                                      ;(some of these are required) 
000014D0                           743   
000014D0                           744  *-----------------------Special OPcode (but not constants) have checks here------------
000014D0                           745  * includes MOVE, MOVEQ, etc
000014D0                           746                                  
000014D0                           747  *-----------------------Check current word for MOVE------------------------------------
000014D0                           748  *MOVE can be B,W, or L.
000014D0  4243                     749  CHECK_MOVE              CLR         D3
000014D2  3639 000020C2            750                          MOVE.W      CURRENT_WORD,D3
000014D8  0243 F000                751                          ANDI.W      #FILT_NIB_1,D3
000014DC  B67C 1000                752                          CMP         #CONST_MOVE_B,D3
000014E0  6700 0056                753                          BEQ         MOVE_B_FOUND
000014E4  B67C 3000                754                          CMP         #CONST_MOVE_W,D3
000014E8  6700 007E                755                          BEQ         MOVE_W_FOUND
000014EC  B67C 2000                756                          CMP         #CONST_MOVE_L,D3
000014F0  6700 00A6                757                          BEQ         MOVE_L_FOUND
000014F4  4E75                     758                          RTS 
000014F6                           759                          
000014F6                           760  *-----------------------Check current word for MOVEQ------------------------------------
000014F6                           761  *MOVEQ can only be L.                       
000014F6  4243                     762  CHECK_MOVEQ             CLR         D3
000014F8  3639 000020C2            763                          MOVE.W      CURRENT_WORD,D3
000014FE  0243 F000                764                          ANDI.W      #FILT_NIB_1,D3
00001502  B67C 7000                765                          CMP         #CONST_MOVEQ,D3
00001506  6700 00FC                766                          BEQ         MOVEQ_FOUND
0000150A  4E75                     767                          RTS 
0000150C                           768                          
0000150C                           769  
0000150C                           770  *-----------------------Check current word for EXT------------------------------------  
0000150C                           771  *check EXT before MOVEM, since they can be easily confused.
0000150C                           772  *EXT can be W or L.                  
0000150C  4243                     773  CHECK_EXT               CLR         D3                  
0000150E  3639 000020C2            774                          MOVE.W      CURRENT_WORD,D3
00001514  0243 FFB8                775                          ANDI.W      #FILT_EXT,D3
00001518  B67C 4880                776                          CMP         #CONST_EXT,D3
0000151C  6700 0174                777                          BEQ         EXT_FOUND
00001520  4E75                     778                          RTS 
00001522                           779                          
00001522                           780  *-----------------------Check current word for MOVEM------------------------------------  
00001522                           781  *MOVEM can be W or L.                  
00001522  4243                     782  CHECK_MOVEM             CLR         D3                         
00001524  3639 000020C2            783                          MOVE.W      CURRENT_WORD,D3
0000152A  0243 FB80                784                          ANDI.W      #FILT_MOVEM,D3
0000152E  B67C 4880                785                          CMP         #CONST_MOVEM,D3
00001532  6700 0162                786                          BEQ         MOVEM_FOUND
00001536  4E75                     787                          RTS 
00001538                           788                          
00001538                           789  *---------------------- END OPWORD CHECKS -----------------------------------------
00001538                           790  
00001538                           791  *---------------------- BEGIN CASES FOR FOUND OPCODES------------------------------
00001538                           792  
00001538                           793  *-----------------------MOVE-related Subroutines------------------------------------
00001538                           794  
00001538                           795  *-----------------------Cases for finding different MOVE OPcodes------------------------------------
00001538                           796  *MOVE.B
00001538  13FC 0000 000020C4       797  MOVE_B_FOUND            MOVE.B      #BYTE_SIZE,CURRENT_OP_SIZE
00001540  6100 FDE2                798                          BSR         DISPLAY_CURRENT_ADDRESS
00001544  6100 0082                799                          BSR         PARSE_MOVE_DATA                           
00001548                           800                         
00001548  43F9 0000206F            801                          LEA         MOVE_B_MSG,A1      ; 'MOVE.B'
0000154E  103C 000E                802                          MOVE.B      #14,D0
00001552  4E4F                     803                          TRAP        #15
00001554                           804                          
00001554  43F9 00001E67            805                          LEA         SPACE,A1           ; ' '
0000155A  103C 000E                806                          MOVE.B      #14,D0      
0000155E  4E4F                     807                          TRAP        #15
00001560                           808                          
00001560  6100 0080                809                          BSR         DISPLAY_MOVE_DATA
00001564  6000 FD8C                810                          BRA         GO_TO_NEXT_OP
00001568                           811  
00001568                           812  *MOVE.W                        
00001568  13FC 0001 000020C4       813  MOVE_W_FOUND            MOVE.B      #WORD_SIZE,CURRENT_OP_SIZE
00001570  6100 FDB2                814                          BSR         DISPLAY_CURRENT_ADDRESS
00001574  6100 0052                815                          BSR         PARSE_MOVE_DATA       
00001578                           816                          
00001578  43F9 00002076            817                          LEA         MOVE_W_MSG,A1      ; 'MOVE.W'
0000157E  103C 000E                818                          MOVE.B      #14,D0
00001582  4E4F                     819                          TRAP        #15
00001584                           820                          
00001584  43F9 00001E67            821                          LEA         SPACE,A1           ; ' '
0000158A  103C 000E                822                          MOVE.B      #14,D0      
0000158E  4E4F                     823                          TRAP        #15
00001590                           824                          
00001590  6100 0050                825                          BSR         DISPLAY_MOVE_DATA
00001594  6000 FD5C                826                          BRA         GO_TO_NEXT_OP  
00001598                           827  
00001598                           828  *MOVE.L                        
00001598  13FC 0002 000020C4       829  MOVE_L_FOUND            MOVE.B      #LONG_SIZE,CURRENT_OP_SIZE
000015A0  6100 FD82                830                          BSR         DISPLAY_CURRENT_ADDRESS
000015A4  6100 0022                831                          BSR         PARSE_MOVE_DATA       
000015A8                           832                          
000015A8  43F9 0000207D            833                          LEA         MOVE_L_MSG,A1      ; 'MOVE.L'
000015AE  103C 000E                834                          MOVE.B      #14,D0
000015B2  4E4F                     835                          TRAP        #15
000015B4                           836                          
000015B4  43F9 00001E67            837                          LEA         SPACE,A1           ; ' '
000015BA  103C 000E                838                          MOVE.B      #14,D0      
000015BE  4E4F                     839                          TRAP        #15
000015C0                           840                          
000015C0  6100 0020                841                          BSR         DISPLAY_MOVE_DATA
000015C4  6000 FD2C                842                          BRA         GO_TO_NEXT_OP 
000015C8                           843                         
000015C8                           844  *-----------------------Parse data for any-sized MOVE instruction---------------------
000015C8                           845  *Note that the size of the MOVE is stored in CURRENT_OP_SIZE.
000015C8                           846  PARSE_MOVE_DATA         ; TODO: error checking 
000015C8                           847                          ;(maybe after reading the first 4 instruction parts, but before reading additional data)
000015C8                           848                          ;IMPORTANT: remember that different MOVE error are specific to different MOVE sizes.
000015C8                           849                          ; example: MOVE.B  A0,D3 is invalid. However, MOVE.W  A0,D3 is valid.
000015C8                           850                          ;
000015C8                           851                          ; possible errors:
000015C8                           852                          ;       CURRENT_DEST_MD = CONST_IMMEDIATE_REG (immediate data cannot be a destination)
000015C8                           853                          ;       CURRENT_SRC_MD  = CONST_ADDR_REG_MD   (byte is not a valid size for this move)
000015C8                           854                          ;       CURRENT_DEST_MD = CONST_ADDR_REG_MD   (byte is not a valid size, although we should be using MOVEA at this point, not MOVE.)
000015C8                           855                          ;       TODO: figure out other possible errors.
000015C8                           856                          
000015C8                           857                          ; after we confirm that there are no errors, we know that we can safely check for additional data and display the instruction.
000015C8                           858                          
000015C8                           859                          
000015C8                           860                          ; at this point, need to read more information (parsed by EA, probably)
000015C8                           861                          ; now that we have a move instruction, we set our EA variables accordingly:
000015C8  6100 03C4                862                          BSR         READ_DEST_REG      ; EA will set CURRENT_DEST_REG.
000015CC  6100 03DE                863                          BSR         READ_DEST_MODE     ; EA will set CURRENT_DEST_MD.
000015D0  6100 03F6                864                          BSR         READ_SOURCE_MODE   ; EA will set CURRENT_SRC_MD.
000015D4  6100 040E                865                          BSR         READ_SOURCE_REG    ; EA will set CURRENT_SRC_REG.
000015D8                           866                          
000015D8                           867                          ; need to check whether we need to read additional data before we start displaying the
000015D8                           868                          ; instruction (for instance, this is necessary for MOVE.B #10,D0).
000015D8  6100 0424                869                          BSR         READ_SOURCE_DATA   ; EA will set CURRENT_SOURCE_DATA if necessary.
000015DC  6100 045A                870                          BSR         READ_DEST_DATA     ; EA will set CURRENT_DEST_DATA if necessary. 
000015E0  4E75                     871                          RTS         
000015E2                           872  
000015E2  6100 0596                873  DISPLAY_MOVE_DATA       BSR         DISPLAY_SOURCE     ; Tell EA to parse and display the source. EX: (A1)   D3    #10   $1000 etc
000015E6                           874                          
000015E6  43F9 00001E6B            875                          LEA         COMMA,A1           ; ','
000015EC  103C 000E                876                          MOVE.B      #14,D0      
000015F0  4E4F                     877                          TRAP        #15
000015F2                           878                          
000015F2  6100 05BC                879                          BSR         DISPLAY_DEST       ; Tell EA to parse and display the destination.
000015F6                           880                          
000015F6  43F9 00001E64            881                          LEA         RETURN,A1          ; (return)
000015FC  103C 000E                882                          MOVE.B      #14,D0
00001600  4E4F                     883                          TRAP        #15
00001602                           884  
00001602  4E75                     885                          RTS  
00001604                           886  
00001604                           887  *-----------------------MOVEQ-related Subroutines------------------------------------
00001604                           888  
00001604                           889  *-----------------------Case for finding MOVEQ------------------------------------
00001604  13FC 0002 000020C4       890  MOVEQ_FOUND             MOVE.B      #LONG_SIZE,CURRENT_OP_SIZE
0000160C  6100 FD16                891                          BSR         DISPLAY_CURRENT_ADDRESS
00001610  6100 0022                892                          BSR         PARSE_MOVEQ_DATA       
00001614                           893                          
00001614  43F9 00002084            894                          LEA         MOVEQ_MSG,A1      ; 'MOVEQ'
0000161A  103C 000E                895                          MOVE.B      #14,D0
0000161E  4E4F                     896                          TRAP        #15
00001620                           897                          
00001620  43F9 00001E67            898                          LEA         SPACE,A1           ; ' '
00001626  103C 000E                899                          MOVE.B      #14,D0      
0000162A  4E4F                     900                          TRAP        #15
0000162C                           901                          
0000162C  6100 0028                902                          BSR         DISPLAY_MOVEQ_DATA
00001630  6000 FCC0                903                          BRA         GO_TO_NEXT_OP  
00001634                           904  
00001634                           905  PARSE_MOVEQ_DATA        ;TODO: check that 0000 000X 0000 0000 equals zero. If not, error.
00001634                           906                          
00001634  6100 0358                907                          BSR         READ_DEST_REG                       ; EA will set CURRENT_DEST_REG.
00001638  13FC 0000 000020D9       908                          MOVE.B      #CONST_DATA_REG_MD,CURRENT_DEST_MD  ; data register is the only allowed destination for MOVEQ.
00001640  6100 0036                909                          BSR         READ_MOVEQ_DATA                     ; 0000 0000 XXXX XXXX will set CURRENT_SOURCE_DATA (I think.)
00001644                           910                          
00001644  13FC 0007 000020D7       911                          MOVE.B      #CONST_ADDR_MISC_MD,CURRENT_SRC_MD
0000164C  13FC 0004 000020D8       912                          MOVE.B      #CONST_IMMEDIATE_REG,CURRENT_SRC_REG
00001654                           913                          
00001654  4E75                     914                          RTS 
00001656                           915  
00001656  6100 0522                916  DISPLAY_MOVEQ_DATA      BSR         DISPLAY_SOURCE     ; Tell EA to parse and display the source. 
0000165A                           917                          
0000165A  43F9 00001E6B            918                          LEA         COMMA,A1           ; ','
00001660  103C 000E                919                          MOVE.B      #14,D0      
00001664  4E4F                     920                          TRAP        #15
00001666                           921                          
00001666  6100 0548                922                          BSR         DISPLAY_DEST       ; Tell EA to parse and display the destination.
0000166A                           923                          
0000166A  43F9 00001E64            924                          LEA         RETURN,A1          ; (return)
00001670  103C 000E                925                          MOVE.B      #14,D0
00001674  4E4F                     926                          TRAP        #15
00001676                           927  
00001676  4E75                     928                          RTS        
00001678                           929  
00001678                           930  ;NOTE: this SR is stored here and not in EA because it is specific to MOVEQ.
00001678  4244                     931  READ_MOVEQ_DATA         CLR         D4
0000167A  4279 000020E0            932                          CLR         CURRENT_SRC_DATA
00001680  3839 000020C2            933                          MOVE.W      CURRENT_WORD,D4
00001686  0244 00FF                934                          ANDI.W      #FILT_MOVEQ_DATA,D4        ; turn D4 into 0000 0000 XXXX XXXX (no shift necessary)
0000168A  33C4 000020E0            935                          MOVE.W      D4,CURRENT_SRC_DATA
00001690  4E75                     936                          RTS
00001692                           937                      
00001692                           938    ; TODO: (in order)
00001692                           939      *   -MOVEM  (W,L)
00001692                           940      *   -ADD    (B,W,L) (will need shahin's size filter for this and below)
00001692                           941      *   -ADDA   (W,L)
00001692                           942      *   -ADDI   (B,W,L)
00001692                           943      *   -SUB    (B,W,L)
00001692                           944    ; see comment block at the top of the program for the full list of codes.
00001692                           945    ; see huge comment block at the top of OPcode section for tentative OPcode parsing implementation plan.
00001692                           946    
00001692                           947  *-----------------------EXT-related Subroutines------------------------------------
00001692  4EF8 1004                948  EXT_FOUND               JMP         STOP ;TODO: case for EXT found
00001696                           949  
00001696                           950  ;TODO: first thing: read the correct size for MOVEM
00001696                           951  *-----------------------MOVEM-related Subroutines------------------------------------
00001696  6100 FC8C                952  MOVEM_FOUND             BSR         DISPLAY_CURRENT_ADDRESS
0000169A  4244                     953                          CLR         D4
0000169C  3839 000020C2            954                          MOVE.W      CURRENT_WORD,D4
000016A2  0244 0040                955                          ANDI.W      #FILT_MOVEM_SIZE,D4 ; 0000 0000 0X00 0000 filter out size and set CURRENT_OP_SIZE accordingly
000016A6  EC4C                     956                          LSR.W       #6,D4               ; 0000 0000 0000 000X
000016A8  B87C 0000                957                          CMP         #WORD_SIZE_MOVEM,D4
000016AC  6700 0006                958                          BEQ         MOVEM_W_FOUND
000016B0  6000 002E                959                          BRA         MOVEM_L_FOUND
000016B4                           960      
000016B4  13FC 0001 000020C4       961  MOVEM_W_FOUND           MOVE.B      #WORD_SIZE,CURRENT_OP_SIZE
000016BC  6100 004E                962                          BSR         PARSE_MOVEM_DATA
000016C0                           963                          ; TODO: parse data before displaying.
000016C0  43F9 0000208A            964                          LEA         MOVEM_W_MSG,A1      ; 'MOVEM.W'
000016C6  103C 000E                965                          MOVE.B      #14,D0
000016CA  4E4F                     966                          TRAP        #15
000016CC                           967                          
000016CC  43F9 00001E67            968                          LEA         SPACE,A1           ; ' '
000016D2  103C 000E                969                          MOVE.B      #14,D0      
000016D6  4E4F                     970                          TRAP        #15  
000016D8                           971                          
000016D8  6100 00C4                972                          BSR         DISPLAY_MOVEM_DATA
000016DC  6000 FC14                973                          BRA         GO_TO_NEXT_OP                               
000016E0                           974  
000016E0  13FC 0002 000020C4       975  MOVEM_L_FOUND           MOVE.B      #LONG_SIZE,CURRENT_OP_SIZE
000016E8  6100 0022                976                          BSR         PARSE_MOVEM_DATA   ; parse movem data for direction, EA, etc
000016EC                           977                          ; TODO: parse all data before displaying.
000016EC  43F9 00002092            978                          LEA         MOVEM_L_MSG,A1      ; 'MOVEM.L'
000016F2  103C 000E                979                          MOVE.B      #14,D0
000016F6  4E4F                     980                          TRAP        #15
000016F8                           981                          
000016F8  43F9 00001E67            982                          LEA         SPACE,A1           ; ' '
000016FE  103C 000E                983                          MOVE.B      #14,D0      
00001702  4E4F                     984                          TRAP        #15 
00001704                           985                          
00001704  6100 0098                986                          BSR         DISPLAY_MOVEM_DATA
00001708  6000 FBE8                987                          BRA         GO_TO_NEXT_OP 
0000170C                           988                          
0000170C  6100 02D6                989  PARSE_MOVEM_DATA        BSR         READ_SOURCE_REG             ; EA will set CURRENT_SRC_REG.
00001710  6100 02B6                990                          BSR         READ_SOURCE_MODE            ; EA will set CURRENT_SRC_MD.
00001714  6100 0026                991                          BSR         READ_MOVEM_DIR              ; read and store the direction of the current operation.
00001718  13F9 000020D8 000020D3   992                          MOVE.B      CURRENT_SRC_REG,CURRENT_EA_REG  ; our current EA reg comes from  0000 0000 0000 0XXX.
00001722  13F9 000020D7 000020D2   993                          MOVE.B      CURRENT_SRC_MD,CURRENT_EA_MD    ; our current EA mode comes from 0000 0000 00XX X000.
0000172C                           994                          
0000172C                           995                          ; TODO: add any other parsing methods that should be true for both directions (and precede error checking) here.
0000172C                           996                          ; TODO: error cases to add here:
0000172C                           997                          ; TODO: error case for CURRENT_EA_MD = CONST_DATA_REG_MD: Dn
0000172C                           998                          ; TODO: error case for CURRENT_EA_MD = CONST_ADDR_REG_MD: An
0000172C                           999                          ; TODO: error case for CURRENT_EA_MD = CONST_ADDR_MISC_MD *and* CURRENT_EA_REG = CONST_IMMEDIATE REG: #<data>
0000172C                          1000                          ; (note that these are not all error cases for MOVEM, but they are the only ones we are able to check in this subroutine.)
0000172C                          1001                          
0000172C  0C39 0000 000020D4      1002                          CMP.B       #CONST_MOVEM_DIR_0,CURRENT_DIRECTION
00001734  6700 001E               1003                          BEQ         PARSE_MOVEM_DIR_0
00001738  6000 0038               1004                          BRA         PARSE_MOVEM_DIR_1
0000173C                          1005                          
0000173C  4244                    1006  READ_MOVEM_DIR          CLR         D4
0000173E  3839 000020C2           1007                          MOVE.W      CURRENT_WORD,D4    
00001744  0244 0400               1008                          ANDI.W      #FILT_MOVEM_DIR,D4 ; 0000 0X00 0000 0000     filter out direction 
00001748  E04C                    1009                          LSR.W       #8,D4              ; 0000 0000 0000 000X
0000174A  E44C                    1010                          LSR.W       #2,D4
0000174C  13C4 000020D4           1011                          MOVE.B      D4,CURRENT_DIRECTION
00001752  4E75                    1012                          RTS
00001754                          1013                          
00001754                          1014  PARSE_MOVEM_DIR_0       ;TODO : error case for  (An+): CURRENT_EA_MD = CONST_ADDR_INCR_MD
00001754  13F9 000020D2 000020CC  1015                          MOVE.B      CURRENT_EA_MD,CURRENT_R_MD      ; put EA on the right.
0000175E  13F9 000020D3 000020CD  1016                          MOVE.B      CURRENT_EA_REG,CURRENT_R_REG
00001768                          1017                          ; by this point, we have done all necessary error checking, and we are ready to read the
00001768                          1018                          ; next word of additional data.
00001768  6100 0026               1019                          BSR         PARSE_MOVEM_MASK_FIELD
0000176C  6100 033E               1020                          BSR         READ_RIGHT_DATA
00001770                          1021                          ; ...
00001770  4E75                    1022                          RTS
00001772                          1023  
00001772                          1024  PARSE_MOVEM_DIR_1       ;TODO : error case for  (-An): CURRENT_EA_MD = CONST_ADDR_DECR_MD
00001772  13F9 000020D2 000020C5  1025                          MOVE.B      CURRENT_EA_MD,CURRENT_L_MD      ; put EA on the left.
0000177C  13F9 000020D3 000020C6  1026                          MOVE.B      CURRENT_EA_REG,CURRENT_L_REG
00001786                          1027                          ; by this point, we have done all necessary error checking, and we are ready to read the
00001786                          1028                          ; next word of additional data.
00001786  6100 0008               1029                          BSR         PARSE_MOVEM_MASK_FIELD
0000178A  6100 02E6               1030                          BSR         READ_LEFT_DATA
0000178E                          1031                          
0000178E                          1032                          ; ...
0000178E  4E75                    1033                          RTS
00001790                          1034                          ; TODO: for all EA modes except predecrement, the next additional data (always read) should be read A7...A0,D7...D0
00001790                          1035                          ;   for predecrement, the order is reversed.
00001790                          1036                          ; TODO: finish parsing data.
00001790                          1037  
00001790                          1038                          
00001790                          1039      *Parse the mask field, which will tell us which address/data registers we are moving to/from.
00001790  4279 000020E8           1040  PARSE_MOVEM_MASK_FIELD  CLR.W       CURRENT_MASK_FIELD
00001796  33DD 000020E8           1041                          MOVE.W      (A5)+,CURRENT_MASK_FIELD
0000179C                          1042                          ;TODO: if CURRENT_EA_MD = CONST_ADDR_DECR_MD, reverse the way we read the next word of additional data.
0000179C  4E75                    1043                          RTS
0000179E                          1044    
0000179E  0C39 0000 000020D4      1045  DISPLAY_MOVEM_DATA      CMP.B       #CONST_MOVEM_DIR_0,CURRENT_DIRECTION
000017A6  6700 0006               1046                          BEQ         DISPLAY_MOVEM_DIR_0
000017AA  6000 0024               1047                          BRA         DISPLAY_MOVEM_DIR_1
000017AE                          1048                          
000017AE  6100 0042               1049  DISPLAY_MOVEM_DIR_0     BSR         DISPLAY_MOVEM_LIST ; display list, then ea.
000017B2                          1050                          
000017B2  43F9 00001E6B           1051                          LEA         COMMA,A1           ; ','
000017B8  103C 000E               1052                          MOVE.B      #14,D0      
000017BC  4E4F                    1053                          TRAP        #15
000017BE                          1054                          
000017BE  6100 045C               1055                          BSR         DISPLAY_RIGHT
000017C2                          1056                          
000017C2  43F9 00001E64           1057                          LEA         RETURN,A1          ; (return)
000017C8  103C 000E               1058                          MOVE.B      #14,D0
000017CC  4E4F                    1059                          TRAP        #15
000017CE                          1060                          
000017CE  4E75                    1061                          RTS
000017D0                          1062  
000017D0  6100 0414               1063  DISPLAY_MOVEM_DIR_1     BSR         DISPLAY_LEFT        ; display ea, then list.
000017D4                          1064                          
000017D4  43F9 00001E6B           1065                          LEA         COMMA,A1            ; ','
000017DA  103C 000E               1066                          MOVE.B      #14,D0      
000017DE  4E4F                    1067                          TRAP        #15
000017E0                          1068                         
000017E0  6100 0010               1069                          BSR         DISPLAY_MOVEM_LIST
000017E4                          1070                          
000017E4  43F9 00001E64           1071                          LEA         RETURN,A1          ; (return)
000017EA  103C 000E               1072                          MOVE.B      #14,D0
000017EE  4E4F                    1073                          TRAP        #15
000017F0                          1074   
000017F0  4E75                    1075                          RTS
000017F2                          1076                          
000017F2  0C39 0004 000020D2      1077  DISPLAY_MOVEM_LIST      CMP.B       #CONST_ADDR_DECR_MD,CURRENT_EA_MD
000017FA  6700 0162               1078                          BEQ         DISPLAY_MOVEM_LIST_REV
000017FE  6000 0002               1079                          BRA         DISPLAY_MOVEM_LIST_FWD
00001802                          1080  
00001802                          1081      ; start from the right, display Ds then As
00001802                          1082      ; MOVEM list is displayed as Ai-Aj/Dx-Dy
00001802  4243                    1083  DISPLAY_MOVEM_LIST_FWD  CLR         D3 ; D3 is a flag which tells us if we find any address registers in the list.
00001804  4244                    1084                          CLR         D4 ; D4 is a temp value for our mask field.
00001806  4245                    1085                          CLR         D5 ; D5 will serve as our index counter.
00001808  6000 003E               1086                          BRA         FIND_MM_F_START_A
0000180C                          1087   
0000180C                          1088       * after finding startA, see if we only had one address register in the list.
0000180C  4246                    1089  CHECK_SINGLE_A_F        CLR         D6                  ; we use D6 as a temporary register (only in this method) to examine the value 1 higher than D5.
0000180E  1C05                    1090                          MOVE.B      D5,D6                
00001810  5206                    1091                          ADD.B       #1,D6
00001812  BC7C 000F               1092                          CMP         #15,D6              ; first, check if D5 is 15 or greater. (meaning D6 is 16 or greater.) If it is, there is no room for an end A.
00001816  6E00 0066               1093                          BGT         FIND_MM_F_START_D   ; This means we move on and look for start D.
0000181A  0D04                    1094                          BTST        D6,D4               ; otherwise, we have to compare the 1-greater value to our mask field.
0000181C  6700 0060               1095                          BEQ         FIND_MM_F_START_D   ; If the next value is 0, there is no end An.
00001820  6000 0048               1096                          BRA         FIND_MM_F_END_A     ; final possibility: there are more address registers and we must find the end An.
00001824                          1097                          
00001824                          1098       * After finding start D, see if we only had one data register in the list.
00001824  4246                    1099  CHECK_SINGLE_D_F        CLR         D6                  ; we use D6 as a temporary register (only in this method) to examine the value 1 higher than D5.
00001826  1C05                    1100                          MOVE.B      D5,D6                
00001828  5206                    1101                          ADD.B       #1,D6
0000182A  BC7C 0007               1102                          CMP         #7,D6                    ; first, check if D5 is 7 or greater. (meaning D6 is 8 or greater.) If it is, there is no room for an end D.
0000182E  6E00 0134               1103                          BGT         MOVEM_LIST_DISPLAY_DONE  ; This means we are done displaying the list.
00001832  0D04                    1104                          BTST        D6,D4                    ; otherwise, we have to compare the 1-greater value to our mask field.
00001834  6700 012E               1105                          BEQ         MOVEM_LIST_DISPLAY_DONE  ; If the next value is 0, there is no end An.
00001838  6000 0066               1106                          BRA         FIND_MM_F_END_D          ; final possibility: there are more data registers and we must find the end Dn.
0000183C                          1107                          
0000183C                          1108       * after finding startD, check to see if we should print a '/' before displaying it.
0000183C  B67C 0001               1109  CHECK_ADDR_IN_LIST_FLAG CMP         #1,D3
00001840  6700 00C6               1110                          BEQ         DISPLAY_SLASH
00001844  6000 00D2               1111                          BRA         DISP_MM_F_START_D
00001848                          1112                          
00001848                          1113       *find the starting address register in the list .                       
00001848  4245                    1114  FIND_MM_F_START_A       CLR         D5
0000184A  1A3C 0008               1115                          MOVE.B      #8,D5   ;start looking for start A at the 8th bit.           
0000184E  3839 000020E8           1116                          MOVE.W      CURRENT_MASK_FIELD,D4  
00001854  6000 0002               1117                          BRA         FIND_MM_F_START_A_LOOP 
00001858                          1118  
00001858  0B04                    1119  FIND_MM_F_START_A_LOOP  BTST.L      D5,D4
0000185A  6600 005A               1120                          BNE         DISP_MM_F_START_A  
0000185E  5205                    1121                          ADD.B       #1,D5
00001860  BA7C 0010               1122                          CMP         #16,D5   
00001864  6DF2                    1123                          BLT         FIND_MM_F_START_A_LOOP
00001866  6000 0016               1124                          BRA         FIND_MM_F_START_D        ; stop searching for start A once we reach 16.  
0000186A                          1125  
0000186A                          1126       *find the ending address register in the list. (start is found.)
0000186A  6000 0002               1127  FIND_MM_F_END_A         BRA         FIND_MM_F_END_A_LOOP
0000186E                          1128                          
0000186E                          1129       * if we get to this loop, we know for sure that we will need to display an end An at some point, and also that we have a start An.
0000186E  0B04                    1130  FIND_MM_F_END_A_LOOP    BTST.L      D5,D4
00001870  6700 0066               1131                          BEQ         DISP_MM_F_END_A          ; BEQ instead of BNE, since we are looking for the next 0 to tell us our end An. 
00001874  5205                    1132                          ADD.B       #1,D5                    ; (it will be 9 below the index where we find the 0.)
00001876  BA7C 0010               1133                          CMP         #16,D5   
0000187A  6DF2                    1134                          BLT         FIND_MM_F_END_A_LOOP
0000187C  60EC                    1135                          BRA         FIND_MM_F_END_A          ; stop searching for end A once we reach 15.  
0000187E                          1136                       
0000187E                          1137       *find the starting data register in the list.                        
0000187E  4244                    1138  FIND_MM_F_START_D       CLR         D4                       ; do not clear D3, since it is a flag we will use if we find any Dn.     
00001880  4245                    1139                          CLR         D5 
00001882  1A3C 0000               1140                          MOVE.B      #0,D5                    ; start looking for start D at index 0.
00001886  3839 000020E8           1141                          MOVE.W      CURRENT_MASK_FIELD,D4
0000188C  6000 0002               1142                          BRA         FIND_MM_F_START_D_LOOP
00001890                          1143                          
00001890  0B04                    1144  FIND_MM_F_START_D_LOOP  BTST.L      D5,D4
00001892  66A8                    1145                          BNE         CHECK_ADDR_IN_LIST_FLAG  ; if we find the start D, check to see whether we need a '/', then display the start D. 
00001894  5205                    1146                          ADD.B       #1,D5
00001896  BA7C 0008               1147                          CMP         #8,D5   
0000189A  6DF4                    1148                          BLT         FIND_MM_F_START_D_LOOP
0000189C  6000 00C6               1149                          BRA         MOVEM_LIST_DISPLAY_DONE  ; stop searching for start D once we reach 8. 
000018A0                          1150                          
000018A0                          1151       *find the ending data register in the list. (start is found.)
000018A0  6000 0002               1152  FIND_MM_F_END_D         BRA         FIND_MM_F_END_D_LOOP
000018A4                          1153  
000018A4                          1154       * if we get to this loop, we know for sure that we will need to display an end Dn at some point, and also that we have a start Dn.
000018A4  0B04                    1155  FIND_MM_F_END_D_LOOP    BTST.L      D5,D4
000018A6  6700 008C               1156                          BEQ         DISP_MM_F_END_D          ; BEQ instead of BNE, since we are looking for the next 0 to tell us our end Dn. 
000018AA  5205                    1157                          ADD.B       #1,D5                    ; (it will be 1 below the index where we find the 0.)
000018AC  BA7C 0008               1158                          CMP         #8,D5   
000018B0  6DF2                    1159                          BLT         FIND_MM_F_END_D_LOOP
000018B2  6000 0080               1160                          BRA         DISP_MM_F_END_D          ; stop searching for end D once we reach 8. 
000018B6                          1161                          
000018B6                          1162       *display the starting address register in the list.
000018B6  43F9 0000209C           1163  DISP_MM_F_START_A       LEA         MSG_A,A1          ; 'A'
000018BC  103C 000E               1164                          MOVE.B      #14,D0      
000018C0  4E4F                    1165                          TRAP        #15
000018C2                          1166                          
000018C2  2205                    1167                          MOVE.L      D5,D1             ; print out the number of the starting address register in the list
000018C4  5141                    1168                          SUBQ        #8,D1             ; note that we have to subtract 8 because the index is 8 higher than the address register value.
000018C6  143C 0010               1169                          MOVE.B      #16,D2
000018CA  103C 000F               1170                          MOVE.B      #15,D0
000018CE  4E4F                    1171                          TRAP        #15
000018D0                          1172                          
000018D0  163C 0001               1173                          MOVE.B      #1,D3             ; D3 is flagged as 1, telling us we will need a / if we find any data registers.
000018D4                          1174                          
000018D4  6000 FF36               1175                          BRA         CHECK_SINGLE_A_F  ; see if we only had one A.
000018D8                          1176  
000018D8                          1177       *display the ending address register in the list.                        
000018D8  43F9 00001E75           1178  DISP_MM_F_END_A         LEA         MINUS,A1        ; '-'
000018DE  103C 000E               1179                          MOVE.B      #14,D0      
000018E2  4E4F                    1180                          TRAP        #15
000018E4                          1181  
000018E4  43F9 0000209C           1182                          LEA         MSG_A,A1        ; 'A'
000018EA  103C 000E               1183                          MOVE.B      #14,D0      
000018EE  4E4F                    1184                          TRAP        #15
000018F0                          1185                          
000018F0  2205                    1186                          MOVE.L      D5,D1           ; print out the number of the ending address register in the list
000018F2  5141                    1187                          SUBQ        #8,D1           ; since we are looking for the 'last 1', we subtract 9, since we found a 0 at the index in question.
000018F4  5341                    1188                          SUBQ        #1,D1
000018F6  143C 0010               1189                          MOVE.B      #16,D2
000018FA  103C 000F               1190                          MOVE.B      #15,D0
000018FE  4E4F                    1191                          TRAP        #15
00001900                          1192                          
00001900                          1193                          ;No need to change D5, since it will be reset at the start of the next loop anyway.
00001900  163C 0001               1194                          MOVE.B      #1,D3           ; D3 is flagged as 1, telling us we will need a / if we find any data registers.
00001904                          1195  
00001904  6000 FF78               1196                          BRA         FIND_MM_F_START_D
00001908                          1197                          
00001908                          1198     * display a '/'. (not always necessecary.)
00001908  43F9 00001E77           1199  DISPLAY_SLASH           LEA         SLASH,A1          ; '/'
0000190E  103C 000E               1200                          MOVE.B      #14,D0      
00001912  4E4F                    1201                          TRAP        #15
00001914                          1202  
00001914  6000 0002               1203                          BRA         DISP_MM_F_START_D  
00001918                          1204                          
00001918                          1205     * display the starting data register in the list.
00001918  43F9 0000209A           1206  DISP_MM_F_START_D       LEA         MSG_D,A1          ; 'D'
0000191E  103C 000E               1207                          MOVE.B      #14,D0      
00001922  4E4F                    1208                          TRAP        #15
00001924                          1209                          
00001924  2205                    1210                          MOVE.L      D5,D1             ; print out the number of the starting data register in the list
00001926  143C 0010               1211                          MOVE.B      #16,D2
0000192A  103C 000F               1212                          MOVE.B      #15,D0
0000192E  4E4F                    1213                          TRAP        #15
00001930                          1214                          
00001930  6000 FEF2               1215                          BRA         CHECK_SINGLE_D_F  ; see if we only had one Dn.
00001934                          1216                          
00001934                          1217     * display the ending data register in the list.
00001934  43F9 00001E75           1218  DISP_MM_F_END_D         LEA         MINUS,A1        ; '-'
0000193A  103C 000E               1219                          MOVE.B      #14,D0      
0000193E  4E4F                    1220                          TRAP        #15
00001940                          1221  
00001940  43F9 0000209A           1222                          LEA         MSG_D,A1          ; 'D'
00001946  103C 000E               1223                          MOVE.B      #14,D0      
0000194A  4E4F                    1224                          TRAP        #15
0000194C                          1225                          
0000194C  2205                    1226                          MOVE.L      D5,D1             ; print out the number of the ending data register in the list
0000194E  5341                    1227                          SUBQ        #1,D1             ; since we are looking for the 'last 1', we subtract 1, since we found a 0 at the index in question.
00001950                          1228  
00001950  143C 0010               1229                          MOVE.B      #16,D2
00001954  103C 000F               1230                          MOVE.B      #15,D0
00001958  4E4F                    1231                          TRAP        #15
0000195A                          1232                          
0000195A  6000 0008               1233                          BRA         MOVEM_LIST_DISPLAY_DONE
0000195E                          1234  
0000195E                          1235  
0000195E                          1236      ; TODO: get forward loop working and tested before starting reverse loop.
0000195E                          1237      ; start from the left, display Ds then As
0000195E  4244                    1238  DISPLAY_MOVEM_LIST_REV  CLR         D4 ; D4 is a temp value for our mask field. 
00001960  4245                    1239                          CLR         D5 ; D5 will serve as our index counter.
00001962                          1240                          ;TODO
00001962  4E75                    1241                          RTS 
00001964                          1242                          
00001964  4E75                    1243  MOVEM_LIST_DISPLAY_DONE RTS ;not sure if this is right, but can't test it at the moment.
00001966                          1244   
00001966                          1245  *-----------------------ORI-related Subroutines------------------------------------
00001966  4EF8 1004               1246  ORI_FOUND               JMP         STOP ;TODO: case for ORI found
0000196A                          1247  
0000196A                          1248   *----------------------ANDI-related Subroutines------------------------------------
0000196A  4EF8 1004               1249  ANDI_FOUND              JMP         STOP ;TODO: case for ANDI found
0000196E                          1250  
0000196E                          1251   *----------------------SUBI-related Subroutines------------------------------------
0000196E  4EF8 1004               1252  SUBI_FOUND              JMP         STOP ;TODO: case for SUBI found
00001972                          1253  
00001972                          1254   *----------------------ADDI-related Subroutines------------------------------------
00001972  4EF8 1004               1255  ADDI_FOUND              JMP         STOP ;TODO: case for ADDI found
00001976                          1256   
00001976                          1257  *-----------------------EORI-related Subroutines------------------------------------
00001976  4EF8 1004               1258  EORI_FOUND              JMP         STOP ;TODO: case for EORI found
0000197A                          1259   
0000197A                          1260  *-----------------------CMPI-related Subroutines------------------------------------
0000197A  4EF8 1004               1261  CMPI_FOUND              JMP         STOP ;TODO: case for CMPI found
0000197E                          1262  
0000197E                          1263  *-----------------------NEGX-related Subroutines------------------------------------
0000197E  4EF8 1004               1264  NEGX_FOUND              JMP         STOP ;TODO: case for NEGX found 
00001982                          1265  
00001982                          1266  *-----------------------CLR-related Subroutines------------------------------------
00001982  4EF8 1004               1267  CLR_FOUND               JMP         STOP ;TODO: case for CLR found 
00001986                          1268  
00001986                          1269  *-----------------------NEG-related Subroutines------------------------------------
00001986  4EF8 1004               1270  NEG_FOUND               JMP         STOP ;TODO: case for NEG found 
0000198A                          1271  
0000198A                          1272  *-----------------------NOT-related Subroutines------------------------------------
0000198A  4EF8 1004               1273  NOT_FOUND               JMP         STOP ;TODO: case for NOT found 
0000198E                          1274                      
0000198E                          1275  *###################### END OPCODE ##################################
0000198E                          1276  *###################### BEGIN EA ##################################
0000198E                          1277  *** EA Subroutines are kept here ***
0000198E                          1278  *----------------------Check the destination register of the current word.-------------
0000198E  4244                    1279  READ_DEST_REG           CLR         D4
00001990  4239 000020DA           1280                          CLR.B       CURRENT_DEST_REG
00001996  3839 000020C2           1281                          MOVE.W      CURRENT_WORD,D4
0000199C  0244 0E00               1282                          ANDI.W      #FILT_DEST_REG,D4       ; turn D4 into 0000 XXX0 0000 0000
000019A0  E04C                    1283                          LSR.W       #8,D4                   ; turn D4 into 0000 0000 0000 0XXX
000019A2  E24C                    1284                          LSR.W       #1,D4                   ; 9 would be invalid, so we shift 8, then 1
000019A4  13C4 000020DA           1285                          MOVE.B      D4,CURRENT_DEST_REG
000019AA  4E75                    1286                          RTS
000019AC                          1287  
000019AC                          1288  *----------------------Check the destination mode of the current word.-------------
000019AC                          1289  *(assuming the destination is where it would be in MOVE).
000019AC  4244                    1290  READ_DEST_MODE          CLR         D4
000019AE  4239 000020D9           1291                          CLR.B       CURRENT_DEST_MD
000019B4  3839 000020C2           1292                          MOVE.W      CURRENT_WORD,D4
000019BA  0244 01C0               1293                          ANDI.W      #FILT_DEST_MD,D4        ; turn D4 into 0000 000X XX00 0000
000019BE  EC4C                    1294                          LSR.W       #6,D4                   ; turn D4 into 0000 0000 0000 0XXX
000019C0  13C4 000020D9           1295                          MOVE.B      D4,CURRENT_DEST_MD
000019C6  4E75                    1296                          RTS
000019C8                          1297  
000019C8                          1298  ;By this point, CURRENT WORD holds the first 16 bits of an instruction we are looking at.
000019C8                          1299  ;(we should already know the OPcode by this point, so this will be called by various OPcode subroutines.)
000019C8                          1300  *---------------------- Check the source mode of the current word.--------------------
000019C8                          1301  *(assuming the source is where it would be in MOVE).
000019C8  4244                    1302  READ_SOURCE_MODE        CLR         D4
000019CA  4239 000020D7           1303                          CLR.B       CURRENT_SRC_MD
000019D0  3839 000020C2           1304                          MOVE.W      CURRENT_WORD,D4
000019D6  0244 0038               1305                          ANDI.W      #FILT_SRC_MD,D4                 ; turn source mode into 0000 0000 00XX X000
000019DA  E64C                    1306                          LSR.W       #3,D4                           ; turn source mode into 0000 0000 0000 0XXX
000019DC  13C4 000020D7           1307                          MOVE.B      D4,CURRENT_SRC_MD
000019E2  4E75                    1308                          RTS
000019E4                          1309                          
000019E4                          1310  *----------------------Check the source register of the current word.-----------------
000019E4  4244                    1311  READ_SOURCE_REG         CLR         D4
000019E6  4239 000020D8           1312                          CLR.B       CURRENT_SRC_REG
000019EC  3839 000020C2           1313                          MOVE.W      CURRENT_WORD,D4
000019F2  0244 0007               1314                          ANDI.W      #FILT_SRC_REG,D4        ; turn D4 into 0000 0000 0000 0XXX. (no need for LSR in this case.)
000019F6  13C4 000020D8           1315                          MOVE.B      D4,CURRENT_SRC_REG
000019FC  4E75                    1316                          RTS
000019FE                          1317  *--------TODO: READ_OP_SIZE---------
000019FE                          1318                         
000019FE                          1319  *----------------------Read additional source data associated with the current word (if necessary).----------------- 
000019FE                          1320  *This needs to postincrement A5 as necessary for each case.
000019FE  4279 000020E0           1321  READ_SOURCE_DATA        CLR         CURRENT_SRC_DATA
00001A04  4279 000020DC           1322                          CLR         CURRENT_DATA
00001A0A  0C39 0007 000020D7      1323                          CMP.B       #CONST_ADDR_MISC_MD,CURRENT_SRC_MD ; check the source mode
00001A12  6700 0004               1324                          BEQ         CONFIRM_READ_SRC_DATA              ; see if we have a source mode that requires additional data.               
00001A16  4E75                    1325                          RTS
00001A18                          1326                          
00001A18  4239 000020D6           1327  CONFIRM_READ_SRC_DATA   CLR.B       CURRENT_REG
00001A1E  13F9 000020D8 000020D6  1328                          MOVE.B      CURRENT_SRC_REG,CURRENT_REG
00001A28  6100 00BC               1329                          BSR         CONFIRM_READ_DATA
00001A2C  23F9 000020DC 000020E0  1330                          MOVE.L      CURRENT_DATA,CURRENT_SRC_DATA
00001A36  4E75                    1331                          RTS
00001A38                          1332   
00001A38                          1333  *----------------------Read additional destination data associated with the current word (if necessary).----------------- 
00001A38                          1334  *This needs to postincrement A5 as necessary.                       
00001A38  4279 000020E4           1335  READ_DEST_DATA          CLR         CURRENT_DEST_DATA
00001A3E  4279 000020DC           1336                          CLR         CURRENT_DATA
00001A44  0C39 0007 000020D9      1337                          CMP.B       #CONST_ADDR_MISC_MD,CURRENT_DEST_MD  ; check the destination mode.
00001A4C  6700 0004               1338                          BEQ         CONFIRM_READ_DEST_DATA               ; see if we have a destination mode that requires additional data.                  
00001A50  4E75                    1339                          RTS
00001A52                          1340                                              
00001A52  4239 000020D6           1341  CONFIRM_READ_DEST_DATA  CLR.B       CURRENT_REG
00001A58  13F9 000020DA 000020D6  1342                          MOVE.B      CURRENT_DEST_REG,CURRENT_REG
00001A62  6100 0082               1343                          BSR         CONFIRM_READ_DATA
00001A66  23F9 000020DC 000020E4  1344                          MOVE.L      CURRENT_DATA,CURRENT_DEST_DATA
00001A70  4E75                    1345                          RTS
00001A72                          1346  
00001A72                          1347  *-----------------------Read additional data in ways that are direction-oriented.--------------------------------------
00001A72                          1348  
00001A72                          1349      *Left
00001A72  4279 000020C8           1350  READ_LEFT_DATA          CLR         CURRENT_L_DATA
00001A78  4279 000020DC           1351                          CLR         CURRENT_DATA
00001A7E  0C39 0007 000020C5      1352                          CMP.B       #CONST_ADDR_MISC_MD,CURRENT_L_MD     ; check the left mode.
00001A86  6700 0004               1353                          BEQ         CONFIRM_READ_LEFT_DATA               ; see if we have a mode that requires additional data.                  
00001A8A  4E75                    1354                          RTS
00001A8C                          1355                                              
00001A8C  4239 000020D6           1356  CONFIRM_READ_LEFT_DATA  CLR.B       CURRENT_REG
00001A92  13F9 000020C6 000020D6  1357                          MOVE.B      CURRENT_L_REG,CURRENT_REG
00001A9C  6100 0048               1358                          BSR         CONFIRM_READ_DATA
00001AA0  23F9 000020DC 000020C8  1359                          MOVE.L      CURRENT_DATA,CURRENT_L_DATA
00001AAA  4E75                    1360                          RTS
00001AAC                          1361                          
00001AAC                          1362      *Right
00001AAC  4279 000020CE           1363  READ_RIGHT_DATA         CLR         CURRENT_R_DATA
00001AB2  4279 000020DC           1364                          CLR         CURRENT_DATA
00001AB8  0C39 0007 000020CC      1365                          CMP.B       #CONST_ADDR_MISC_MD,CURRENT_R_MD ; check the right mode.
00001AC0  6700 0004               1366                          BEQ         CONFIRM_READ_RIGHT_DATA              ; see if we have a mode that requires additional data.                  
00001AC4  4E75                    1367                          RTS
00001AC6                          1368                                              
00001AC6  4239 000020D6           1369  CONFIRM_READ_RIGHT_DATA CLR.B       CURRENT_REG
00001ACC  13F9 000020CD 000020D6  1370                          MOVE.B      CURRENT_R_REG,CURRENT_REG
00001AD6  6100 000E               1371                          BSR         CONFIRM_READ_DATA
00001ADA  23F9 000020DC 000020CE  1372                          MOVE.L      CURRENT_DATA,CURRENT_R_DATA
00001AE4  4E75                    1373                          RTS
00001AE6                          1374                          
00001AE6                          1375  *-----------------------Read some additional data.----------------------------------------------------------
00001AE6                          1376        ; This same subroutine is used for reading any kind of data, as long as CURRENT_REG is set beforehand.
00001AE6                          1377        ; By this point, CURRENT_REG holds whatever register we currently care about. (could also use CURRENT_REG)         
00001AE6  0C39 0002 000020D6      1378  CONFIRM_READ_DATA       CMP.B       #CONST_COUNTR_DISPLC_REG,CURRENT_REG      ; see if we are reading counter w/ displacement
00001AEE  6700 0034               1379                          BEQ         READ_COUNTR_DISPLC_DATA
00001AF2                          1380                     
00001AF2  0C39 0003 000020D6      1381                          CMP.B       #CONST_COUNTR_INDEX_REG,CURRENT_REG       ; see if we are reading counter w/ index
00001AFA  6700 002A               1382                          BEQ         READ_COUNTR_INDEX_DATA
00001AFE                          1383                          
00001AFE  0C39 0000 000020D6      1384                          CMP.B       #CONST_ABS_SHORT_REG,CURRENT_REG          ; see if we are reading absolute short address
00001B06  6700 0020               1385                          BEQ         READ_ABS_SHORT_DATA
00001B0A                          1386                          
00001B0A  0C39 0001 000020D6      1387                          CMP.B       #CONST_ABS_LONG_REG,CURRENT_REG           ; see if we are reading absolute long address
00001B12  6700 001C               1388                          BEQ         READ_ABS_LONG_DATA 
00001B16                          1389                          
00001B16  0C39 0004 000020D6      1390                          CMP.B       #CONST_IMMEDIATE_REG,CURRENT_REG          ; see if we are reading immediate data
00001B1E  6700 0018               1391                          BEQ         READ_IMMEDIATE_DATA
00001B22                          1392       
00001B22  4E75                    1393                          RTS
00001B24                          1394                          
00001B24                          1395  ; TODO: each of these SRs should increment A5 by the proper amount while also storing the correct data in CURRENT_DATA.
00001B24  4E75                    1396  READ_COUNTR_DISPLC_DATA RTS ; TODO: read data for counter w/ displacement (d16,PC)
00001B26                          1397  
00001B26  4E75                    1398  READ_COUNTR_INDEX_DATA  RTS ; TODO: read data for counter w/ index        (d16,PC,Xn)
00001B28                          1399  
00001B28                          1400  *-----------------------Read additional absolute word address---------------------------
00001B28  33DD 000020DC           1401  READ_ABS_SHORT_DATA     MOVE.W      (A5)+,CURRENT_DATA ; read data for absolute short address  (xxx).W
00001B2E  4E75                    1402                          RTS
00001B30                          1403                          
00001B30                          1404  *-----------------------Read additional absolute long address---------------------------
00001B30  23DD 000020DC           1405  READ_ABS_LONG_DATA      MOVE.L      (A5)+,CURRENT_DATA ; read data for absolute long address   (xxx).L
00001B36  4E75                    1406                          RTS 
00001B38                          1407  
00001B38                          1408  *-----------------------Read additional immediate data---------------------------
00001B38  0C39 0000 000020C4      1409  READ_IMMEDIATE_DATA     CMP.B       #BYTE_SIZE,CURRENT_OP_SIZE   ; see if we are reading immediate byte data
00001B40  6700 001C               1410                          BEQ         READ_IMMEDIATE_DATA_W
00001B44                          1411                          
00001B44  0C39 0001 000020C4      1412                          CMP.B       #WORD_SIZE,CURRENT_OP_SIZE   ; see if we are reading immediate word data
00001B4C  6700 0010               1413                          BEQ         READ_IMMEDIATE_DATA_W
00001B50                          1414                          
00001B50  0C39 0002 000020C4      1415                          CMP.B       #LONG_SIZE,CURRENT_OP_SIZE   ; see if we are reading immediate long data
00001B58  6700 0012               1416                          BEQ         READ_IMMEDIATE_DATA_L
00001B5C                          1417                          ;TODO: error case goes here
00001B5C  4E75                    1418                          RTS
00001B5E                          1419  
00001B5E  4279 000020DC           1420  READ_IMMEDIATE_DATA_W   CLR         CURRENT_DATA
00001B64  33DD 000020DC           1421                          MOVE.W      (A5)+,CURRENT_DATA
00001B6A  4E75                    1422                          RTS
00001B6C                          1423                          
00001B6C  4279 000020DC           1424  READ_IMMEDIATE_DATA_L   CLR         CURRENT_DATA
00001B72  23DD 000020DC           1425                          MOVE.L      (A5)+,CURRENT_DATA
00001B78  4E75                    1426                          RTS
00001B7A                          1427                          
00001B7A                          1428  *----------------------Display the source for the current instruction.-----------------
00001B7A                          1429  *by this point, error checking should already be done and CURRENT_SRC_MD and CURRENT_SRC_REG should have the data we need.
00001B7A  4239 000020D5           1430  DISPLAY_SOURCE          CLR.B       CURRENT_MD
00001B80  4239 000020D6           1431                          CLR.B       CURRENT_REG
00001B86  42B9 000020DC           1432                          CLR.L       CURRENT_DATA
00001B8C                          1433                          
00001B8C  13F9 000020D7 000020D5  1434                          MOVE.B      CURRENT_SRC_MD,CURRENT_MD
00001B96  13F9 000020D8 000020D6  1435                          MOVE.B      CURRENT_SRC_REG,CURRENT_REG    
00001BA0  23F9 000020E0 000020DC  1436                          MOVE.L      CURRENT_SRC_DATA,CURRENT_DATA
00001BAA  6100 00A6               1437                          BSR         CHECK_ADDRESSING_MODES   
00001BAE  4E75                    1438                          RTS  
00001BB0                          1439                          
00001BB0                          1440  *----------------------Display the destination for the current instruction.-----------------
00001BB0                          1441  *by this point, error checking should already be done and CURRENT_DEST_MD and CURRENT_DEST_REG should have the data we need.
00001BB0  4239 000020D5           1442  DISPLAY_DEST            CLR.B       CURRENT_MD
00001BB6  4239 000020D6           1443                          CLR.B       CURRENT_REG
00001BBC  42B9 000020DC           1444                          CLR.L       CURRENT_DATA
00001BC2                          1445                          
00001BC2  13F9 000020D9 000020D5  1446                          MOVE.B      CURRENT_DEST_MD,CURRENT_MD
00001BCC  13F9 000020DA 000020D6  1447                          MOVE.B      CURRENT_DEST_REG,CURRENT_REG    
00001BD6  23F9 000020E4 000020DC  1448                          MOVE.L      CURRENT_DEST_DATA,CURRENT_DATA
00001BE0  6100 0070               1449                          BSR         CHECK_ADDRESSING_MODES     
00001BE4  4E75                    1450                          RTS  
00001BE6                          1451  
00001BE6                          1452  *----------------------Display the left side of the current instruction.-----------------------                        
00001BE6  4239 000020D5           1453  DISPLAY_LEFT            CLR.B       CURRENT_MD
00001BEC  4239 000020D6           1454                          CLR.B       CURRENT_REG
00001BF2  42B9 000020DC           1455                          CLR.L       CURRENT_DATA
00001BF8                          1456                          
00001BF8  13F9 000020C5 000020D5  1457                          MOVE.B      CURRENT_L_MD,CURRENT_MD
00001C02  13F9 000020C6 000020D6  1458                          MOVE.B      CURRENT_L_REG,CURRENT_REG    
00001C0C  23F9 000020C8 000020DC  1459                          MOVE.L      CURRENT_L_DATA,CURRENT_DATA
00001C16  6100 003A               1460                          BSR         CHECK_ADDRESSING_MODES   
00001C1A  4E75                    1461                          RTS  
00001C1C                          1462                          
00001C1C                          1463  *----------------------Display the right side of the current instruction.-----------------------  
00001C1C  4239 000020D5           1464  DISPLAY_RIGHT           CLR.B       CURRENT_MD
00001C22  4239 000020D6           1465                          CLR.B       CURRENT_REG
00001C28  42B9 000020DC           1466                          CLR.L       CURRENT_DATA
00001C2E                          1467                          
00001C2E  13F9 000020CC 000020D5  1468                          MOVE.B      CURRENT_R_MD,CURRENT_MD
00001C38  13F9 000020CD 000020D6  1469                          MOVE.B      CURRENT_R_REG,CURRENT_REG    
00001C42  23F9 000020CE 000020DC  1470                          MOVE.L      CURRENT_R_DATA,CURRENT_DATA
00001C4C  6100 0004               1471                          BSR         CHECK_ADDRESSING_MODES   
00001C50  4E75                    1472                          RTS  
00001C52                          1473                          
00001C52                          1474  *-----------------------Mode checks (for displaying)---------
00001C52                          1475  *these do not care whether the mode is for source or destination.
00001C52  0C39 0000 000020D5      1476  CHECK_ADDRESSING_MODES  CMP.B       #CONST_DATA_REG_MD,CURRENT_MD   ; check for CURRENT_MD = ...0000
00001C5A  6700 0058               1477                          BEQ         DISPLAY_DATA_REG
00001C5E  0C39 0001 000020D5      1478                          CMP.B       #CONST_ADDR_REG_MD,CURRENT_MD    ; check for CURRENT_MD = ...0001
00001C66  6700 006C               1479                          BEQ         DISPLAY_ADDR_REG
00001C6A  0C39 0002 000020D5      1480                          CMP.B       #CONST_ADDR_IND_MD,CURRENT_MD    ; check for CURRENT_MD = ...0010
00001C72  6700 0080               1481                          BEQ         DISPLAY_ADDR_IND
00001C76  0C39 0003 000020D5      1482                          CMP.B       #CONST_ADDR_INCR_MD,CURRENT_MD   ; check for CURRENT_MD = ...0011
00001C7E  6700 00AC               1483                          BEQ         DISPLAY_ADDR_INCR
00001C82  0C39 0004 000020D5      1484                          CMP.B       #CONST_ADDR_DECR_MD,CURRENT_MD   ; check for CURRENT_MD = ...0100
00001C8A  6700 00E4               1485                          BEQ         DISPLAY_ADDR_DECR
00001C8E  0C39 0005 000020D5      1486                          CMP.B       #CONST_ADDR_DISPLC_MD,CURRENT_MD ; check for CURRENT_MD = ...0101
00001C96  6700 011C               1487                          BEQ         DISPLAY_ADDR_DISPLC
00001C9A  0C39 0006 000020D5      1488                          CMP.B       #CONST_ADDR_INDEX_MD,CURRENT_MD  ; check for CURRENT_MD = ...0110
00001CA2  6700 0112               1489                          BEQ         DISPLAY_ADDR_INDEX
00001CA6  0C39 0007 000020D5      1490                          CMP.B       #CONST_ADDR_MISC_MD,CURRENT_MD   ; check for CURRENT_MD = ...0111
00001CAE  6700 0108               1491                          BEQ         CHECK_MISC_ADDRESSINGS
00001CB2                          1492                          ;TODO: error cases? 
00001CB2  4E75                    1493                          RTS
00001CB4                          1494  
00001CB4                          1495  ; case for displaying data register.          
00001CB4  43F9 0000209A           1496  DISPLAY_DATA_REG        LEA         MSG_D,A1               ; print out 'D' (later, send this to dislpay buffer)
00001CBA  103C 000E               1497                          MOVE.B      #14,D0
00001CBE  4E4F                    1498                          TRAP        #15
00001CC0                          1499                          
00001CC0  4241                    1500                          CLR         D1
00001CC2  1239 000020D6           1501                          MOVE.B      (CURRENT_REG),D1      ; print out the number of the data register.
00001CC8  143C 0010               1502                          MOVE.B      #16,D2
00001CCC  103C 000F               1503                          MOVE.B      #15,D0
00001CD0  4E4F                    1504                          TRAP        #15
00001CD2                          1505                          
00001CD2  4E75                    1506                          RTS
00001CD4                          1507  
00001CD4                          1508  ; case for displaying address register. 
00001CD4  43F9 0000209C           1509  DISPLAY_ADDR_REG        LEA         MSG_A,A1               ; print out 'A'
00001CDA  103C 000E               1510                          MOVE.B      #14,D0
00001CDE  4E4F                    1511                          TRAP        #15
00001CE0                          1512                          
00001CE0  4241                    1513                          CLR         D1
00001CE2  1239 000020D6           1514                          MOVE.B      (CURRENT_REG),D1       ; print out the number of the data register.
00001CE8  143C 0010               1515                          MOVE.B      #16,D2
00001CEC  103C 000F               1516                          MOVE.B      #15,D0
00001CF0  4E4F                    1517                          TRAP        #15
00001CF2                          1518                          
00001CF2  4E75                    1519                          RTS
00001CF4                          1520  
00001CF4                          1521  ; case for displaying address register indirect.                        
00001CF4  43F9 00001E6F           1522  DISPLAY_ADDR_IND        LEA         OPEN_PARENS,A1         ; print out '(' (later, send this to dislpay buffer)
00001CFA  103C 000E               1523                          MOVE.B      #14,D0
00001CFE  4E4F                    1524                          TRAP        #15
00001D00                          1525                          
00001D00  43F9 0000209C           1526                          LEA         MSG_A,A1               ; print out 'A'
00001D06  103C 000E               1527                          MOVE.B      #14,D0
00001D0A  4E4F                    1528                          TRAP        #15
00001D0C                          1529                          
00001D0C  4241                    1530                          CLR         D1
00001D0E  1239 000020D6           1531                          MOVE.B      (CURRENT_REG),D1      ; print out the number of the data register.
00001D14  143C 0010               1532                          MOVE.B      #16,D2
00001D18  103C 000F               1533                          MOVE.B      #15,D0
00001D1C  4E4F                    1534                          TRAP        #15
00001D1E                          1535                          
00001D1E  43F9 00001E71           1536                          LEA         CLOSE_PARENS,A1       ; print out ')'
00001D24  103C 000E               1537                          MOVE.B      #14,D0
00001D28  4E4F                    1538                          TRAP        #15
00001D2A                          1539                          
00001D2A  4E75                    1540                          RTS
00001D2C                          1541  
00001D2C                          1542  ; case for displaying address indirect postincrement.
00001D2C  43F9 00001E6F           1543  DISPLAY_ADDR_INCR       LEA         OPEN_PARENS,A1        ; print out '(' (later, send this to dislpay buffer)
00001D32  103C 000E               1544                          MOVE.B      #14,D0
00001D36  4E4F                    1545                          TRAP        #15
00001D38                          1546                          
00001D38  43F9 0000209C           1547                          LEA         MSG_A,A1              ; print out 'A'
00001D3E  103C 000E               1548                          MOVE.B      #14,D0
00001D42  4E4F                    1549                          TRAP        #15
00001D44                          1550                          
00001D44  4241                    1551                          CLR         D1
00001D46  1239 000020D6           1552                          MOVE.B      (CURRENT_REG),D1      ; print out the number of the data register.
00001D4C  143C 0010               1553                          MOVE.B      #16,D2
00001D50  103C 000F               1554                          MOVE.B      #15,D0
00001D54  4E4F                    1555                          TRAP        #15
00001D56                          1556                          
00001D56  43F9 00001E71           1557                          LEA         CLOSE_PARENS,A1       ; print out ')'
00001D5C  103C 000E               1558                          MOVE.B      #14,D0
00001D60  4E4F                    1559                          TRAP        #15
00001D62                          1560                          
00001D62  43F9 00001E73           1561                          LEA         PLUS,A1               ; print out '+'
00001D68  103C 000E               1562                          MOVE.B      #14,D0
00001D6C  4E4F                    1563                          TRAP        #15
00001D6E                          1564                          
00001D6E  4E75                    1565                          RTS
00001D70                          1566                          
00001D70                          1567  ; case for displaying address indirect preedecrement mode.
00001D70  43F9 00001E75           1568  DISPLAY_ADDR_DECR       LEA         MINUS,A1               ; print out '-'
00001D76  103C 000E               1569                          MOVE.B      #14,D0
00001D7A  4E4F                    1570                          TRAP        #15                                           
00001D7C                          1571  
00001D7C  43F9 00001E6F           1572                          LEA         OPEN_PARENS,A1        ; print out '(' (later, send this to dislpay buffer)
00001D82  103C 000E               1573                          MOVE.B      #14,D0
00001D86  4E4F                    1574                          TRAP        #15
00001D88                          1575                          
00001D88  43F9 0000209C           1576                          LEA         MSG_A,A1              ; print out 'A'
00001D8E  103C 000E               1577                          MOVE.B      #14,D0
00001D92  4E4F                    1578                          TRAP        #15
00001D94                          1579                          
00001D94  4241                    1580                          CLR         D1
00001D96  1239 000020D6           1581                          MOVE.B      (CURRENT_REG),D1      ; print out the number of the data register.
00001D9C  143C 0010               1582                          MOVE.B      #16,D2
00001DA0  103C 000F               1583                          MOVE.B      #15,D0
00001DA4  4E4F                    1584                          TRAP        #15
00001DA6                          1585                          
00001DA6  43F9 00001E71           1586                          LEA         CLOSE_PARENS,A1       ; print out ')'
00001DAC  103C 000E               1587                          MOVE.B      #14,D0
00001DB0  4E4F                    1588                          TRAP        #15
00001DB2                          1589                          
00001DB2  4E75                    1590                          RTS     
00001DB4                          1591  
00001DB4                          1592  DISPLAY_ADDR_DISPLC     ;TODO: case for source mode is address with displacement mode.
00001DB4  4E75                    1593                          RTS    
00001DB6                          1594  
00001DB6                          1595  DISPLAY_ADDR_INDEX      ;TODO: case for source mode is address with index mode.
00001DB6  4E75                    1596                          RTS 
00001DB8                          1597  
00001DB8                          1598  *-----------------------Register checks (for displaying only)---------
00001DB8                          1599  *these do not care whether the register is for source or destination.
00001DB8                          1600  *not for cases where reg is simply a number (like D5, A5, (A5), etc),
00001DB8                          1601  *only for miscellaneous addressings where mode is 111.                        
00001DB8  0C39 0002 000020D6      1602  CHECK_MISC_ADDRESSINGS  CMP.B       #CONST_COUNTR_DISPLC_REG,CURRENT_REG
00001DC0  6700 0034               1603                          BEQ         DISPLAY_COUNTR_DISPLC
00001DC4                          1604                          
00001DC4  0C39 0003 000020D6      1605                          CMP.B       #CONST_COUNTR_INDEX_REG,CURRENT_REG
00001DCC  6700 002A               1606                          BEQ         DISPLAY_COUNTR_INDEX
00001DD0                          1607                          
00001DD0  0C39 0000 000020D6      1608                          CMP.B       #CONST_ABS_SHORT_REG,CURRENT_REG
00001DD8  6700 0020               1609                          BEQ         DISPLAY_ABS_SHORT
00001DDC                          1610                          
00001DDC  0C39 0001 000020D6      1611                          CMP.B       #CONST_ABS_LONG_REG,CURRENT_REG
00001DE4  6700 0034               1612                          BEQ         DISPLAY_ABS_LONG
00001DE8                          1613                          
00001DE8  0C39 0004 000020D6      1614                          CMP.B       #CONST_IMMEDIATE_REG,CURRENT_REG
00001DF0  6700 0048               1615                          BEQ         DISPLAY_IMMEDIATE
00001DF4                          1616                          
00001DF4                          1617                          ; TODO: error case?
00001DF4                          1618                          
00001DF4  4E75                    1619                          RTS
00001DF6                          1620                          
00001DF6  4E75                    1621  DISPLAY_COUNTR_DISPLC   RTS         ;TODO   
00001DF8                          1622  
00001DF8  4E75                    1623  DISPLAY_COUNTR_INDEX    RTS         ;TODO   
00001DFA                          1624  
00001DFA  43F9 00001E69           1625  DISPLAY_ABS_SHORT       LEA         DOLLAR,A1             ; print out '$'. 
00001E00  103C 000E               1626                          MOVE.B      #14,D0
00001E04  4E4F                    1627                          TRAP        #15
00001E06                          1628  
00001E06  4241                    1629                          CLR         D1
00001E08  3239 000020DC           1630                          MOVE.W      (CURRENT_DATA),D1     ; print out the absolute short address we are concerned with in hex. 
00001E0E  143C 0010               1631                          MOVE.B      #16,D2
00001E12  103C 000F               1632                          MOVE.B      #15,D0
00001E16  4E4F                    1633                          TRAP        #15
00001E18                          1634                          
00001E18  4E75                    1635                          RTS 
00001E1A                          1636  
00001E1A  43F9 00001E69           1637  DISPLAY_ABS_LONG        LEA         DOLLAR,A1             ; print out '$'. 
00001E20  103C 000E               1638                          MOVE.B      #14,D0
00001E24  4E4F                    1639                          TRAP        #15
00001E26                          1640  
00001E26  4241                    1641                          CLR         D1
00001E28  2239 000020DC           1642                          MOVE.L      (CURRENT_DATA),D1     ; print out the absolute long address we are concerned with in hex. 
00001E2E  143C 0010               1643                          MOVE.B      #16,D2
00001E32  103C 000F               1644                          MOVE.B      #15,D0
00001E36  4E4F                    1645                          TRAP        #15
00001E38                          1646                          
00001E38  4E75                    1647                          RTS 
00001E3A                          1648  
00001E3A  43F9 00001E6D           1649  DISPLAY_IMMEDIATE       LEA         HASH,A1               ; print out '#'. (NOTE: should send this to display buffer instead.)
00001E40  103C 000E               1650                          MOVE.B      #14,D0
00001E44  4E4F                    1651                          TRAP        #15
00001E46                          1652                          
00001E46  43F9 00001E69           1653                          LEA         DOLLAR,A1             ; print out '$'. (this saves time since we can more easily find the hex value of the immediate data.)
00001E4C  103C 000E               1654                          MOVE.B      #14,D0
00001E50  4E4F                    1655                          TRAP        #15
00001E52                          1656                          
00001E52  3239 000020DC           1657                          MOVE.W      (CURRENT_DATA),D1     ; print out the immediate data we are concerned with in hex. 
00001E58  143C 0010               1658                          MOVE.B      #16,D2
00001E5C  103C 000F               1659                          MOVE.B      #15,D0
00001E60  4E4F                    1660                          TRAP        #15
00001E62                          1661                          
00001E62  4E75                    1662                          RTS
00001E64                          1663                          
00001E64                          1664  *###################### END EA ##################################
00001E64                          1665  *############# BEGIN VARIABLES/CONSTANTS #########################
00001E64                          1666  *** Variables and Constants are kept here ***
00001E64                          1667  
00001E64                          1668  *output characters
00001E64  =0000000D               1669  CR                      EQU         $0D
00001E64  =0000000A               1670  LF                      EQU         $0A
00001E64= 0D 0A 00                1671  RETURN                  DC.B        CR,LF,0
00001E67= 20 00                   1672  SPACE                   DC.B        ' ',0
00001E69= 24 00                   1673  DOLLAR                  DC.B        '$',0
00001E6B= 2C 00                   1674  COMMA                   DC.B        ',',0
00001E6D= 23 00                   1675  HASH                    DC.B        '#',0
00001E6F= 28 00                   1676  OPEN_PARENS             DC.B        '(',0
00001E71= 29 00                   1677  CLOSE_PARENS            DC.B        ')',0
00001E73= 2B 00                   1678  PLUS                    DC.B        '+',0
00001E75= 2D 00                   1679  MINUS                   DC.B        '-',0
00001E77= 2F 00                   1680  SLASH                   DC.B        '/',0
00001E79                          1681  
00001E79                          1682  *output messages
00001E79                          1683      ;TODO: consider also giving the user the range of valid start/end addresses
00001E79= 50 6C 65 61 73 65 ...   1684  START_ADDR_MSG          DC.B        'Please enter a starting hex address to read from.',CR,LF,0
00001EAD= 50 6C 65 61 73 65 ...   1685  END_ADDR_MSG            DC.B        'Please enter an ending hex address to read from.',CR,LF,0
00001EE0                          1686  
00001EE0= 4E 6F 74 20 61 20 ...   1687  INVALID_LEN_MSG         DC.B        'Not a valid length for input address.',CR,LF
00001F07= 50 6C 65 61 73 65 ...   1688                          DC.B        'Please enter a valid-length address.',CR,LF,0
00001F2E= 4E 6F 74 20 61 20 ...   1689  INVALID_ADDR_MSG        DC.B        'Not a valid address.',CR,LF
00001F44= 50 6C 65 61 73 65 ...   1690                          DC.B        'Please enter a valid address.',CR,LF,0
00001F64= 4E 6F 74 20 61 20 ...   1691  INVALID_END_ADDR_MSG    DC.B        'Not a valid end address.',CR,LF
00001F7E= 50 6C 65 61 73 65 ...   1692                          DC.B        'Please enter an end address after the start address.',CR,LF,0
00001FB5                          1693                        
00001FB5= 4E 6F 74 20 61 20 ...   1694  INVALID_ADDR_L_MSG      DC.B        'Not a valid address (too low).',CR,LF
00001FD5= 50 6C 65 61 73 65 ...   1695                          DC.B        'Please enter a valid address.',CR,LF,0
00001FF5                          1696                          
00001FF5= 4E 6F 74 20 61 20 ...   1697  INVALID_ADDR_H_MSG      DC.B        'Not a valid address (too high).',CR,LF
00002016= 50 6C 65 61 73 65 ...   1698                          DC.B        'Please enter a valid address.',CR,LF,0
00002036                          1699                          
00002036= 44 6F 6E 65 20 72 ...   1700  DONE_READING_MSG        DC.B        'Done reading the program.',CR,LF,0
00002052                          1701  
00002052                          1702  *output instruction names (OPcodes)
00002052                          1703      ;sizes
00002052= 2E 42 00                1704  BYTE_SIZE_MSG           DC.B        '.B',0
00002055= 2E 57 00                1705  WORD_SIZE_MSG           DC.B        '.W',0
00002058= 2E 4C 00                1706  LONG_SIZE_MSG           DC.B        '.L',0
0000205B                          1707  
0000205B                          1708      ;constants
0000205B= 52 45 53 45 54 00       1709  RESET_MSG               DC.B        'RESET',0
00002061= 4E 4F 50 00             1710  NOP_MSG                 DC.B        'NOP',0
00002065= 53 54 4F 50 00          1711  STOP_MSG                DC.B        'STOP',0
0000206A                          1712      ;moves
0000206A= 4D 4F 56 45 00          1713  MOVE_MSG                DC.B        'MOVE',0
0000206F= 4D 4F 56 45 2E 42 00    1714  MOVE_B_MSG              DC.B        'MOVE.B',0
00002076= 4D 4F 56 45 2E 57 00    1715  MOVE_W_MSG              DC.B        'MOVE.W',0
0000207D= 4D 4F 56 45 2E 4C 00    1716  MOVE_L_MSG              DC.B        'MOVE.L',0
00002084                          1717  
00002084= 4D 4F 56 45 51 00       1718  MOVEQ_MSG               DC.B        'MOVEQ',0
0000208A                          1719  
0000208A= 4D 4F 56 45 4D 2E ...   1720  MOVEM_W_MSG             DC.B        'MOVEM.W',0
00002092= 4D 4F 56 45 4D 2E ...   1721  MOVEM_L_MSG             DC.B        'MOVEM.L',0
0000209A                          1722  
0000209A                          1723  *other output instruction message constants
0000209A= 44 00                   1724  MSG_D                   DC.B        'D',0
0000209C= 41 00                   1725  MSG_A                   DC.B        'A',0
0000209E                          1726  
0000209E                          1727  *storage locations for input
0000209E                          1728  START_ADDR_IN           DS.B        20
000020B2                          1729  
000020B2                          1730  *other I/O-related variables/constants
000020B2  =00000001               1731  INPUTTING_START         SET         1 ;if 1, we are inputting start address. If 0, we are inputting end address.
000020B2                          1732  OPCODE_BUFFER           DS.L        1 ; can hold at most 4 characters
000020B6                          1733  SIZE_BUFFER             DS.W        1 ;cand hold at most 2 characters
000020B8                          1734  DISPLAY_BUFFER          DS.W        5
000020C2                          1735  
000020C2                          1736  *EA/OPcode parsed instruction variables/constants
000020C2                          1737  
000020C2                          1738  CURRENT_WORD            DS.W        1 ; current first 16 bits of an instruction.
000020C4                          1739  CURRENT_OP_SIZE         DS.B        1 ; current operation size. Byte = 01, Word = 11, Long = 10
000020C5                          1740  
000020C5                          1741      *Direction-oriented variables
000020C5                          1742          *left
000020C5                          1743  CURRENT_L_MD            DS.B        1 ; current left mode (printing-wise) we are concerned with.
000020C6                          1744  CURRENT_L_REG           DS.B        1 ; current left register (printing-wise) we are concerned with.
000020C8                          1745  CURRENT_L_DATA          DS.L        1
000020CC                          1746          *right
000020CC                          1747  CURRENT_R_MD            DS.B        1 ; current right mode (printing-wise) we are concerned with.
000020CD                          1748  CURRENT_R_REG           DS.B        1 ; current right register (printing-wise) we are concerned with.
000020CE                          1749  CURRENT_R_DATA          DS.L        1
000020D2                          1750  
000020D2                          1751  
000020D2                          1752      *Destination/source-oriented variables
000020D2                          1753  CURRENT_EA_MD           DS.B        1 ; current EA mode we are concerned with.
000020D3                          1754  CURRENT_EA_REG          DS.B        1 ; current EA register we are concerned with.
000020D4                          1755  
000020D4                          1756  CURRENT_DIRECTION       DS.B        1 ; current direction of an operation.
000020D5                          1757  
000020D5                          1758  CURRENT_MD              DS.B        1 ; current mode we are concerened with (ex: 000 for data register mode.)
000020D6                          1759  CURRENT_REG             DS.B        1 ; current register number we are concerned with(address, data, etc) that we are looking at. Ex: D0,A5,etc
000020D7                          1760  
000020D7                          1761  CURRENT_SRC_MD          DS.B        1 ; current source mode
000020D8                          1762  CURRENT_SRC_REG         DS.B        1 ; current source register
000020D9                          1763  CURRENT_DEST_MD         DS.B        1 ; current desination mode
000020DA                          1764  CURRENT_DEST_REG        DS.B        1 ; current desination register
000020DB                          1765  
000020DC                          1766  CURRENT_DATA            DS.L        1 ; current addition data we are concerned with
000020E0                          1767  CURRENT_SRC_DATA        DS.L        1 ; current additional data for source (like absolute addresses, immediate data, etc)
000020E4                          1768  CURRENT_DEST_DATA       DS.L        1 ; current additional data for destination (like absolute addresses, immediate data, etc) 
000020E8                          1769  
000020E8                          1770      *miscellaneous EA variables
000020E8                          1771  CURRENT_MASK_FIELD      DS.W        1 ; right now, this is only used for MOVEM.
000020EA                          1772  
000020EA                          1773  *size constants
000020EA  =00000000               1774  BYTE_SIZE               EQU         $00 ; 0000 0000
000020EA  =00000001               1775  WORD_SIZE               EQU         $01 ; 0000 0001
000020EA  =00000002               1776  LONG_SIZE               EQU         $02 ; 0000 0010
000020EA                          1777  
000020EA  =00000001               1778  BYTE_SIZE_M             EQU         $01 ; 0000 0001
000020EA  =00000003               1779  WORD_SIZE_M             EQU         $03 ; 0000 0011
000020EA  =00000002               1780  LONG_SIZE_M             EQU         $02 ; 0000 0010
000020EA                          1781  
000020EA  =00000000               1782  WORD_SIZE_MOVEM         EQU         $00 ; 0000 0000
000020EA  =00000001               1783  LONG_SIZE_MOVEM         EQU         $01 ; 0000 0001
000020EA                          1784  
000020EA                          1785  *address constants
000020EA  =00003000               1786  MIN_ADDRESS             EQU         $00003000
000020EA  =0FFF0000               1787  MAX_ADDRESS             EQU         $0FFF0000
000020EA                          1788  
000020EA                          1789  *address variables
000020EA  =00007000               1790  TEST_ORIGIN             SET         $00007000
000020EA  =00007000               1791  NEXT_ADDR               SET         TEST_ORIGIN
000020EA  =00009000               1792  END_ADDR                SET         $00009000
000020EA                          1793  
000020EA                          1794  *filters for isolating parts of a hexa instruction. X means 'unknown' and can be 0 or one after ANDI filter.
000020EA                          1795  *To filter an instruction, ANDI it with the desired filter.
000020EA                          1796  *note: I'm not sure if it matters much whether you have the 4 leading 0s in these filters, but I don't want to
000020EA                          1797  *risk changing it. Therefore, some filters have leading 0s and some do not.
000020EA                          1798      * general filters
000020EA  =0000C000               1799  FILT_2BIT_1             EQU         $0000C000   ; first 2 bits:                         XX00 0000 0000 0000
000020EA  =0000F000               1800  FILT_NIB_1              EQU         $0000F000   ; first nibble:                         XXXX 0000 0000 0000
000020EA  =00000F00               1801  FILT_NIB_2              EQU         $00000F00   ; second nibble:                        0000 XXXX 0000 0000
000020EA  =00000800               1802  FILT_BIT_5              EQU         $00000800   ; 5th bit:                              0000 X000 0000 0000
000020EA  =00000100               1803  FILT_BIT_8              EQU         $00000100   ; 8th bit:                              0000 000X 0000 0000
000020EA                          1804  
000020EA                          1805      * source/destination filters (not applicable for bidirectional operations)
000020EA  =00000E00               1806  FILT_DEST_REG           EQU         $00000E00   ; destination register:                 0000 XXX0 0000 0000
000020EA  =000001C0               1807  FILT_DEST_MD            EQU         $000001C0   ; destination mode:                     0000 000X XX00 0000
000020EA  =00000038               1808  FILT_SRC_MD             EQU         $00000038   ; source mode:                          0000 0000 00XX X000
000020EA  =00000007               1809  FILT_SRC_REG            EQU         $00000007   ; source register:                      0000 0000 0000 0XXX
000020EA                          1810  
000020EA                          1811      * move filters
000020EA  =00003000               1812  FILT_MOVE_SIZE          EQU         $00003000   ; Size of a move operation:             00XX 0000 0000 0000
000020EA  =0000FB80               1813  FILT_MOVEM              EQU         $0000FB80   ; check for a MOVEM instruction:        XXXX X0XX X000 0000
000020EA  =00000040               1814  FILT_MOVEM_SIZE         EQU         $00000040   ; Size of a MOVEM operation             0000 0000 0X00 0000
000020EA  =00000400               1815  FILT_MOVEM_DIR          EQU         $00000400   ; direction of a MOVEM operation:       0000 0X00 0000 0000
000020EA                          1816  
000020EA                          1817      * filters for BRA, BSR, BCC, and MOVEQ (the same filter, but named differently for clarity.)
000020EA  =000000FF               1818  FILT_DISPLACEMENT       EQU         $00FF       ; Displacment of branch instruction:    0000 0000 XXXX XXXX
000020EA  =000000FF               1819  FILT_MOVEQ_DATA         EQU         $00FF       ; Data of MOVEQ instruction:            0000 0000 XXXX XXXX
000020EA                          1820  
000020EA                          1821      * EXT filter
000020EA  =0000FFB8               1822  FILT_EXT                EQU         $FFB8       ; check for an EXT instruction:         XXXX XXXX X0XX X000
000020EA                          1823  
000020EA                          1824  * constants for comparing with filtered instructions. X means 'don't care' (and will be set to 0 by previous filter)
000020EA                          1825  *(These do not represent the complete insturctions.)
000020EA                          1826  *(Also note that repetition is allowed for clarity's sake, so two constants can share a value.)
000020EA                          1827      * general filters
000020EA  =00000000               1828  CONST_ALL_0             EQU         $0000    ; all 0s:                               0000 0000 0000 0000
000020EA  =00004000               1829  CONST_NIB1_0100         EQU         $4000    ; first nibble is 0100                  0100 XXXX XXXX XXXX
000020EA  =00000800               1830  CONST_NIB2_1000         EQU         $0800    ; second nibble is 1000                 XXXX 1000 XXXX XXXX
000020EA  =00000A00               1831  CONST_NIB2_1010         EQU         $0A00    ; second nibble is 1010                 XXXX 1010 XXXX XXXX
000020EA  =00000E00               1832  CONST_NIB2_1110         EQU         $0E00    ; second nibble is 1110                 XXXX 1110 XXXX XXXX
000020EA                          1833  
000020EA                          1834  * Immediate operation constants
000020EA                          1835      * ANDI
000020EA  =00000000               1836  CONST_ORI_DEST_REG      EQU         $0000    ; confirm ORI                           XXXX 000X XXXX XXXX
000020EA                          1837      * ANDI
000020EA  =00000200               1838  CONST_ANDI_DEST_REG     EQU         $0200    ; confirm ANDI                          XXXX 001X XXXX XXXX
000020EA                          1839      * SUBI
000020EA  =00000400               1840  CONST_SUBI_DEST_REG     EQU         $0400    ; confirm SUBI                          XXXX 010X XXXX XXXX
000020EA                          1841      * ADDI
000020EA  =00000600               1842  CONST_ADDI_DEST_REG     EQU         $0600    ; confirm ADDI                          XXXX 011X XXXX XXXX
000020EA                          1843      * EORI
000020EA  =00000A00               1844  CONST_EORI_DEST_REG     EQU         $0A00    ; confirm EORI                          XXXX 101X XXXX XXXX
000020EA                          1845      * CMPI
000020EA  =00000C00               1846  CONST_CMPI_DEST_REG     EQU         $0C00    ; confirm CMPI                          XXXX 110X XXXX XXXX
000020EA                          1847  
000020EA                          1848  * Constants for matching based on 2nd nibble
000020EA                          1849      *NEGX
000020EA  =00000000               1850  CONST_NEGX_OP           EQU         $0000    ; confirm NEGX                          XXXX 0000 XXXX XXXX
000020EA                          1851      *CLR
000020EA  =00000200               1852  CONST_CLR_OP            EQU         $0200    ; confirm CLR                           XXXX 0010 XXXX XXXX
000020EA                          1853      *NEG
000020EA  =00000400               1854  CONST_NEG_OP            EQU         $0400    ; confirm NEG                           XXXX 0100 XXXX XXXX
000020EA                          1855      *NOT
000020EA  =00000600               1856  CONST_NOT_OP            EQU         $0600    ; confirm NOT                           XXXX 0110 XXXX XXXX
000020EA                          1857  
000020EA                          1858  * EXT constant
000020EA  =00004880               1859  CONST_EXT               EQU         $4880    ; confirm EXT                           0100 1000 1X00 0XXX
000020EA                          1860  
000020EA                          1861  * Other constants
000020EA                          1862      * BTST,BCHG,BCLR,BSET
000020EA  =00000800               1863  CONST_B_OP              EQU         $0800    ; BTST,BCHG,BCLR,BSET                   XXXX 100X XXXX XXXX
000020EA                          1864  
000020EA                          1865      * MOVE
000020EA  =00001000               1866  CONST_MOVE_B            EQU         $1000    ; MOVE.B (use first nib)                0001 XXXX XXXX XXXX
000020EA  =00003000               1867  CONST_MOVE_W            EQU         $3000    ; MOVE.W (use first nib)                0011 XXXX XXXX XXXX
000020EA  =00002000               1868  CONST_MOVE_L            EQU         $2000    ; MOVE.L (use first nib)                0010 XXXX XXXX XXXX
000020EA                          1869  
000020EA                          1870      * MOVEQ
000020EA  =00007000               1871  CONST_MOVEQ             EQU         $7000    ; MOVEQ.L (use first nib)               0111 XXXX XXXX XXXX    
000020EA                          1872           
000020EA                          1873      * MOVEM                      
000020EA  =00004880               1874  CONST_MOVEM             EQU         $4880    ; confirm MOVEM (use FILT_MOVEM)        0100 1X00 1XXX XXXX        
000020EA  =00000000               1875  CONST_MOVEM_DIR_0       EQU         $0000    ; MOVEM list to EA direction            XXXX XXXX XXXX XXX0
000020EA  =00000001               1876  CONST_MOVEM_DIR_1       EQU         $0001    ; MOVEM EA to list direction            XXXX XXXX XXXX XXX1    
000020EA                          1877           
000020EA                          1878  * Mode/register constants
000020EA                          1879  
000020EA                          1880      * Mode values
000020EA  =00000000               1881  CONST_DATA_REG_MD       EQU         $00      ; Data register mode:     Dn            XXXX X000
000020EA  =00000001               1882  CONST_ADDR_REG_MD       EQU         $01      ; Address register mode:  An            XXXX X001
000020EA  =00000002               1883  CONST_ADDR_IND_MD       EQU         $02      ; Address indirect mode:  (An)          XXXX X010
000020EA  =00000003               1884  CONST_ADDR_INCR_MD      EQU         $03      ; Address postincr. mode: (An)+         XXXX X011
000020EA  =00000004               1885  CONST_ADDR_DECR_MD      EQU         $04      ; Address predecr. mode:  -(An)         XXXX X100
000020EA  =00000005               1886  CONST_ADDR_DISPLC_MD    EQU         $05      ; Address w/ displacement:(d16,An)      XXXX X101
000020EA  =00000006               1887  CONST_ADDR_INDEX_MD     EQU         $06      ; Address w/ index:       (d8,PC,Xn)    XXXX X110
000020EA  =00000007               1888  CONST_ADDR_MISC_MD      EQU         $07      ; Various other addressing modes        XXXX X111
000020EA                          1889  
000020EA                          1890      * Constant register values (should not be necessary for register numbers like D5)
000020EA  =00000002               1891  CONST_COUNTR_DISPLC_REG EQU         $02      ; Counter w/ displacement:(d16,PC)      XXXX X010
000020EA  =00000003               1892  CONST_COUNTR_INDEX_REG  EQU         $03      ; Counter w/ index:       (d16,PC,Xn)   XXXX X011
000020EA  =00000000               1893  CONST_ABS_SHORT_REG     EQU         $00      ; Absolute word:          (xxx).W       XXXX X000
000020EA  =00000001               1894  CONST_ABS_LONG_REG      EQU         $01      ; Absolute long:          (xxx).L       XXXX X001
000020EA  =00000004               1895  CONST_IMMEDIATE_REG     EQU         $04      ; Immediate data:         #imm          XXXX X100
000020EA                          1896  
000020EA                          1897  *full OPcode contstants
000020EA  =00004E70               1898  RESET_CODE              EQU         $4E70   ; RESET                                 0100 1110 0111 0001
000020EA  =00004E71               1899  NOP_CODE                EQU         $4E71   ; NOP                                   0100 1110 0111 0001
000020EA  =00004E72               1900  STOP_CODE               EQU         $4E72   ; STOP                                  0100 1110 0111 0010
000020EA                          1901  
000020EA                          1902    
000020EA                          1903  *############# END VARIABLES/CONSTANTS #########################
000020EA                          1904  
000020EA                          1905      END START        ; last line of source, very end of the program

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDI_FOUND          1972
ANDI_FOUND          196A
ASCII_TO_HEX        10B4
BEGIN_READ          12E2
BYTE_SIZE           0
BYTE_SIZE_M         1
BYTE_SIZE_MSG       2052
CHECK_ADDRESSING_MODES  1C52
CHECK_ADDR_IN_LIST_FLAG  183C
CHECK_CONSTANTS     134A
CHECK_DONE_READING  1308
CHECK_EXT           150C
CHECK_MISC_ADDRESSINGS  1DB8
CHECK_MOVE          14D0
CHECK_MOVEM         1522
CHECK_MOVEQ         14F6
CHECK_NIB1_0000     13CE
CHECK_NIB1_0100     13E4
CHECK_NON_CONSTANTS  13B2
CHECK_SINGLE_A_F    180C
CHECK_SINGLE_D_F    1824
CLOSE_PARENS        1E71
CLR_FOUND           1982
CMPI_FOUND          197A
COMMA               1E6B
CONFIRMED_NEXT_OP   12F6
CONFIRM_0000_XXX0   1412
CONFIRM_0100_0XXX   146C
CONFIRM_0100_1000   14C4
CONFIRM_0100_1010   14C8
CONFIRM_0100_1110   14CC
CONFIRM_0100_1XXX   149C
CONFIRM_NIB1_0000   13FA
CONFIRM_NIB1_0100   1450
CONFIRM_READ_DATA   1AE6
CONFIRM_READ_DEST_DATA  1A52
CONFIRM_READ_LEFT_DATA  1A8C
CONFIRM_READ_RIGHT_DATA  1AC6
CONFIRM_READ_SRC_DATA  1A18
CONST_ABS_LONG_REG  1
CONST_ABS_SHORT_REG  0
CONST_ADDI_DEST_REG  600
CONST_ADDR_DECR_MD  4
CONST_ADDR_DISPLC_MD  5
CONST_ADDR_INCR_MD  3
CONST_ADDR_INDEX_MD  6
CONST_ADDR_IND_MD   2
CONST_ADDR_MISC_MD  7
CONST_ADDR_REG_MD   1
CONST_ALL_0         0
CONST_ANDI_DEST_REG  200
CONST_B_OP          800
CONST_CLR_OP        200
CONST_CMPI_DEST_REG  C00
CONST_COUNTR_DISPLC_REG  2
CONST_COUNTR_INDEX_REG  3
CONST_DATA_REG_MD   0
CONST_EORI_DEST_REG  A00
CONST_EXT           4880
CONST_IMMEDIATE_REG  4
CONST_MOVEM         4880
CONST_MOVEM_DIR_0   0
CONST_MOVEM_DIR_1   1
CONST_MOVEQ         7000
CONST_MOVE_B        1000
CONST_MOVE_L        2000
CONST_MOVE_W        3000
CONST_NEGX_OP       0
CONST_NEG_OP        400
CONST_NIB1_0100     4000
CONST_NIB2_1000     800
CONST_NIB2_1010     A00
CONST_NIB2_1110     E00
CONST_NOT_OP        600
CONST_ORI_DEST_REG  0
CONST_SUBI_DEST_REG  400
CONVERSION_DONE     12B0
COUNT_INPUT_DIGITS  1046
CR                  D
CURRENT_DATA        20DC
CURRENT_DEST_DATA   20E4
CURRENT_DEST_MD     20D9
CURRENT_DEST_REG    20DA
CURRENT_DIRECTION   20D4
CURRENT_EA_MD       20D2
CURRENT_EA_REG      20D3
CURRENT_L_DATA      20C8
CURRENT_L_MD        20C5
CURRENT_L_REG       20C6
CURRENT_MASK_FIELD  20E8
CURRENT_MD          20D5
CURRENT_OP_SIZE     20C4
CURRENT_REG         20D6
CURRENT_R_DATA      20CE
CURRENT_R_MD        20CC
CURRENT_R_REG       20CD
CURRENT_SRC_DATA    20E0
CURRENT_SRC_MD      20D7
CURRENT_SRC_REG     20D8
CURRENT_WORD        20C2
DIG_CONV_DONE_1     10DE
DIG_CONV_DONE_2     1112
DIG_CONV_DONE_3     114A
DIG_CONV_DONE_4     1182
DIG_CONV_DONE_5     11BA
DIG_CONV_DONE_6     11F2
DIG_CONV_DONE_7     122A
DIG_CONV_DONE_8     1262
DISPLAY_ABS_LONG    1E1A
DISPLAY_ABS_SHORT   1DFA
DISPLAY_ADDR_DECR   1D70
DISPLAY_ADDR_DISPLC  1DB4
DISPLAY_ADDR_INCR   1D2C
DISPLAY_ADDR_IND    1CF4
DISPLAY_ADDR_INDEX  1DB6
DISPLAY_ADDR_REG    1CD4
DISPLAY_BUFFER      20B8
DISPLAY_COUNTR_DISPLC  1DF6
DISPLAY_COUNTR_INDEX  1DF8
DISPLAY_CURRENT_ADDRESS  1324
DISPLAY_DATA_REG    1CB4
DISPLAY_DEST        1BB0
DISPLAY_IMMEDIATE   1E3A
DISPLAY_LEFT        1BE6
DISPLAY_MOVEM_DATA  179E
DISPLAY_MOVEM_DIR_0  17AE
DISPLAY_MOVEM_DIR_1  17D0
DISPLAY_MOVEM_LIST  17F2
DISPLAY_MOVEM_LIST_FWD  1802
DISPLAY_MOVEM_LIST_REV  195E
DISPLAY_MOVEQ_DATA  1656
DISPLAY_MOVE_DATA   15E2
DISPLAY_RIGHT       1C1C
DISPLAY_SLASH       1908
DISPLAY_SOURCE      1B7A
DISP_MM_F_END_A     18D8
DISP_MM_F_END_D     1934
DISP_MM_F_START_A   18B6
DISP_MM_F_START_D   1918
DOLLAR              1E69
DONE_READING        1310
DONE_READING_MSG    2036
END_ADDR            9000
END_ADDR_MSG        1EAD
EORI_FOUND          1976
EXT_FOUND           1692
FILT_2BIT_1         C000
FILT_BIT_5          800
FILT_BIT_8          100
FILT_DEST_MD        1C0
FILT_DEST_REG       E00
FILT_DISPLACEMENT   FF
FILT_EXT            FFB8
FILT_MOVEM          FB80
FILT_MOVEM_DIR      400
FILT_MOVEM_SIZE     40
FILT_MOVEQ_DATA     FF
FILT_MOVE_SIZE      3000
FILT_NIB_1          F000
FILT_NIB_2          F00
FILT_SRC_MD         38
FILT_SRC_REG        7
FIND_MM_F_END_A     186A
FIND_MM_F_END_A_LOOP  186E
FIND_MM_F_END_D     18A0
FIND_MM_F_END_D_LOOP  18A4
FIND_MM_F_START_A   1848
FIND_MM_F_START_A_LOOP  1858
FIND_MM_F_START_D   187E
FIND_MM_F_START_D_LOOP  1890
GO_TO_NEXT_OP       12F2
HASH                1E6D
INPUTTING_START     1
INVALID_ADDR_HIGH   12A0
INVALID_ADDR_H_MSG  1FF5
INVALID_ADDR_INPUT  1270
INVALID_ADDR_LOW    1290
INVALID_ADDR_L_MSG  1FB5
INVALID_ADDR_MSG    1F2E
INVALID_END_ADDR    1280
INVALID_END_ADDR_MSG  1F64
INVALID_LEN_MSG     1EE0
LF                  A
LONG_SIZE           2
LONG_SIZE_M         2
LONG_SIZE_MOVEM     1
LONG_SIZE_MSG       2058
MAX_ADDRESS         FFF0000
MINUS               1E75
MIN_ADDRESS         3000
MOVEM_FOUND         1696
MOVEM_LIST_DISPLAY_DONE  1964
MOVEM_L_FOUND       16E0
MOVEM_L_MSG         2092
MOVEM_W_FOUND       16B4
MOVEM_W_MSG         208A
MOVEQ_FOUND         1604
MOVEQ_MSG           2084
MOVE_B_FOUND        1538
MOVE_B_MSG          206F
MOVE_L_FOUND        1598
MOVE_L_MSG          207D
MOVE_MSG            206A
MOVE_W_FOUND        1568
MOVE_W_MSG          2076
MSG_A               209C
MSG_D               209A
NEGX_FOUND          197E
NEG_FOUND           1986
NEXT_ADDR           7000
NOP_CODE            4E71
NOP_FOUND           1390
NOP_MSG             2061
NOT_FOUND           198A
OPCODE_BUFFER       20B2
OPEN_PARENS         1E6F
ORI_FOUND           1966
PARSE_MOVEM_DATA    170C
PARSE_MOVEM_DIR_0   1754
PARSE_MOVEM_DIR_1   1772
PARSE_MOVEM_MASK_FIELD  1790
PARSE_MOVEQ_DATA    1634
PARSE_MOVE_DATA     15C8
PLUS                1E73
PREPARE_DISPLAY     12EE
PROMPT_INPUT        1008
READ_ABS_LONG_DATA  1B30
READ_ABS_SHORT_DATA  1B28
READ_COUNTR_DISPLC_DATA  1B24
READ_COUNTR_INDEX_DATA  1B26
READ_CURRENT_OP     1320
READ_DEST_DATA      1A38
READ_DEST_MODE      19AC
READ_DEST_REG       198E
READ_IMMEDIATE_DATA  1B38
READ_IMMEDIATE_DATA_L  1B6C
READ_IMMEDIATE_DATA_W  1B5E
READ_LEFT_DATA      1A72
READ_MOVEM_DIR      173C
READ_MOVEQ_DATA     1678
READ_RIGHT_DATA     1AAC
READ_SOURCE_DATA    19FE
READ_SOURCE_MODE    19C8
READ_SOURCE_REG     19E4
RESET_CODE          4E70
RESET_FOUND         1372
RESET_MSG           205B
RETURN              1E64
SET_END_ADDR        12D8
SET_START_ADDR      12D2
SIZE_BUFFER         20B6
SLASH               1E77
SPACE               1E67
START               1000
START_ADDR_IN       209E
START_ADDR_MSG      1E79
STOP                1004
STOP_CODE           4E72
STOP_FOUND          13AE
STOP_MSG            2065
SUBI_FOUND          196E
TAKE_USER_INPUT     1034
TAKE_USER_IN_E      1020
TAKE_USER_IN_S      100C
TEST_ORIGIN         7000
VALID_ADDR          12C6
WORD_SIZE           1
WORD_SIZE_M         3
WORD_SIZE_MOVEM     0
WORD_SIZE_MSG       2055
