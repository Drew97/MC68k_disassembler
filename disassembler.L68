00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.14.00
Created On: 2/22/2014 7:02:34 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Disassembler
00000000                             3  * Written by : Robert Brandenburg, Danielle Jenkins, Shahin Nahar
00000000                             4  * Date       : 2/13/14
00000000                             5  * Description: Disassemble hex machine code instructions into 68K instructions
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8  * TODO: write disassembler
00000000                             9  * TODO: more specific TODOs for our plan
00000000                            10  * TODO: comments saying who is working where
00000000                            11  
00000000                            12  
00000000                            13  * Commenting Key: 
00000000                            14  *    "----------"  <-- subroutine commenting
00000000                            15  *    "##########"  <-- section/role commenting
00000000                            16  
00000000                            17  * Notes on saving registers on run:
00000000                            18  *    MOVEM.L A0-A3/D0-D7, -(A7) * copies all working registers to stack
00000000                            19  *    MOVEM.L (A7)+, A0-A3/D0-D7 *Restore the registers
00000000                            20  
00000000                            21  * Notes on AND filters (bit masking):
00000000                            22  * Example:
00000000                            23  *       0001 000 001 111 100   (say you want "001")
00000000                            24  *   AND 0000 000 111 000 000   (0 <-- don't want, 1 <-- do want)
00000000                            25  *       --------------------
00000000                            26  *     = 0000 000 001 000 000
00000000                            27  *
00000000                            28  * Relevant wiki page:
00000000                            29  *   https://en.wikipedia.org/wiki/Mask_(computing)#Masking_bits_to_0
00000000                            30  *
00000000                            31  *################ TODO LIST ################################
00000000                            32  *----------------OPcode TODOS (ROBERT)-----------------------------
00000000                            33  * Implement a method to reverse the mask words for MOVEM commands with -(An).
00000000                            34  * This means no need for special reverse reading methods in this case.
00000000                            35  
00000000                            36  * Fix the current bugs with MOVEs performed on absolute addresses. Not sure why these errors occur.
00000000                            37  *   -consult the bug report before trying to debug.
00000000                            38  * Continue decoding OPcodes in the following order: (with sizes)
00000000                            39  *   NOTE: I will delete OPcodes from this list as I implement them.
00000000                            40  
00000000                            41  *   -ADD    (B,W,L) (will need shahin's size filter for this and below)
00000000                            42  *   -ADDA   (W,L)
00000000                            43  *   -ADDI   (B,W,L)
00000000                            44  *   -SUB    (B,W,L)
00000000                            45  *   -SUBA   (W,L)
00000000                            46  
00000000                            47  *   -SUBQ   (B,W,L)
00000000                            48  *   -MULS   (W)     (not MULU?)
00000000                            49  *   -DIVU   (W      (not DIVU?)
00000000                            50  *   -LEA    (?)
00000000                            51  *   -CLR    (B,W,L)
00000000                            52  
00000000                            53  *   -AND    (B,W,L)
00000000                            54  *   -ANDI   (B,W,L)
00000000                            55  *   -EOR    (B,W,L)
00000000                            56  *   -EORI   (B,W,L)
00000000                            57  *   -ASR    (B,W,L) (no ASL?)
00000000                            58  
00000000                            59  *   -LSL    (B,W,L) (no LSR?)
00000000                            60  *   -ROL    (B,W,L)
00000000                            61  *   -ROR    (B,W,L)
00000000                            62  *   -BCHG   (?)
00000000                            63  *   -CMP    (B,W,L)
00000000                            64  
00000000                            65  *   -CMPA   (W,L)
00000000                            66  *   -CMPI   (B,W,L)
00000000                            67  *   -JSR    (N/A)
00000000                            68  
00000000                            69  *   (add others if we have time)
00000000                            70  *
00000000                            71  *----------------I/O TODOS (DANIELLE)-----------------------------
00000000                            72  * (TODOs for I/O go here.)
00000000                            73  *----------------EA TODOS  (SHAHIN)-----------------------------
00000000                            74  * (TODOs for EA go here.)
00000000                            75  *################ BEGIN MAIN ###############################
00000000                            76  *** All subroutine calls are made here ***
00001000                            77  START                   ORG        $1000       ; first instruction of program
00001000  6000 0006                 78                          BRA        PROMPT_INPUT            ; prompt the user for input
00001004                            79                   
00001004  4E72 2700                 80  STOP                    STOP       #$2700          ; halt simulator, end of main
00001008                            81  
00001008                            82  *################ END MAIN ###############################
00001008                            83  *################ BEGIN IO ###############################
00001008                            84  *** IO Subroutines are kept here ***
00001008                            85  
00001008                            86  *-------------------- Print ASCII logo ----------------------
00001008  6000 0002                 87  PROMPT_INPUT            BRA         TAKE_USER_IN_S ;TODO: change to welcome/ASCII logo
0000100C                            88  *------------------- Prompt user for input -------------------
0000100C                            89  
0000100C                            90                  
0000100C  163C 0001                 91  TAKE_USER_IN_S          MOVE.B      #1,D3
00001010  43F9 00001FCF             92                          LEA         START_ADDR_MSG,A1  ; Prompt user for starting address
00001016  103C 000E                 93                          MOVE.B      #14,D0
0000101A  4E4F                      94                          TRAP        #15
0000101C                            95  
0000101C  6000 0016                 96                          BRA         TAKE_USER_INPUT
00001020                            97  
00001020  163C 0000                 98  TAKE_USER_IN_E          MOVE.B      #0,D3
00001024  43F9 00002003             99                          LEA         END_ADDR_MSG,A1  ; prompt user for ending address
0000102A  103C 000E                100                          MOVE.B      #14,D0
0000102E  4E4F                     101                          TRAP        #15
00001030                           102                          
00001030  6000 0002                103                          BRA         TAKE_USER_INPUT
00001034                           104                          
00001034  7200                     105  TAKE_USER_INPUT         MOVE.L      #$00000000,D1   ; need to clear out the data registers we are about to use to avoid junk data.   
00001036  7A00                     106                          MOVE.L      #$00000000,D5    
00001038  7C00                     107                          MOVE.L      #$00000000,D6
0000103A  7E00                     108                          MOVE.L      #$00000000,D7
0000103C                           109  
0000103C  103C 0002                110                          MOVE.B      #2,D0           ; Take user input for next address.
00001040  327C 3000                111                          MOVEA.W     #$3000,A1       ; Store the ascii input in A1,(note that we might not want to use 3000 here)
00001044  4E4F                     112                          TRAP        #15             ; and the length in D1.W.  
00001046                           113  
00001046  327C 3001                114  COUNT_INPUT_DIGITS      MOVEA.W     #$3001,A1
0000104A  B27C 0001                115                          CMP         #1,D1
0000104E  6700 0064                116                          BEQ         ASCII_TO_HEX  ;start converting if we have 1 digit.
00001052                           117            
00001052  327C 3002                118                          MOVEA.W     #$3002,A1
00001056  B27C 0002                119                          CMP         #2,D1
0000105A  6700 0058                120                          BEQ         ASCII_TO_HEX  ;start converting if we have 2 digits.
0000105E                           121            
0000105E  327C 3003                122                          MOVEA.W     #$3003,A1
00001062  B27C 0003                123                          CMP         #3,D1
00001066  6700 004C                124                          BEQ         ASCII_TO_HEX  ;start converting if we have 3 digits.
0000106A                           125            
0000106A  327C 3004                126                          MOVEA.W     #$3004,A1
0000106E  B27C 0004                127                          CMP         #4,D1
00001072  6700 0040                128                          BEQ         ASCII_TO_HEX  ;start converting if we have 4 digits.
00001076                           129            
00001076  327C 3005                130                          MOVEA.W     #$3005,A1
0000107A  B27C 0005                131                          CMP         #5,D1
0000107E  6700 0034                132                          BEQ         ASCII_TO_HEX  ;start converting if we have 5 digits.
00001082                           133            
00001082  327C 3006                134                          MOVEA.W     #$3006,A1
00001086  B27C 0006                135                          CMP         #6,D1
0000108A  6700 0028                136                          BEQ         ASCII_TO_HEX  ;start converting if we have 6 digits.
0000108E                           137            
0000108E  327C 3007                138                          MOVEA.W     #$3007,A1
00001092  B27C 0007                139                          CMP         #7,D1
00001096  6700 001C                140                          BEQ         ASCII_TO_HEX  ;start converting if we have 7 digits.
0000109A                           141            
0000109A  327C 3008                142                          MOVEA.W     #$3008,A1
0000109E  B27C 0008                143                          CMP         #8,D1
000010A2  6700 0010                144                          BEQ         ASCII_TO_HEX  ;start converting if we have 8 digits.
000010A6                           145            
000010A6  43F9 00002036            146                          LEA         INVALID_LEN_MSG,A1         ; If we get an invalid length, give and error message and... branch back asking user for input again
000010AC  103C 000E                147                          MOVE.B      #14,D0
000010B0  4E4F                     148                          TRAP        #15
000010B2                           149  
000010B2  6780                     150                          BEQ         TAKE_USER_INPUT               
000010B4                           151  
000010B4                           152  
000010B4                           153  
000010B4                           154  *------------------- Convert to hex subroutine -------------------
000010B4                           155  
000010B4  7C00                     156  ASCII_TO_HEX            MOVE.L      #$00000000,D6      ; running total of converted hex number
000010B6                           157                  
000010B6                           158                          ;first digit
000010B6  1A21                     159                          MOVE.B      -(A1),D5  ; Move the raw ascii value of first digit into 3007.
000010B8  BA7C 0030                160                          CMP         #$30,D5
000010BC  6D00 01B2                161                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
000010C0  BA7C 0040                162                          CMP         #$40,D5
000010C4  6700 01AA                163                          BEQ         INVALID_ADDR_INPUT
000010C8  BA7C 0046                164                          CMP         #$46,D5
000010CC  6E00 01A2                165                          BGT         INVALID_ADDR_INPUT   
000010D0                           166                          ; Convert ascii to hex for that digit.
000010D0  0445 0030                167                          SUB         #$30,D5   ;
000010D4  BA7C 000A                168                          CMP         #$A,D5
000010D8  6D00 0004                169                          BLT         DIG_CONV_DONE_1 ; Necessary to convert some ASCII values.
000010DC  5F05                     170                          SUB.B       #7, D5                      ; TODO: errors for invalid ASCII values.
000010DE                           171                  
000010DE  DC45                     172  DIG_CONV_DONE_1         ADD.W       D5,D6
000010E0  B27C 0001                173                          CMP         #1,D1
000010E4  6700 01CA                174                          BEQ         CONVERSION_DONE
000010E8                           175                  
000010E8                           176                          ;second digit
000010E8  7A00                     177                          MOVE.L      #$00000000,D5
000010EA  1A21                     178                          MOVE.B      -(A1),D5
000010EC  BA7C 0030                179                          CMP         #$30,D5
000010F0  6D00 017E                180                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
000010F4  BA7C 0040                181                          CMP         #$40,D5
000010F8  6700 0176                182                          BEQ         INVALID_ADDR_INPUT
000010FC  BA7C 0046                183                          CMP         #$46,D5
00001100  6E00 016E                184                          BGT         INVALID_ADDR_INPUT   
00001104  0445 0030                185                          SUB         #$30,D5
00001108  BA7C 000A                186                          CMP         #$A,D5            
0000110C  6D00 0004                187                          BLT         DIG_CONV_DONE_2    ;digit conversion done 1
00001110  5F05                     188                          SUB.B       #7, D5             ; if we have A or greater, then we need to subtract 1.
00001112                           189               
00001112  CAFC 0010                190  DIG_CONV_DONE_2         MULU.W      #$00000010,D5  ; this part adds $10 * (2nd digit) to our running total.
00001116  DC45                     191                          ADD.W       D5,D6 
00001118                           192                    
00001118  B27C 0002                193                          CMP         #2,D1
0000111C  6700 0192                194                          BEQ         CONVERSION_DONE
00001120                           195                  
00001120                           196                          ;third digit
00001120  7A00                     197                          MOVE.L      #$00000000,D5
00001122  1A21                     198                          MOVE.B      -(A1),D5
00001124  BA7C 0030                199                          CMP         #$30,D5
00001128  6D00 0146                200                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
0000112C  BA7C 0040                201                          CMP         #$40,D5
00001130  6700 013E                202                          BEQ         INVALID_ADDR_INPUT
00001134  BA7C 0046                203                          CMP         #$46,D5
00001138  6E00 0136                204                          BGT         INVALID_ADDR_INPUT   
0000113C  0445 0030                205                          SUB         #$30,D5
00001140  BA7C 000A                206                          CMP         #$A,D5
00001144  6D00 0004                207                          BLT         DIG_CONV_DONE_3 
00001148  5F05                     208                          SUB.B       #7, D5
0000114A                           209                  
0000114A  CAFC 0100                210  DIG_CONV_DONE_3         MULU.W      #$00000100,D5
0000114E  DC45                     211                          ADD.W       D5,D6 
00001150                           212      
00001150  B27C 0003                213                          CMP         #3,D1
00001154  6700 015A                214                          BEQ         CONVERSION_DONE
00001158                           215                  
00001158                           216                          ;fourth digit
00001158  7A00                     217                          MOVE.L      #$00000000,D5
0000115A  1A21                     218                          MOVE.B      -(A1),D5
0000115C  BA7C 0030                219                          CMP         #$30,D5
00001160  6D00 010E                220                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
00001164  BA7C 0040                221                          CMP         #$40,D5
00001168  6700 0106                222                          BEQ         INVALID_ADDR_INPUT
0000116C  BA7C 0046                223                          CMP         #$46,D5
00001170  6E00 00FE                224                          BGT         INVALID_ADDR_INPUT   
00001174  0445 0030                225                          SUB         #$30,D5
00001178  BA7C 000A                226                          CMP         #$A,D5
0000117C  6D00 0004                227                          BLT         DIG_CONV_DONE_4
00001180  5F05                     228                          SUB.B       #7,D5
00001182                           229                  
00001182  CAFC 1000                230  DIG_CONV_DONE_4         MULU.W      #$00001000,D5
00001186  DC45                     231                          ADD.W       D5,D6 
00001188                           232      
00001188  B27C 0004                233                          CMP         #4,D1
0000118C  6700 0122                234                          BEQ         CONVERSION_DONE
00001190                           235                  
00001190                           236                          ;fifth digit
00001190  7A00                     237                          MOVE.L      #$00000000,D5
00001192  1A21                     238                          MOVE.B      -(A1),D5
00001194  BA7C 0030                239                          CMP         #$30,D5
00001198  6D00 00D6                240                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
0000119C  BA7C 0040                241                          CMP         #$40,D5
000011A0  6700 00CE                242                          BEQ         INVALID_ADDR_INPUT
000011A4  BA7C 0046                243                          CMP         #$46,D5
000011A8  6E00 00C6                244                          BGT         INVALID_ADDR_INPUT   
000011AC  0445 0030                245                          SUB         #$30,D5
000011B0  BA7C 000A                246                          CMP         #$A,D5
000011B4  6D00 0004                247                          BLT         DIG_CONV_DONE_5
000011B8  5F05                     248                          SUB.B       #$7, D5
000011BA                           249                  
000011BA  CAFC 0001                250  DIG_CONV_DONE_5         MULU.W      #$0001,D5
000011BE  DE45                     251                          ADD.W       D5,D7 
000011C0                           252  
000011C0  B27C 0005                253                          CMP         #5,D1
000011C4  6700 00EA                254                          BEQ         CONVERSION_DONE
000011C8                           255                  
000011C8                           256                          ;sixth digit
000011C8  7A00                     257                          MOVE.L      #$00000000,D5
000011CA  1A21                     258                          MOVE.B      -(A1),D5
000011CC  BA7C 0030                259                          CMP         #$30,D5
000011D0  6D00 009E                260                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
000011D4  BA7C 0040                261                          CMP         #$40,D5
000011D8  6700 0096                262                          BEQ         INVALID_ADDR_INPUT
000011DC  BA7C 0046                263                          CMP         #$46,D5
000011E0  6E00 008E                264                          BGT         INVALID_ADDR_INPUT   
000011E4  0445 0030                265                          SUB         #$30,D5
000011E8  BA7C 000A                266                          CMP         #$A,D5
000011EC  6D00 0004                267                          BLT         DIG_CONV_DONE_6
000011F0  5F05                     268                          SUB.B       #$7, D5
000011F2                           269                  
000011F2  CAFC 0010                270  DIG_CONV_DONE_6         MULU.W      #$0010,D5
000011F6  DE45                     271                          ADD.W       D5,D7
000011F8                           272      
000011F8  B27C 0006                273                          CMP         #6,D1
000011FC  6700 00B2                274                          BEQ         CONVERSION_DONE
00001200                           275                  
00001200                           276                          ;seventh digit
00001200  7A00                     277                          MOVE.L      #$00000000,D5
00001202  1A21                     278                          MOVE.B      -(A1),D5
00001204  BA7C 0030                279                          CMP         #$30,D5
00001208  6D00 0066                280                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
0000120C  BA7C 0040                281                          CMP         #$40,D5
00001210  6700 005E                282                          BEQ         INVALID_ADDR_INPUT
00001214  BA7C 0046                283                          CMP         #$46,D5
00001218  6E00 0056                284                          BGT         INVALID_ADDR_INPUT   
0000121C  0445 0030                285                          SUB         #$30,D5
00001220  BA7C 000A                286                          CMP         #$A,D5
00001224  6D00 0004                287                          BLT         DIG_CONV_DONE_7
00001228  5F05                     288                          SUB.B       #7, D5
0000122A                           289                  
0000122A  CAFC 0100                290  DIG_CONV_DONE_7         MULU.W      #$0100,D5
0000122E  DE45                     291                          ADD.W       D5,D7
00001230                           292      
00001230  B27C 0007                293                          CMP         #7,D1
00001234  6700 007A                294                          BEQ         CONVERSION_DONE
00001238                           295                  
00001238                           296                          ;eighth digit
00001238  7A00                     297                          MOVE.L      #$00000000,D5
0000123A  1A21                     298                          MOVE.B      -(A1),D5
0000123C  BA7C 0030                299                          CMP         #$30,D5
00001240  6D00 002E                300                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
00001244  BA7C 0040                301                          CMP         #$40,D5
00001248  6700 0026                302                          BEQ         INVALID_ADDR_INPUT
0000124C  BA7C 0046                303                          CMP         #$46,D5
00001250  6E00 001E                304                          BGT         INVALID_ADDR_INPUT   
00001254  0445 0030                305                          SUB         #$30,D5
00001258  BA7C 000A                306                          CMP         #$A,D5
0000125C  6D00 0004                307                          BLT         DIG_CONV_DONE_8
00001260  5F05                     308                          SUB.B       #7, D5
00001262                           309                  
00001262  CAFC 1000                310  DIG_CONV_DONE_8         MULU.W      #$1000,D5
00001266  DE45                     311                          ADD.W       D5,D7
00001268                           312      
00001268  B27C 0008                313                          CMP         #8,D1
0000126C  6700 0042                314                          BEQ         CONVERSION_DONE    ;the input was valid and we are done with the conversion
00001270                           315                  
00001270  43F9 00002084            316  INVALID_ADDR_INPUT      LEA         INVALID_ADDR_MSG,A1    ;tell the user the address was invalid and prompt input again.
00001276  103C 000E                317                          MOVE.B      #14,D0
0000127A  4E4F                     318                          TRAP        #15
0000127C                           319                          
0000127C  6000 FDB6                320                          BRA         TAKE_USER_INPUT
00001280                           321                          
00001280  43F9 000020BA            322  INVALID_END_ADDR        LEA         INVALID_END_ADDR_MSG,A1
00001286  103C 000E                323                          MOVE.B      #14,D0
0000128A  4E4F                     324                          TRAP        #15
0000128C                           325                          
0000128C  6000 FDA6                326                          BRA         TAKE_USER_INPUT
00001290                           327                          
00001290  43F9 0000210B            328  INVALID_ADDR_LOW        LEA         INVALID_ADDR_L_MSG,A1    ;tell the user the address was invalid and prompt input again.
00001296  103C 000E                329                          MOVE.B      #14,D0
0000129A  4E4F                     330                          TRAP        #15
0000129C                           331                          
0000129C  6000 FD96                332                          BRA         TAKE_USER_INPUT
000012A0                           333  
000012A0  43F9 0000214B            334  INVALID_ADDR_HIGH       LEA         INVALID_ADDR_H_MSG,A1    ;tell the user the address was invalid and prompt input again.
000012A6  103C 000E                335                          MOVE.B      #14,D0
000012AA  4E4F                     336                          TRAP        #15
000012AC                           337                          
000012AC  6000 FD86                338                          BRA         TAKE_USER_INPUT
000012B0                           339                 
000012B0  E18F                     340  CONVERSION_DONE         LSL.L       #8,D7   ; Prepare for concatenation
000012B2  E18F                     341                          LSL.L       #8,D7   ; Got to perform the same operation twice to get it all the way to the left
000012B4  DE46                     342                          ADD.W       D6,D7  ; concatenate the two data registers into one value
000012B6                           343                          
000012B6  BEBC 00004000            344                          CMP.L       #MIN_ADDRESS,D7
000012BC  6DD2                     345                          BLT         INVALID_ADDR_LOW ;Not a valid address-- too low.
000012BE                           346                          
000012BE  BEBC 0FFF0000            347                          CMP.L       #MAX_ADDRESS,D7
000012C4  6EDA                     348                          BGT         INVALID_ADDR_HIGH  ;Not a valid address-- too high.
000012C6                           349                          
000012C6  0C43 0001                350  VALID_ADDR              CMPI        #1,D3
000012CA                           351                          
000012CA  6700 0006                352                          BEQ         SET_START_ADDR
000012CE  6000 0008                353                          BRA         SET_END_ADDR              
000012D2                           354                                                 
000012D2  2A47                     355  SET_START_ADDR          MOVEA.L     D7,A5  ;when a valid start address is inputted, store and ask the user for an end address.
000012D4  6000 FD4A                356                          BRA         TAKE_USER_IN_E
000012D8                           357  
000012D8  BE8D                     358  SET_END_ADDR            CMP.L       A5,D7    ;if end address is lower than start address, we get an error.
000012DA  6DA4                     359                          BLT         INVALID_END_ADDR           
000012DC                           360                          
000012DC  2C47                     361                          MOVEA.L     D7,A6  ;when a valid start address is inputted, store and ask the user for an end address.
000012DE  6000 0002                362                          BRA         BEGIN_READ
000012E2                           363                          
000012E2  284D                     364  BEGIN_READ              MOVEA.L      A5,A4 ; keep track of address to print with A4. TODO: could also add this value to the display buffer.
000012E4  33DD 00002218            365                          MOVE.W      (A5)+,CURRENT_WORD ;look at the first instruction word at the starting address.
000012EA  6000 0002                366                          BRA         PREPARE_DISPLAY
000012EE                           367  
000012EE                           368  *------------------- Add to display buffer -------------------
000012EE                           369  ;At this point A5 is a valid start address and A6 is a valid end address.
000012EE                           370  ;TODO: prepare the display buffer
000012EE  6000 0030                371  PREPARE_DISPLAY         BRA         READ_CURRENT_OP    ;TEMP (though we might still call this after the display buffer is prepared)                       
000012F2                           372                 
000012F2                           373  *------------------- Move address pointer for data reading -------------------
000012F2                           374  ; This method is specifically for reading the next OPword.
000012F2  6000 0014                375  GO_TO_NEXT_OP           BRA         CHECK_DONE_READING
000012F6                           376                           
000012F6  4279 00002218            377  CONFIRMED_NEXT_OP       CLR         CURRENT_WORD
000012FC  284D                     378                          MOVEA.L     A5,A4 ; keep track of address to print with A4. 
000012FE  33DD 00002218            379                          MOVE.W      (A5)+,CURRENT_WORD
00001304  6000 001A                380                          BRA         READ_CURRENT_OP
00001308                           381                          
00001308                           382  *------------------- Print display buffer -------------------
00001308                           383  
00001308                           384  ;TODO
00001308                           385  
00001308                           386  *------------------- Check if end of data -------------------
00001308  BACE                     387  CHECK_DONE_READING      CMPA        A6,A5       ; TODO: this comparison is not sufficient, because it will say that $8000 is less than $7000 (since $8000 is negative.)
0000130A  6DEA                     388                          BLT         CONFIRMED_NEXT_OP
0000130C  6000 0002                389                          BRA         DONE_READING
00001310                           390                          
00001310                           391  *------------------- Confirm end of data -------------------
00001310  43F9 0000218C            392  DONE_READING            LEA         DONE_READING_MSG,A1 ; when we reach the end address, say so and halt the program. TODO: ask user whether we want to read the data again.
00001316  103C 000E                393                          MOVE.B      #14,D0
0000131A  4E4F                     394                          TRAP        #15
0000131C  4EF8 1004                395                          JMP         STOP
00001320                           396                          
00001320                           397  *################## END IO  #####################################
00001320                           398  *################## BEGIN OPCODE ##########################
00001320                           399  *** OPcode Subroutines are kept here ***
00001320                           400  
00001320                           401  ; planned process for reading hex instructions:
00001320                           402          ; NOTE: this process is tentative and subject to change as OPcode person implements. 
00001320                           403                  ;           1) Go to start of instruction reading loop, passing in the address of next instruction.
00001320                           404                  ;           2) Store a word (16 bits) from that address.
00001320                           405                  ;           3) Read the first 4 bits of the word using a filter.
00001320                           406                  ;           4) branch to one of the following paths based on these bits:
00001320                           407                  ;               a) 0000: Read the next 3 bits (i.e., the destination mode). Branch:
00001320                           408                  ;                   i.   000: Read the bits at 0000 0000 XXXX XXXX (may want to make this filter) Branch:
00001320                           409                  ;                       1) 00 111 100: ORI TO CCR (need to read data, I think)
00001320                           410                  ;                       2) 01 111 100: ORI TO SR (need to read data, I think)
00001320                           411                  ;                       3) (default) ORI. Now, read and store:
00001320                           412                  ;                           SIZE:       0000 0000 XX00 0000 (need to make this filter)
00001320                           413                  ;                           MODE:       0000 0000 00XX X000 (need to make this filter)
00001320                           414                  ;                           REGISTER:   0000 0000 0000 0XXX (need to make this filter)
00001320                           415                  ;                           only mandatory additional data is the immediate data.
00001320                           416                  ;                   ii.  001: Read the bits at 0000 0000 XXXX XXXX (may want to make this filter) Branch:
00001320                           417                  ;                       1) 00 111 100: ANDI TO CCR (need to read data, I think)
00001320                           418                  ;                       2) 01 111 100: ANDI TO SR (need to read data, I think)
00001320                           419                  ;                       3) (default) ANDI. Now, read and store:
00001320                           420                  ;                           SIZE:       0000 0000 XX00 0000 (need to make this filter)
00001320                           421                  ;                           MODE:       0000 0000 00XX X000 (need to make this filter)
00001320                           422                  ;                           REGISTER:   0000 0000 0000 0XXX (need to make this filter)
00001320                           423                  ;                           only mandatory additional data is the immediate data.
00001320                           424                  ;                   iii. 101: Read the bits at 0000 0000 XXXX XXXX (may want to make this filter) Branch:
00001320                           425                  ;                       1) 00 111 100: EORI TO CCR (need to read data, I think)
00001320                           426                  ;                       2) 01 111 100: EORI TO SR (need to read data, I think)
00001320                           427                  ;                       3) (default) EORI. Now, read and store:
00001320                           428                  ;                           SIZE:       0000 0000 XX00 0000 (need to make this filter)
00001320                           429                  ;                           MODE:       0000 0000 00XX X000 (FILT_SRC_MODE)
00001320                           430                  ;                           REGISTER:   0000 0000 0000 0XXX (FILT_SRC_REG)
00001320                           431                  ;                           only mandatory additional data is the immediate data.
00001320                           432                  ;                   iv.  011: ADDI. Now read and store:
00001320                           433                  ;                           SIZE:       0000 0000 XX00 0000 (need to make this filter)
00001320                           434                  ;                           MODE:       0000 0000 00XX X000 (FILT_SRC_MODE)
00001320                           435                  ;                           REGISTER:   0000 0000 0000 0XXX (FILT_SRC_REG)
00001320                           436                  ;                           only mandatory additional data is the immediate data.
00001320                           437                  ;                   v.   010: SUBI. Now read and store:
00001320                           438                  ;                           SIZE:       0000 0000 XX00 0000 (need to make this filter)
00001320                           439                  ;                           MODE:       0000 0000 00XX X000 (FILT_SRC_MODE)
00001320                           440                  ;                           REGISTER:   0000 0000 0000 0XXX (FILT_SRC_REG)
00001320                           441                  ;                           only mandatory additional data is the immediate data.
00001320                           442                  ;                   vi.  110: CMPI. Now read and store:
00001320                           443                  ;                           SIZE:       0000 0000 XX00 0000 (need to make this filter)
00001320                           444                  ;                           MODE:       0000 0000 00XX X000 (FILT_SRC_MODE)
00001320                           445                  ;                           REGISTER:   0000 0000 0000 0XXX (FILT_SRC_REG)
00001320                           446                  ;                           only mandatory additional data is the immediate data.
00001320                           447                  ;                   vii. 100: BTST, BCHG, BCLR, BSET (TODO: expand this section if we need these OPcodes)
00001320                           448                  ;                   viii.(default): BTST, BCHG, BCLR, BSET (with data register)(TODO: expand this section if we need these OPcodes)
00001320                           449                  ;               b) 0001: (MOVE.B). Now read and store:
00001320                           450                  ;                           DESTINATION REGISTER: 0000 XXX0 0000 0000 (FILT_DEST_REG)
00001320                           451                  ;                           DESTINATION MODE:     0000 000X XX00 0000 (FILT_DEST_MODE)
00001320                           452                  ;                           SOURCE MODE:          0000 0000 00XX X000 (FILT_SCR_MODE)
00001320                           453                  ;                           SOURCE REGISTER:      0000 0000 0000 0XXX (FILT_SRC_REG)
00001320                           454                  ;                           The modes (and maybe register) will tell us whether we need to read additional data for this MOVE.
00001320                           455                  ;               c) 0011: (MOVE.W). Now read and store:
00001320                           456                  ;                           DESTINATION REGISTER: 0000 XXX0 0000 0000 (FILT_DEST_REG)
00001320                           457                  ;                           DESTINATION MODE:     0000 000X XX00 0000 (FILT_DEST_MODE)
00001320                           458                  ;                           SOURCE MODE:          0000 0000 00XX X000 (FILT_SCR_MODE)
00001320                           459                  ;                           SOURCE REGISTER:      0000 0000 0000 0XXX (FILT_SRC_REG)
00001320                           460                  ;                           The modes (and maybe register) will tell us whether we need to read additional data for this MOVE.
00001320                           461                  ;               d) 0010: (MOVE.L). Now read and store:
00001320                           462                  ;                           DESTINATION REGISTER: 0000 XXX0 0000 0000 (FILT_DEST_REG)
00001320                           463                  ;                           DESTINATION MODE:     0000 000X XX00 0000 (FILT_DEST_MODE)
00001320                           464                  ;                           SOURCE MODE:          0000 0000 00XX X000 (FILT_SCR_MODE)
00001320                           465                  ;                           SOURCE REGISTER:      0000 0000 0000 0XXX (FILT_SRC_REG)
00001320                           466                  ;                           The modes (and maybe register) will tell us whether we need to read additional data for this MOVE.
00001320                           467                  ;               e) 0100: Read the bits at 0000 XXXX 0000 0000 (need filter) Branch:
00001320                           468                  ;                   i.      0000: Read the bits at 0000 0000 XX00 0000 (need filter) Branch:
00001320                           469                  ;                               1. 11: MOVE from SR. (TODO)
00001320                           470                  ;                               2. (DEFAULT) NEGX. (the two bits are size) (TODO)
00001320                           471                  ;                   ii.     0100: Read the bits at 0000 0000 XX00 0000 (need filter) Branch:
00001320                           472                  ;                               1. 11 MOVE to CCR. (TODO)
00001320                           473                  ;                               2. (DEFAULT) NEG. (the two bits are size) (TODO)
00001320                           474                  ;                   iii.    0110: Read the bits at 0000 0000 XX00 0000 (need filter) Branch:
00001320                           475                  ;                               1. 11 MOVE to SR. (TODO)
00001320                           476                  ;                               2. (DEFAULT) NOT. (the two bits are size) (TODO)
00001320                           477                  ;                   iv.     0010: CLR. (TODO)
00001320                           478                  ;                    v.     1000: (EXT, NBCD, SWAP, PEA, MOVEM (dir 0)) (TODO)
00001320                           479                  ;                   vi.     1010: Check the bits at 0000 XX00 0000 0000 (need filter) Branch:
00001320                           480                  ;                           1. 11: check the bits at 0000 00XX XXXX XXXX (need filter) Branch:
00001320                           481                  ;                               a. 11 1100: ILLEGAL (TODO)
00001320                           482                  ;                               b. (default) TAS (TODO)
00001320                           483                  ;                           2. (default) TST (TODO)
00001320                           484                  ;                  vii.     1110: (TRAP, LINK, UNLK, MOVE USP, RESET, NOP, STOP, RTE, RTS, TRAPV, RTR, JSR, JMP) (TODO)
00001320                           485                  ;                 viii.     (DEFAULT): (MOVEM, LEA, CHK,) (TODO)    
00001320                           486                  ;               f) 0101: (ADDQ, SUBQ, Scc, DBcc): Read the bits at 0000 0000 XX00 0000 (need filter) Branch:
00001320                           487                  ;                    i. 11: Read the bit at 0000 000X 0000 0000 (need filter) Branch:
00001320                           488                  ;                           1. 0: ADDQ (TODO)
00001320                           489                  ;                           2. 1: SUBQ (TODO)
00001320                           490                  ;                   ii. (default) (bits are size) read the bits at 0000 00XX X000 (FILT_SRC_MODE). Branch:
00001320                           491                  ;                           1. 001: DBCC (TODO)
00001320                           492                  ;                           2. (default): Scc (TODO)
00001320                           493                  ;               g) 0110: Read the bit at 0000 XXXX 0000 0000 (need filter) Branch:
00001320                           494                  ;                    i. 0000: BRA (TODO)
00001320                           495                  ;                   ii. 0001: BSR (TODO)
00001320                           496                  ;                  iii. (default) Bcc (TODO)
00001320                           497                  ;               h) 0111: MOVEQ (TODO)
00001320                           498                  ;               i) 1000: (DIVU, DIVS, SBCD, OR) (TODO)
00001320                           499                  ;               j) 1001: (SUB, SUBX, SUBA) (TODO)
00001320                           500                  ;               k) 1011: (EOR, CMPM, CMP, CMPA) (TODO)
00001320                           501                  ;               l) 1100: (MULU, MULS, ABCD, EXG, AND) (TODO)
00001320                           502                  ;               m) 1101: (ADD, ADDX, ADDA) (TODO)
00001320                           503                  ;               n) 1110: (ASd, LSd, ROXd, ROd, ASd, LSd, ROXd, ROd) (TODO)
00001320                           504                  ;               o) (default) The code is invalid. Not yet sure what we do in this case.
00001320                           505                  ;   
00001320                           506                  ;   
00001320                           507                  ;
00001320                           508                  
00001320                           509                  ;TODO: Use AND operations with filters to create values which can be
00001320                           510                  ;      checked against constants to narrow down OPcodes.
00001320                           511                  
00001320                           512                  ;TODO: Since it will take a while to decode every possible OPcode, we
00001320                           513                  ;      should first have a default "Error" subroutine which the program
00001320                           514                  ;      branches to once all other possibilities have been ruled out.
00001320                           515  
00001320                           516  *------------------- Read current OPcode -------------------
00001320                           517  ; By this point, CURRENT_WORD should store a potential beginning of an instruction, so we should not increment A5.
00001320  6000 0028                518  READ_CURRENT_OP         BRA         CHECK_CONSTANTS
00001324                           519                          
00001324                           520    
00001324                           521  *------------------- Display current address we are reading -------------------
00001324  43F9 00001FBF            522  DISPLAY_CURRENT_ADDRESS LEA         DOLLAR,A1       ; '$'
0000132A  103C 000E                523                          MOVE.B      #14,D0
0000132E  4E4F                     524                          TRAP        #15
00001330                           525                  
00001330  220C                     526                          MOVE.L      A4,D1           ; display the address the instruction was found at
00001332  143C 0010                527                          MOVE.B      #16,D2
00001336  103C 000F                528                          MOVE.B      #15,D0
0000133A  4E4F                     529                          TRAP        #15
0000133C                           530  
0000133C  43F9 00001FBD            531                          LEA         SPACE,A1        ; ' '
00001342  103C 000E                532                          MOVE.B      #14,D0      
00001346  4E4F                     533                          TRAP        #15     
00001348                           534                          
00001348  4E75                     535                          RTS
0000134A                           536   
0000134A                           537  *------------------ Check current word for constants---------
0000134A                           538  ; By this point, the current word should store a potential beginning of an instruction.                   
0000134A  0C79 4E70 00002218       539  CHECK_CONSTANTS         CMP         #RESET_CODE,(CURRENT_WORD)
00001352  6700 001E                540                          BEQ         RESET_FOUND
00001356  0C79 4E71 00002218       541                          CMP         #NOP_CODE,(CURRENT_WORD)
0000135E  6700 0030                542                          BEQ         NOP_FOUND
00001362  0C79 4E72 00002218       543                          CMP         #STOP_CODE,(CURRENT_WORD)
0000136A  6700 0042                544                          BEQ         STOP_FOUND
0000136E  6000 0042                545                          BRA         CHECK_NON_CONSTANTS     ;Once we rule out all the constants we know of, we check for non-constants.
00001372                           546  
00001372                           547  ; TODO: change the structure of these subroutines to be like the nice structure used in EA SRs.
00001372                           548                         
00001372  61B0                     549  RESET_FOUND             BSR         DISPLAY_CURRENT_ADDRESS
00001374                           550  
00001374  43F9 000021B1            551                          LEA         RESET_MSG,A1    ; 'RESET'
0000137A  103C 000E                552                          MOVE.B      #14,D0
0000137E  4E4F                     553                          TRAP        #15
00001380                           554                          
00001380  43F9 00001FBA            555                          LEA         RETURN,A1       ; (return)
00001386  103C 000E                556                          MOVE.B      #14,D0
0000138A  4E4F                     557                          TRAP        #15
0000138C                           558                 
0000138C  6000 FF64                559                          BRA         GO_TO_NEXT_OP   
00001390                           560   
00001390                           561  ; NOTE: this SR is temporary. Once we have the display buffer, it will work differently.                 
00001390  6192                     562  NOP_FOUND               BSR         DISPLAY_CURRENT_ADDRESS
00001392                           563  
00001392  43F9 000021B7            564                          LEA         NOP_MSG,A1    ; 'NOP'
00001398  103C 000E                565                          MOVE.B      #14,D0
0000139C  4E4F                     566                          TRAP        #15
0000139E                           567                          
0000139E  43F9 00001FBA            568                          LEA         RETURN,A1     ; (return)
000013A4  103C 000E                569                          MOVE.B      #14,D0
000013A8  4E4F                     570                          TRAP        #15
000013AA                           571                 
000013AA  6000 FF46                572                          BRA         GO_TO_NEXT_OP   ; when we are done parsing and displaying the NOP instruction, go to the next OPcode.
000013AE                           573  
000013AE  4EF8 1004                574  STOP_FOUND              JMP         STOP  ;TODO: case for stop found. (NOTE that STOP instructions have additional data.)               
000013B2                           575  
000013B2                           576  ;TODO: add cases for rest of valid constant OPcodes here
000013B2                           577  
000013B2                           578  *----------------- Check current word for non-constants---------
000013B2                           579  ;NOTE: we currently know that CURRENT_WORD is not a constant by the time we reach this SR.
000013B2                           580  
000013B2  6100 0232                581  CHECK_NON_CONSTANTS     BSR         CHECK_MOVE        ; MOVE is a special case because of how its first nibble is structured.     
000013B6  6100 0254                582                          BSR         CHECK_MOVEQ       ; MOVEQ is also a special case.
000013BA  6100 0266                583                          BSR         CHECK_EXT         ; need to rule out EXT before checking MOVEM, because they have very similar OPcodes.
000013BE  6100 0278                584                          BSR         CHECK_MOVEM      
000013C2  6100 002A                585                          BSR         CHECK_NIB1_0000 
000013C6  6100 003C                586                          BSR         CHECK_NIB1_0100 
000013CA  6100 004E                587                          BSR         CHECK_NIB1_0101
000013CE  6100 0060                588                          BSR         CHECK_NIB1_0110
000013D2  6100 0072                589                          BSR         CHECK_NIB1_1000
000013D6  6100 0082                590                          BSR         CHECK_NIB1_1001
000013DA  6100 0094                591                          BSR         CHECK_NIB1_1011
000013DE  6100 00A6                592                          BSR         CHECK_NIB1_1100
000013E2  6100 00B8                593                          BSR         CHECK_NIB1_1101
000013E6  6100 00CA                594                          BSR         CHECK_NIB1_1110
000013EA                           595                          
000013EA                           596                          ; TODO: If we get to here, there should be an error.
000013EA                           597                          
000013EA                           598                          ;NOTE: we do not check for most specific instructions here.
000013EA                           599  
000013EA                           600                          ; TODO: go into the subroutines below and *fully* implement the followings:
000013EA                           601                          *   -ADD    (B,W,L) (will need shahin's size filter for this and below)
000013EA                           602                          *   -ADDA   (W,L)
000013EA                           603                          *   -ADDI   (B,W,L)
000013EA                           604                          *   -SUB    (B,W,L)
000013EA                           605                          ;etc
000013EA  4EF8 1004                606                          JMP         STOP
000013EE                           607                          ;TODO: check for other instructions instead of stopping if it's not one of these.
000013EE                           608    
000013EE                           609  *-----------------------First 4bit checks go here-----------------------------------
000013EE                           610    
000013EE                           611  *-----------------------Check if the current word starts with 0000--------------------
000013EE  4243                     612  CHECK_NIB1_0000         CLR         D3
000013F0  3639 00002218            613                          MOVE.W      CURRENT_WORD,D3
000013F6  0243 F000                614                          ANDI.W      #FILT_NIB_1,D3  ; filter out the first 4 bits of the word
000013FA  B67C 0000                615                          CMP         #CONST_ALL_0,D3 ; see if they are 0000
000013FE  6700 00C8                616                          BEQ         CONFIRM_NIB1_0000
00001402  4E75                     617                          RTS 
00001404                           618                          
00001404  4243                     619  CHECK_NIB1_0100         CLR         D3 
00001406  3639 00002218            620                          MOVE.W      CURRENT_WORD,D3
0000140C  0243 F000                621                          ANDI.W      #FILT_NIB_1,D3      ; filter out the first 4 bits of the word
00001410  B67C 4000                622                          CMP         #CONST_NIB1_0100,D3 ; see if they are 0100
00001414  6700 0108                623                          BEQ         CONFIRM_NIB1_0100
00001418  4E75                     624                          RTS                        
0000141A                           625                          
0000141A  4243                     626  CHECK_NIB1_0101         CLR         D3 
0000141C  3639 00002218            627                          MOVE.W      CURRENT_WORD,D3
00001422  0243 F000                628                          ANDI.W      #FILT_NIB_1,D3      ; filter out the first 4 bits of the word
00001426  B67C 5000                629                          CMP         #CONST_NIB1_0101,D3 ; see if they are 0101
0000142A  6700 0172                630                          BEQ         CONFIRM_NIB1_0101
0000142E  4E75                     631                          RTS  
00001430                           632                
00001430  4243                     633  CHECK_NIB1_0110         CLR         D3 
00001432  3639 00002218            634                          MOVE.W      CURRENT_WORD,D3
00001438  0243 F000                635                          ANDI.W      #FILT_NIB_1,D3      ; filter out the first 4 bits of the word
0000143C  B67C 6000                636                          CMP         #CONST_NIB1_0110,D3 ; see if they are 0110
00001440  6700 0160                637                          BEQ         CONFIRM_NIB1_0110
00001444  4E75                     638                          RTS  
00001446                           639                     
00001446  4243                     640  CHECK_NIB1_1000         CLR         D3 
00001448  3639 00002218            641                          MOVE.W      CURRENT_WORD,D3
0000144E  0243 F000                642                          ANDI.W      #FILT_NIB_1,D3      ; filter out the first 4 bits of the word
00001452  B67C 8000                643                          CMP         #CONST_NIB1_1000,D3 ; see if they are 1000
00001456  6700 014E                644                          BEQ         CONFIRM_NIB1_1000
0000145A                           645          
0000145A  4243                     646  CHECK_NIB1_1001         CLR         D3 
0000145C  3639 00002218            647                          MOVE.W      CURRENT_WORD,D3
00001462  0243 F000                648                          ANDI.W      #FILT_NIB_1,D3      ; filter out the first 4 bits of the word
00001466  B67C 9000                649                          CMP         #CONST_NIB1_1001,D3 ; see if they are 1001
0000146A  6700 013E                650                          BEQ         CONFIRM_NIB1_1001
0000146E  4E75                     651                          RTS
00001470                           652  
00001470  4243                     653  CHECK_NIB1_1011         CLR         D3 
00001472  3639 00002218            654                          MOVE.W      CURRENT_WORD,D3
00001478  0243 F000                655                          ANDI.W      #FILT_NIB_1,D3      ; filter out the first 4 bits of the word
0000147C  B67C B000                656                          CMP         #CONST_NIB1_1011,D3 ; see if they are 1011
00001480  6700 012C                657                          BEQ         CONFIRM_NIB1_1011
00001484  4E75                     658                          RTS 
00001486                           659  
00001486  4243                     660  CHECK_NIB1_1100         CLR         D3 
00001488  3639 00002218            661                          MOVE.W      CURRENT_WORD,D3
0000148E  0243 F000                662                          ANDI.W      #FILT_NIB_1,D3      ; filter out the first 4 bits of the word
00001492  B67C C000                663                          CMP         #CONST_NIB1_1100,D3 ; see if they are 1100
00001496  6700 011A                664                          BEQ         CONFIRM_NIB1_1100
0000149A  4E75                     665                          RTS 
0000149C                           666  
0000149C  4243                     667  CHECK_NIB1_1101         CLR         D3 
0000149E  3639 00002218            668                          MOVE.W      CURRENT_WORD,D3
000014A4  0243 F000                669                          ANDI.W      #FILT_NIB_1,D3      ; filter out the first 4 bits of the word
000014A8  B67C D000                670                          CMP         #CONST_NIB1_1101,D3 ; see if they are 1101
000014AC  6700 0108                671                          BEQ         CONFIRM_NIB1_1101
000014B0  4E75                     672                          RTS 
000014B2                           673                          
000014B2  4243                     674  CHECK_NIB1_1110         CLR         D3 
000014B4  3639 00002218            675                          MOVE.W      CURRENT_WORD,D3
000014BA  0243 F000                676                          ANDI.W      #FILT_NIB_1,D3      ; filter out the first 4 bits of the word
000014BE  B67C E000                677                          CMP         #CONST_NIB1_1110,D3 ; see if they are 1110
000014C2  6700 011E                678                          BEQ         CONFIRM_NIB1_1110
000014C6  4E75                     679                          RTS 
000014C8                           680                          
000014C8                           681  *-----------------------First 4bit confirms go here--------------------------------------
000014C8                           682  
000014C8                           683  *-----------------------Cases where the current word starts with 0000--------------------                       
000014C8  4243                     684  CONFIRM_NIB1_0000       CLR         D3
000014CA  3639 00002218            685                          MOVE.W      CURRENT_WORD,D3
000014D0  0243 0100                686                          ANDI.W      #FILT_BIT_8,D3  ; turn word into 0000 000X 0000 0000
000014D4  E04B                     687                          LSR.W       #8,D3           ; turn word into 0000 0000 0000 000X
000014D6  B67C 0000                688                          CMP         #CONST_ALL_0,D3 ; see if the word is still 0.
000014DA  6700 0004                689                          BEQ         CONFIRM_0000_XXX0
000014DE                           690                          ; if we get to here, then the word must be BCHG, BCLR, BSET, or MOVEP.
000014DE                           691                          ; BCHG is required
000014DE                           692                          ; if our disassembler doesn't consider any of those valid, there should be an error message here.
000014DE  4E75                     693                          RTS 
000014E0                           694                          
000014E0                           695  ; at this point, the word is of the form 0000 XXX0...
000014E0  4243                     696  CONFIRM_0000_XXX0       CLR         D3
000014E2  3639 00002218            697                          MOVE.W      CURRENT_WORD,D3
000014E8  0243 0E00                698                          ANDI.W      #FILT_DEST_REG,D3  ; turn word into 0000 XXX0 0000 0000          
000014EC                           699                          
000014EC                           700                          ; now figure out which operation we have: (note that constants have been ruled out by this point)
000014EC                           701                          
000014EC  B67C 0000                702                          CMP         #CONST_ORI_DEST_REG,D3  ; ORI 
000014F0  6700 05BE                703                          BEQ         ORI_FOUND           
000014F4                           704                          
000014F4  B67C 0200                705                          CMP         #CONST_ANDI_DEST_REG,D3 ; ANDI 
000014F8  6700 05BA                706                          BEQ         ANDI_FOUND
000014FC                           707                          
000014FC  B67C 0400                708                          CMP         #CONST_SUBI_DEST_REG,D3 ; SUBI
00001500  6700 05B6                709                          BEQ         SUBI_FOUND
00001504                           710                          ;
00001504  B67C 0600                711                          CMP         #CONST_ADDI_DEST_REG,D3 ; ADDI
00001508  6700 05B2                712                          BEQ         ADDI_FOUND
0000150C                           713                          
0000150C  B67C 0A00                714                          CMP         #CONST_EORI_DEST_REG,D3 ; EORI
00001510  6700 05AE                715                          BEQ         EORI_FOUND
00001514                           716                          
00001514  B67C 0C00                717                          CMP         #CONST_CMPI_DEST_REG,D3 ; CMPI
00001518  6700 05AA                718                          BEQ         CMPI_FOUND
0000151C                           719                          
0000151C                           720                          ;TODO: remaining: BTST, BCHG, BCLR, or BSET. 
0000151C                           721                          ;      if none of them, an error case should occur here.
0000151C                           722                          ;     (note that BCHG is required, though we don't know which version.)
0000151C                           723                          
0000151C  4E75                     724                          RTS     ;change RTS to whatever branch instruction is appropriate here.
0000151E                           725                          
0000151E                           726  *-----------------------Cases where the current word starts with 0100-----------------
0000151E                           727  
0000151E                           728  CONFIRM_NIB1_0100       ; TODO: check for MOVE from SR, MOVE to CCR, MOVE to SR here.
0000151E  4243                     729                          CLR         D3              
00001520  3639 00002218            730                          MOVE.W      CURRENT_WORD,D3
00001526  0243 0800                731                          ANDI.W      #FILT_BIT_5,D3  ; turn word into 0000 X000 0000 0000
0000152A  E04B                     732                          LSR.W       #8,D3           ; turn word into 0000 0000 0000 000X
0000152C  E64B                     733                          LSR.W       #3,D3
0000152E  B67C 0000                734                          CMP         #CONST_ALL_0,D3 ; see if the word is still 0.
00001532  6700 0006                735                          BEQ         CONFIRM_0100_0XXX   ; branch based on the 5th bit.
00001536  6000 0032                736                          BRA         CONFIRM_0100_1XXX
0000153A                           737                          
0000153A  4243                     738  CONFIRM_0100_0XXX       CLR         D3              
0000153C  3639 00002218            739                          MOVE.W      CURRENT_WORD,D3
00001542  0243 0F00                740                          ANDI.W      #FILT_NIB_2,D3  ; turn word into 0000 XXXX 0000 0000
00001546                           741                          
00001546                           742                          ; now figure out which operation we have:
00001546                           743                          
00001546  B67C 0000                744                          CMP         #CONST_NEGX_OP,D3
0000154A  6700 057C                745                          BEQ         NEGX_FOUND
0000154E                           746                          
0000154E  B67C 0200                747                          CMP         #CONST_CLR_OP,D3
00001552  6700 0578                748                          BEQ         CLR_FOUND
00001556                           749                          
00001556  B67C 0400                750                          CMP         #CONST_NEG_OP,D3
0000155A  6700 0574                751                          BEQ         NEG_FOUND
0000155E                           752                          
0000155E  B67C 0600                753                          CMP         #CONST_NOT_OP,D3
00001562  6700 0570                754                          BEQ         NOT_FOUND         ; note that we could likely make a conflicting SR name with one.
00001566                           755                          
00001566                           756                          ; TODO: we definitely have an error at this point.
00001566                           757                          
00001566  4EF8 1004                758                          JMP         STOP     ;change STOP to whatever we want based on error. (probably some error case which will then branch to reading next OPcode.)
0000156A                           759                          
0000156A  4243                     760  CONFIRM_0100_1XXX       CLR         D3
0000156C  3639 00002218            761                          MOVE.W      CURRENT_WORD,D3
00001572  0243 0F00                762                          ANDI.W      #FILT_NIB_2,D3  ; turn word into 0000 XXXX 0000 0000
00001576                           763                          
00001576  B67C 0800                764                          CMP         #CONST_NIB2_1000,D3
0000157A  6700 0016                765                          BEQ         CONFIRM_0100_1000
0000157E                           766  
0000157E  B67C 0A00                767                          CMP         #CONST_NIB2_1010,D3
00001582  6700 0012                768                          BEQ         CONFIRM_0100_1010 
00001586                           769  
00001586  B67C 0E00                770                          CMP         #CONST_NIB2_1110,D3
0000158A  6700 000E                771                          BEQ         CONFIRM_0100_1110 
0000158E                           772                          ; TODO: make MOVEM a special case since it has an unusual OPcode.
0000158E                           773                          ; TODO: remaining possibilities are MOVEM, LEA, or CHK. (the first two are required.)
0000158E                           774  
0000158E  4EF8 1004                775                          JMP         STOP                      
00001592                           776                     
00001592  4EF8 1004                777  CONFIRM_0100_1000       JMP         STOP                       
00001596                           778  ; TODO: check for EXT, NBCD, SWAP, or PEA.               
00001596                           779   
00001596  4EF8 1004                780  CONFIRM_0100_1010       JMP         STOP  
0000159A                           781  ; TODO: check for TAS or TST. (ILLEGAL is already ruled out.)         
0000159A                           782         
0000159A  4EF8 1004                783  CONFIRM_0100_1110       JMP         STOP       
0000159E                           784  ; TODO: check for TRAP, LINK, UNLK, MOVE USP, JSR, or JMP. (some of these are required.)
0000159E                           785  
0000159E                           786  *-----------------------Cases where the current word starts with 0101-----------------
0000159E  4EF8 1004                787  CONFIRM_NIB1_0101        JMP         STOP
000015A2                           788        
000015A2                           789                          
000015A2                           790      ;TODO: ADDQ, SUBQ, Scc, DBcc (some of these are required)
000015A2                           791   
000015A2                           792  *-----------------------Cases where the current word starts with 0110-----------------
000015A2  4EF8 1004                793  CONFIRM_NIB1_0110        JMP         STOP
000015A6                           794      ;TODO: BRA, BSR, Bcc (some of these are required)   
000015A6                           795      
000015A6                           796  *-----------------------Cases where the current word starts with 1000-----------------
000015A6  4EF8 1004                797  CONFIRM_NIB1_1000        JMP         STOP
000015AA                           798      ;TODO: DIVU, DIVS, SBCD, OR (some of these are required)   
000015AA                           799      
000015AA                           800  *-----------------------Cases where the current word starts with 1001-----------------
000015AA  4EF8 1004                801  CONFIRM_NIB1_1001        JMP         STOP
000015AE                           802      ;TODO: SUB, SUBX, SUBA (some of these are required) 
000015AE                           803   
000015AE                           804  *-----------------------Cases where the current word starts with 1011-----------------
000015AE  4EF8 1004                805  CONFIRM_NIB1_1011        JMP         STOP
000015B2                           806      ;TODO: EOR, CMPM, CMP, CMPA (some of these are required)  
000015B2                           807      
000015B2                           808  *-----------------------Cases where the current word starts with 1100-----------------
000015B2  4EF8 1004                809  CONFIRM_NIB1_1100        JMP         STOP
000015B6                           810      ;TODO: MULU, MULS, ABCD, EXG, AND (some of these are required) 
000015B6                           811      
000015B6                           812  *-----------------------Cases where the current word starts with 1101-----------------
000015B6  4243                     813  CONFIRM_NIB1_1101        CLR         D3                 ; XXXX XXXX 11XX XXXX means ADDA
000015B8  3639 00002218            814                           MOVE.W      CURRENT_WORD,D3
000015BE  0243 00C0                815                           ANDI.W      #FILT_ADDA,D3
000015C2  B67C 00C0                816                           CMP         #CONST_ADDA,D3
000015C6  6700 0518                817                           BEQ         ADDA_FOUND
000015CA                           818                           
000015CA  4243                     819                           CLR         D3                 ; XXXX XXX1 XX00 XXXX means ADDX 
000015CC  3639 00002218            820                           MOVE.W      CURRENT_WORD,D3
000015D2  0243 0130                821                           ANDI.W      #FILT_ADDX,D3
000015D6  B67C 0100                822                           CMP         #CONST_ADDX,D3
000015DA  6700 0500                823                           BEQ         ADDX_FOUND
000015DE                           824                           
000015DE  6000 04F8                825                           BRA         ADD_FOUND          ; everything else means ADD
000015E2                           826  
000015E2                           827      ; TODO: ADD (next major goal)
000015E2                           828      ; TODO: ADDX, ADDA (some of these are required) 
000015E2                           829      
000015E2                           830  *-----------------------Cases where the current word starts with 1110-----------------
000015E2  4EF8 1004                831  CONFIRM_NIB1_1110        JMP         STOP
000015E6                           832      ;TODO: ASR, ASL, LSR, LSL, ROXR, ROXL, ROR, ROL (these are all repeated twice on the sheet for some reason) 
000015E6                           833                                                      ;(some of these are required) 
000015E6                           834   
000015E6                           835  *-----------------------Special OPcode (but not constants) have checks here------------
000015E6                           836  * includes MOVE, MOVEQ, etc
000015E6                           837                                  
000015E6                           838  *-----------------------Check current word for MOVE------------------------------------
000015E6                           839  *MOVE can be B,W, or L.
000015E6  4243                     840  CHECK_MOVE              CLR         D3
000015E8  3639 00002218            841                          MOVE.W      CURRENT_WORD,D3
000015EE  0243 F000                842                          ANDI.W      #FILT_NIB_1,D3
000015F2  B67C 1000                843                          CMP         #CONST_MOVE_B,D3
000015F6  6700 0056                844                          BEQ         MOVE_B_FOUND
000015FA  B67C 3000                845                          CMP         #CONST_MOVE_W,D3
000015FE  6700 007E                846                          BEQ         MOVE_W_FOUND
00001602  B67C 2000                847                          CMP         #CONST_MOVE_L,D3
00001606  6700 00A6                848                          BEQ         MOVE_L_FOUND
0000160A  4E75                     849                          RTS 
0000160C                           850                          
0000160C                           851  *-----------------------Check current word for MOVEQ------------------------------------
0000160C                           852  *MOVEQ can only be L.                       
0000160C  4243                     853  CHECK_MOVEQ             CLR         D3
0000160E  3639 00002218            854                          MOVE.W      CURRENT_WORD,D3
00001614  0243 F000                855                          ANDI.W      #FILT_NIB_1,D3
00001618  B67C 7000                856                          CMP         #CONST_MOVEQ,D3
0000161C  6700 00FC                857                          BEQ         MOVEQ_FOUND
00001620  4E75                     858                          RTS 
00001622                           859                          
00001622                           860  
00001622                           861  *-----------------------Check current word for EXT------------------------------------  
00001622                           862  *check EXT before MOVEM, since they can be easily confused.
00001622                           863  *EXT can be W or L.                  
00001622  4243                     864  CHECK_EXT               CLR         D3                  
00001624  3639 00002218            865                          MOVE.W      CURRENT_WORD,D3
0000162A  0243 FFB8                866                          ANDI.W      #FILT_EXT,D3
0000162E  B67C 4880                867                          CMP         #CONST_EXT,D3
00001632  6700 0174                868                          BEQ         EXT_FOUND
00001636  4E75                     869                          RTS 
00001638                           870                          
00001638                           871  *-----------------------Check current word for MOVEM------------------------------------  
00001638                           872  *MOVEM can be W or L.                  
00001638  4243                     873  CHECK_MOVEM             CLR         D3                         
0000163A  3639 00002218            874                          MOVE.W      CURRENT_WORD,D3
00001640  0243 FB80                875                          ANDI.W      #FILT_MOVEM,D3
00001644  B67C 4880                876                          CMP         #CONST_MOVEM,D3
00001648  6700 0162                877                          BEQ         MOVEM_FOUND
0000164C  4E75                     878                          RTS 
0000164E                           879                          
0000164E                           880  *---------------------- END OPWORD CHECKS -----------------------------------------
0000164E                           881  
0000164E                           882  *---------------------- BEGIN CASES FOR FOUND OPCODES------------------------------
0000164E                           883  
0000164E                           884  *-----------------------MOVE-related Subroutines------------------------------------
0000164E                           885  
0000164E                           886  *-----------------------Cases for finding different MOVE OPcodes------------------------------------
0000164E                           887  *MOVE.B
0000164E  13FC 0000 0000221A       888  MOVE_B_FOUND            MOVE.B      #BYTE_SIZE,CURRENT_OP_SIZE
00001656  6100 FCCC                889                          BSR         DISPLAY_CURRENT_ADDRESS
0000165A  6100 0082                890                          BSR         PARSE_MOVE_DATA                           
0000165E                           891                         
0000165E  43F9 000021C5            892                          LEA         MOVE_B_MSG,A1      ; 'MOVE.B'
00001664  103C 000E                893                          MOVE.B      #14,D0
00001668  4E4F                     894                          TRAP        #15
0000166A                           895                          
0000166A  43F9 00001FBD            896                          LEA         SPACE,A1           ; ' '
00001670  103C 000E                897                          MOVE.B      #14,D0      
00001674  4E4F                     898                          TRAP        #15
00001676                           899                          
00001676  6100 0080                900                          BSR         DISPLAY_MOVE_DATA
0000167A  6000 FC76                901                          BRA         GO_TO_NEXT_OP
0000167E                           902  
0000167E                           903  *MOVE.W                        
0000167E  13FC 0001 0000221A       904  MOVE_W_FOUND            MOVE.B      #WORD_SIZE,CURRENT_OP_SIZE
00001686  6100 FC9C                905                          BSR         DISPLAY_CURRENT_ADDRESS
0000168A  6100 0052                906                          BSR         PARSE_MOVE_DATA       
0000168E                           907                          
0000168E  43F9 000021CC            908                          LEA         MOVE_W_MSG,A1      ; 'MOVE.W'
00001694  103C 000E                909                          MOVE.B      #14,D0
00001698  4E4F                     910                          TRAP        #15
0000169A                           911                          
0000169A  43F9 00001FBD            912                          LEA         SPACE,A1           ; ' '
000016A0  103C 000E                913                          MOVE.B      #14,D0      
000016A4  4E4F                     914                          TRAP        #15
000016A6                           915                          
000016A6  6100 0050                916                          BSR         DISPLAY_MOVE_DATA
000016AA  6000 FC46                917                          BRA         GO_TO_NEXT_OP  
000016AE                           918  
000016AE                           919  *MOVE.L                        
000016AE  13FC 0002 0000221A       920  MOVE_L_FOUND            MOVE.B      #LONG_SIZE,CURRENT_OP_SIZE
000016B6  6100 FC6C                921                          BSR         DISPLAY_CURRENT_ADDRESS
000016BA  6100 0022                922                          BSR         PARSE_MOVE_DATA       
000016BE                           923                          
000016BE  43F9 000021D3            924                          LEA         MOVE_L_MSG,A1      ; 'MOVE.L'
000016C4  103C 000E                925                          MOVE.B      #14,D0
000016C8  4E4F                     926                          TRAP        #15
000016CA                           927                          
000016CA  43F9 00001FBD            928                          LEA         SPACE,A1           ; ' '
000016D0  103C 000E                929                          MOVE.B      #14,D0      
000016D4  4E4F                     930                          TRAP        #15
000016D6                           931                          
000016D6  6100 0020                932                          BSR         DISPLAY_MOVE_DATA
000016DA  6000 FC16                933                          BRA         GO_TO_NEXT_OP 
000016DE                           934                         
000016DE                           935  *-----------------------Parse data for any-sized MOVE instruction---------------------
000016DE                           936  *Note that the size of the MOVE is stored in CURRENT_OP_SIZE.
000016DE                           937  PARSE_MOVE_DATA         ; TODO: error checking 
000016DE                           938                          ;(maybe after reading the first 4 instruction parts, but before reading additional data)
000016DE                           939                          ;IMPORTANT: remember that different MOVE error are specific to different MOVE sizes.
000016DE                           940                          ; example: MOVE.B  A0,D3 is invalid. However, MOVE.W  A0,D3 is valid.
000016DE                           941                          ;
000016DE                           942                          ; possible errors:
000016DE                           943                          ;       CURRENT_DEST_MD = CONST_IMMEDIATE_REG (immediate data cannot be a destination)
000016DE                           944                          ;       CURRENT_SRC_MD  = CONST_ADDR_REG_MD   (byte is not a valid size for this move)
000016DE                           945                          ;       CURRENT_DEST_MD = CONST_ADDR_REG_MD   (byte is not a valid size, although we should be using MOVEA at this point, not MOVE.)
000016DE                           946                          ;       TODO: figure out other possible errors.
000016DE                           947                          
000016DE                           948                          ; after we confirm that there are no errors, we know that we can safely check for additional data and display the instruction.
000016DE                           949                          
000016DE                           950                          
000016DE                           951                          ; at this point, need to read more information (parsed by EA, probably)
000016DE                           952                          ; now that we have a move instruction, we set our EA variables accordingly:
000016DE  6100 0404                953                          BSR         READ_DEST_REG      ; EA will set CURRENT_DEST_REG.
000016E2  6100 041E                954                          BSR         READ_DEST_MODE     ; EA will set CURRENT_DEST_MD.
000016E6  6100 0436                955                          BSR         READ_SOURCE_MODE   ; EA will set CURRENT_SRC_MD.
000016EA  6100 044E                956                          BSR         READ_SOURCE_REG    ; EA will set CURRENT_SRC_REG.
000016EE                           957                          
000016EE                           958                          ; need to check whether we need to read additional data before we start displaying the
000016EE                           959                          ; instruction (for instance, this is necessary for MOVE.B #10,D0).
000016EE  6100 0464                960                          BSR         READ_SOURCE_DATA   ; EA will set CURRENT_SOURCE_DATA if necessary.
000016F2  6100 049A                961                          BSR         READ_DEST_DATA     ; EA will set CURRENT_DEST_DATA if necessary. 
000016F6  4E75                     962                          RTS         
000016F8                           963  
000016F8  6100 05D6                964  DISPLAY_MOVE_DATA       BSR         DISPLAY_SOURCE     ; Tell EA to parse and display the source. EX: (A1)   D3    #10   $1000 etc
000016FC                           965                          
000016FC  43F9 00001FC1            966                          LEA         COMMA,A1           ; ','
00001702  103C 000E                967                          MOVE.B      #14,D0      
00001706  4E4F                     968                          TRAP        #15
00001708                           969                          
00001708  6100 05FC                970                          BSR         DISPLAY_DEST       ; Tell EA to parse and display the destination.
0000170C                           971                          
0000170C  43F9 00001FBA            972                          LEA         RETURN,A1          ; (return)
00001712  103C 000E                973                          MOVE.B      #14,D0
00001716  4E4F                     974                          TRAP        #15
00001718                           975  
00001718  4E75                     976                          RTS  
0000171A                           977  
0000171A                           978  *-----------------------MOVEQ-related Subroutines------------------------------------
0000171A                           979  
0000171A                           980  *-----------------------Case for finding MOVEQ------------------------------------
0000171A  13FC 0002 0000221A       981  MOVEQ_FOUND             MOVE.B      #LONG_SIZE,CURRENT_OP_SIZE
00001722  6100 FC00                982                          BSR         DISPLAY_CURRENT_ADDRESS
00001726  6100 0022                983                          BSR         PARSE_MOVEQ_DATA       
0000172A                           984                          
0000172A  43F9 000021DA            985                          LEA         MOVEQ_MSG,A1      ; 'MOVEQ'
00001730  103C 000E                986                          MOVE.B      #14,D0
00001734  4E4F                     987                          TRAP        #15
00001736                           988                          
00001736  43F9 00001FBD            989                          LEA         SPACE,A1           ; ' '
0000173C  103C 000E                990                          MOVE.B      #14,D0      
00001740  4E4F                     991                          TRAP        #15
00001742                           992                          
00001742  6100 0028                993                          BSR         DISPLAY_MOVEQ_DATA
00001746  6000 FBAA                994                          BRA         GO_TO_NEXT_OP  
0000174A                           995  
0000174A                           996  PARSE_MOVEQ_DATA        ;TODO: check that 0000 000X 0000 0000 equals zero. If not, error.
0000174A                           997                          
0000174A  6100 0398                998                          BSR         READ_DEST_REG                       ; EA will set CURRENT_DEST_REG.
0000174E  13FC 0000 0000222F       999                          MOVE.B      #CONST_DATA_REG_MD,CURRENT_DEST_MD  ; data register is the only allowed destination for MOVEQ.
00001756  6100 0036               1000                          BSR         READ_MOVEQ_DATA                     ; 0000 0000 XXXX XXXX will set CURRENT_SOURCE_DATA (I think.)
0000175A                          1001                          
0000175A  13FC 0007 0000222D      1002                          MOVE.B      #CONST_ADDR_MISC_MD,CURRENT_SRC_MD
00001762  13FC 0004 0000222E      1003                          MOVE.B      #CONST_IMMEDIATE_REG,CURRENT_SRC_REG
0000176A                          1004                          
0000176A  4E75                    1005                          RTS 
0000176C                          1006  
0000176C  6100 0562               1007  DISPLAY_MOVEQ_DATA      BSR         DISPLAY_SOURCE     ; Tell EA to parse and display the source. 
00001770                          1008                          
00001770  43F9 00001FC1           1009                          LEA         COMMA,A1           ; ','
00001776  103C 000E               1010                          MOVE.B      #14,D0      
0000177A  4E4F                    1011                          TRAP        #15
0000177C                          1012                          
0000177C  6100 0588               1013                          BSR         DISPLAY_DEST       ; Tell EA to parse and display the destination.
00001780                          1014                          
00001780  43F9 00001FBA           1015                          LEA         RETURN,A1          ; (return)
00001786  103C 000E               1016                          MOVE.B      #14,D0
0000178A  4E4F                    1017                          TRAP        #15
0000178C                          1018  
0000178C  4E75                    1019                          RTS        
0000178E                          1020  
0000178E                          1021  ;NOTE: this SR is stored here and not in EA because it is specific to MOVEQ.
0000178E  4244                    1022  READ_MOVEQ_DATA         CLR         D4
00001790  4279 00002236           1023                          CLR         CURRENT_SRC_DATA
00001796  3839 00002218           1024                          MOVE.W      CURRENT_WORD,D4
0000179C  0244 00FF               1025                          ANDI.W      #FILT_MOVEQ_DATA,D4        ; turn D4 into 0000 0000 XXXX XXXX (no shift necessary)
000017A0  33C4 00002236           1026                          MOVE.W      D4,CURRENT_SRC_DATA
000017A6  4E75                    1027                          RTS
000017A8                          1028                      
000017A8                          1029    ; TODO: (in order)
000017A8                          1030      *   -MOVEM  (W,L)
000017A8                          1031      *   -ADD    (B,W,L) (will need shahin's size filter for this and below)
000017A8                          1032      *   -ADDA   (W,L)
000017A8                          1033      *   -ADDI   (B,W,L)
000017A8                          1034      *   -SUB    (B,W,L)
000017A8                          1035    ; see comment block at the top of the program for the full list of codes.
000017A8                          1036    ; see huge comment block at the top of OPcode section for tentative OPcode parsing implementation plan.
000017A8                          1037    
000017A8                          1038  *-----------------------EXT-related Subroutines------------------------------------
000017A8  4EF8 1004               1039  EXT_FOUND               JMP         STOP ;TODO: case for EXT found
000017AC                          1040  
000017AC                          1041  ;TODO: first thing: read the correct size for MOVEM
000017AC                          1042  *-----------------------MOVEM-related Subroutines------------------------------------
000017AC  6100 FB76               1043  MOVEM_FOUND             BSR         DISPLAY_CURRENT_ADDRESS
000017B0  4244                    1044                          CLR         D4
000017B2  3839 00002218           1045                          MOVE.W      CURRENT_WORD,D4
000017B8  0244 0040               1046                          ANDI.W      #FILT_MOVEM_SIZE,D4 ; 0000 0000 0X00 0000 filter out size and set CURRENT_OP_SIZE accordingly
000017BC  EC4C                    1047                          LSR.W       #6,D4               ; 0000 0000 0000 000X
000017BE  B87C 0000               1048                          CMP         #WORD_SIZE_MOVEM,D4
000017C2  6700 0006               1049                          BEQ         MOVEM_W_FOUND
000017C6  6000 002E               1050                          BRA         MOVEM_L_FOUND
000017CA                          1051      
000017CA  13FC 0001 0000221A      1052  MOVEM_W_FOUND           MOVE.B      #WORD_SIZE,CURRENT_OP_SIZE
000017D2  6100 004E               1053                          BSR         PARSE_MOVEM_DATA
000017D6                          1054                          ; TODO: parse data before displaying.
000017D6  43F9 000021E0           1055                          LEA         MOVEM_W_MSG,A1      ; 'MOVEM.W'
000017DC  103C 000E               1056                          MOVE.B      #14,D0
000017E0  4E4F                    1057                          TRAP        #15
000017E2                          1058                          
000017E2  43F9 00001FBD           1059                          LEA         SPACE,A1           ; ' '
000017E8  103C 000E               1060                          MOVE.B      #14,D0      
000017EC  4E4F                    1061                          TRAP        #15  
000017EE                          1062                          
000017EE  6100 00C4               1063                          BSR         DISPLAY_MOVEM_DATA
000017F2  6000 FAFE               1064                          BRA         GO_TO_NEXT_OP                               
000017F6                          1065  
000017F6  13FC 0002 0000221A      1066  MOVEM_L_FOUND           MOVE.B      #LONG_SIZE,CURRENT_OP_SIZE
000017FE  6100 0022               1067                          BSR         PARSE_MOVEM_DATA   ; parse movem data for direction, EA, etc
00001802                          1068                          ; TODO: parse all data before displaying.
00001802  43F9 000021E8           1069                          LEA         MOVEM_L_MSG,A1      ; 'MOVEM.L'
00001808  103C 000E               1070                          MOVE.B      #14,D0
0000180C  4E4F                    1071                          TRAP        #15
0000180E                          1072                          
0000180E  43F9 00001FBD           1073                          LEA         SPACE,A1           ; ' '
00001814  103C 000E               1074                          MOVE.B      #14,D0      
00001818  4E4F                    1075                          TRAP        #15 
0000181A                          1076                          
0000181A  6100 0098               1077                          BSR         DISPLAY_MOVEM_DATA
0000181E  6000 FAD2               1078                          BRA         GO_TO_NEXT_OP 
00001822                          1079                          
00001822  6100 0316               1080  PARSE_MOVEM_DATA        BSR         READ_SOURCE_REG             ; EA will set CURRENT_SRC_REG.
00001826  6100 02F6               1081                          BSR         READ_SOURCE_MODE            ; EA will set CURRENT_SRC_MD.
0000182A  6100 0026               1082                          BSR         READ_MOVEM_DIR              ; read and store the direction of the current operation.
0000182E  13F9 0000222E 00002229  1083                          MOVE.B      CURRENT_SRC_REG,CURRENT_EA_REG  ; our current EA reg comes from  0000 0000 0000 0XXX.
00001838  13F9 0000222D 00002228  1084                          MOVE.B      CURRENT_SRC_MD,CURRENT_EA_MD    ; our current EA mode comes from 0000 0000 00XX X000.
00001842                          1085                          
00001842                          1086                          ; TODO: add any other parsing methods that should be true for both directions (and precede error checking) here.
00001842                          1087                          ; TODO: error cases to add here:
00001842                          1088                          ; TODO: error case for CURRENT_EA_MD = CONST_DATA_REG_MD: Dn
00001842                          1089                          ; TODO: error case for CURRENT_EA_MD = CONST_ADDR_REG_MD: An
00001842                          1090                          ; TODO: error case for CURRENT_EA_MD = CONST_ADDR_MISC_MD *and* CURRENT_EA_REG = CONST_IMMEDIATE REG: #<data>
00001842                          1091                          ; (note that these are not all error cases for MOVEM, but they are the only ones we are able to check in this subroutine.)
00001842                          1092                          
00001842  0C39 0000 0000222A      1093                          CMP.B       #CONST_MOVEM_DIR_0,CURRENT_DIRECTION
0000184A  6700 001E               1094                          BEQ         PARSE_MOVEM_DIR_0
0000184E  6000 0038               1095                          BRA         PARSE_MOVEM_DIR_1
00001852                          1096                          
00001852  4244                    1097  READ_MOVEM_DIR          CLR         D4
00001854  3839 00002218           1098                          MOVE.W      CURRENT_WORD,D4    
0000185A  0244 0400               1099                          ANDI.W      #FILT_MOVEM_DIR,D4 ; 0000 0X00 0000 0000     filter out direction 
0000185E  E04C                    1100                          LSR.W       #8,D4              ; 0000 0000 0000 000X
00001860  E44C                    1101                          LSR.W       #2,D4
00001862  13C4 0000222A           1102                          MOVE.B      D4,CURRENT_DIRECTION
00001868  4E75                    1103                          RTS
0000186A                          1104                          
0000186A                          1105  PARSE_MOVEM_DIR_0       ;TODO : error case for  (An+): CURRENT_EA_MD = CONST_ADDR_INCR_MD
0000186A  13F9 00002228 00002222  1106                          MOVE.B      CURRENT_EA_MD,CURRENT_R_MD      ; put EA on the right.
00001874  13F9 00002229 00002223  1107                          MOVE.B      CURRENT_EA_REG,CURRENT_R_REG
0000187E                          1108                          ; by this point, we have done all necessary error checking, and we are ready to read the
0000187E                          1109                          ; next word of additional data.
0000187E  6100 0026               1110                          BSR         PARSE_MOVEM_MASK_FIELD
00001882  6100 037E               1111                          BSR         READ_RIGHT_DATA
00001886                          1112                          ; ...
00001886  4E75                    1113                          RTS
00001888                          1114  
00001888                          1115  PARSE_MOVEM_DIR_1       ;TODO : error case for  (-An): CURRENT_EA_MD = CONST_ADDR_DECR_MD
00001888  13F9 00002228 0000221B  1116                          MOVE.B      CURRENT_EA_MD,CURRENT_L_MD      ; put EA on the left.
00001892  13F9 00002229 0000221C  1117                          MOVE.B      CURRENT_EA_REG,CURRENT_L_REG
0000189C                          1118                          ; by this point, we have done all necessary error checking, and we are ready to read the
0000189C                          1119                          ; next word of additional data.
0000189C  6100 0008               1120                          BSR         PARSE_MOVEM_MASK_FIELD
000018A0  6100 0326               1121                          BSR         READ_LEFT_DATA
000018A4                          1122                          
000018A4                          1123                          ; ...
000018A4  4E75                    1124                          RTS
000018A6                          1125                          ; TODO: for all EA modes except predecrement, the next additional data (always read) should be read A7...A0,D7...D0
000018A6                          1126                          ;   for predecrement, the order is reversed.
000018A6                          1127                          ; TODO: finish parsing data.
000018A6                          1128  
000018A6                          1129                          
000018A6                          1130      *Parse the mask field, which will tell us which address/data registers we are moving to/from.
000018A6  4279 0000223E           1131  PARSE_MOVEM_MASK_FIELD  CLR.W       CURRENT_MASK_FIELD
000018AC  33DD 0000223E           1132                          MOVE.W      (A5)+,CURRENT_MASK_FIELD
000018B2                          1133                          ;TODO: if CURRENT_EA_MD = CONST_ADDR_DECR_MD, reverse the way we read the next word of additional data.
000018B2  4E75                    1134                          RTS
000018B4                          1135    
000018B4  0C39 0000 0000222A      1136  DISPLAY_MOVEM_DATA      CMP.B       #CONST_MOVEM_DIR_0,CURRENT_DIRECTION
000018BC  6700 0006               1137                          BEQ         DISPLAY_MOVEM_DIR_0
000018C0  6000 0024               1138                          BRA         DISPLAY_MOVEM_DIR_1
000018C4                          1139                          
000018C4  6100 0042               1140  DISPLAY_MOVEM_DIR_0     BSR         DISPLAY_MOVEM_LIST ; display list, then ea.
000018C8                          1141                          
000018C8  43F9 00001FC1           1142                          LEA         COMMA,A1           ; ','
000018CE  103C 000E               1143                          MOVE.B      #14,D0      
000018D2  4E4F                    1144                          TRAP        #15
000018D4                          1145                          
000018D4  6100 049C               1146                          BSR         DISPLAY_RIGHT
000018D8                          1147                          
000018D8  43F9 00001FBA           1148                          LEA         RETURN,A1          ; (return)
000018DE  103C 000E               1149                          MOVE.B      #14,D0
000018E2  4E4F                    1150                          TRAP        #15
000018E4                          1151                          
000018E4  4E75                    1152                          RTS
000018E6                          1153  
000018E6  6100 0454               1154  DISPLAY_MOVEM_DIR_1     BSR         DISPLAY_LEFT        ; display ea, then list.
000018EA                          1155                          
000018EA  43F9 00001FC1           1156                          LEA         COMMA,A1            ; ','
000018F0  103C 000E               1157                          MOVE.B      #14,D0      
000018F4  4E4F                    1158                          TRAP        #15
000018F6                          1159                         
000018F6  6100 0010               1160                          BSR         DISPLAY_MOVEM_LIST
000018FA                          1161                          
000018FA  43F9 00001FBA           1162                          LEA         RETURN,A1          ; (return)
00001900  103C 000E               1163                          MOVE.B      #14,D0
00001904  4E4F                    1164                          TRAP        #15
00001906                          1165   
00001906  4E75                    1166                          RTS
00001908                          1167                          
00001908  0C39 0004 00002228      1168  DISPLAY_MOVEM_LIST      CMP.B       #CONST_ADDR_DECR_MD,CURRENT_EA_MD
00001910  6700 0010               1169                          BEQ         DISPLAY_MOVEM_LIST_REV
00001914  6000 0002               1170                          BRA         DISPLAY_MOVEM_LIST_FWD
00001918                          1171  
00001918                          1172      * display and start from the right
00001918                          1173      * MOVEM list is displayed as Ai-Aj/Dx-Dy
00001918  4243                    1174  DISPLAY_MOVEM_LIST_FWD  CLR         D3 ; D3 is a flag which tells us if we find any address registers in the list.
0000191A  4244                    1175                          CLR         D4 ; D4 is a temp value for our mask field.
0000191C  4245                    1176                          CLR         D5 ; D5 will serve as our index counter.
0000191E  6000 0078               1177                          BRA         FIND_MM_START_A
00001922                          1178                          
00001922                          1179      * display and start from the left
00001922                          1180      * MOVEM list is displayed as Ai-Aj/Dx-Dy                        
00001922  4243                    1181  DISPLAY_MOVEM_LIST_REV  CLR         D3 ; D3 is a flag which tells us if we find any address registers in the list.
00001924  4244                    1182                          CLR         D4 ; D4 is a temp value for our mask field.
00001926  4245                    1183                          CLR         D5 ; D5 will serve as our index counter.
00001928  6100 0006               1184                          BSR         REVERSE_MASK_FIELD
0000192C  6000 006A               1185                          BRA         FIND_MM_START_A
00001930                          1186  
00001930                          1187      * reverse the mask field if EA mode is -(An).
00001930  4240                    1188  REVERSE_MASK_FIELD      CLR         D0
00001932  4241                    1189                          CLR         D1                          ; D1 will receive new value
00001934  4242                    1190                          CLR         D2
00001936  3439 0000223E           1191                          MOVE.W      CURRENT_MASK_FIELD,D2
0000193C  303C 0010               1192                          MOVE        #16,D0                      ; Use D0 as counter
00001940  6100 000A               1193                          BSR         REVERSE_MASK_FIELD_LOOP
00001944  33C2 0000223E           1194                          MOVE.W      D2,CURRENT_MASK_FIELD
0000194A  4E75                    1195                          RTS
0000194C                          1196                          
0000194C  E34A                    1197  REVERSE_MASK_FIELD_LOOP LSL         #1,D2                       ; Shift MSB of D2 into X bit
0000194E  E251                    1198                          ROXR        #1,D1                       ; Shift X bit into MSB of D1
00001950  5340                    1199                          SUB         #1,D0                       ; count down
00001952  B07C 0000               1200                          CMP         #0,D0
00001956  6EF4                    1201                          BGT         REVERSE_MASK_FIELD_LOOP     ; Repeat until D0 reaches -1
00001958  3401                    1202                          MOVE        D1,D2                       ; Put new value back in D2
0000195A  4E75                    1203                          RTS
0000195C                          1204   
0000195C                          1205       * after finding start A, see if we only had one address register in the list.
0000195C  4246                    1206  CHECK_SINGLE_A          CLR         D6                  ; we use D6 as a temporary register (only in this method) to examine the value 1 higher than D5.
0000195E  1C05                    1207                          MOVE.B      D5,D6                
00001960  5206                    1208                          ADD.B       #1,D6
00001962  BC7C 000F               1209                          CMP         #15,D6              ; first, check if D5 is 15 or greater. (meaning D6 is 16 or greater.) If it is, there is no room for an end A.
00001966  6E00 0066               1210                          BGT         FIND_MM_START_D   ; This means we move on and look for start D.
0000196A  0D04                    1211                          BTST        D6,D4               ; otherwise, we have to compare the 1-greater value to our mask field.
0000196C  6700 0060               1212                          BEQ         FIND_MM_START_D   ; If the next value is 0, there is no end An.
00001970  6000 0048               1213                          BRA         FIND_MM_END_A     ; final possibility: there are more address registers and we must find the end An.
00001974                          1214                          
00001974                          1215       * After finding start D, see if we only had one data register in the list.
00001974  4246                    1216  CHECK_SINGLE_D          CLR         D6                  ; we use D6 as a temporary register (only in this method) to examine the value 1 higher than D5.
00001976  1C05                    1217                          MOVE.B      D5,D6                
00001978  5206                    1218                          ADD.B       #1,D6
0000197A  BC7C 0007               1219                          CMP         #7,D6                    ; first, check if D5 is 7 or greater. (meaning D6 is 8 or greater.) If it is, there is no room for an end D.
0000197E  6E00 012E               1220                          BGT         MOVEM_LIST_DISPLAY_DONE  ; This means we are done displaying the list.
00001982  0D04                    1221                          BTST        D6,D4                    ; otherwise, we have to compare the 1-greater value to our mask field.
00001984  6700 0128               1222                          BEQ         MOVEM_LIST_DISPLAY_DONE  ; If the next value is 0, there is no end An.
00001988  6000 0066               1223                          BRA         FIND_MM_END_D          ; final possibility: there are more data registers and we must find the end Dn.
0000198C                          1224                          
0000198C                          1225       * after finding startD, check to see if we should print a '/' before displaying it.
0000198C  B67C 0001               1226  CHECK_ADDR_IN_LIST_FLAG CMP         #1,D3
00001990  6700 00C6               1227                          BEQ         DISPLAY_SLASH
00001994  6000 00D2               1228                          BRA         DISP_MM_START_D
00001998                          1229                          
00001998                          1230       *find the starting address register in the list .                       
00001998  4245                    1231  FIND_MM_START_A         CLR         D5
0000199A  1A3C 0008               1232                          MOVE.B      #8,D5   ;start looking for start A at the 8th bit.           
0000199E  3839 0000223E           1233                          MOVE.W      CURRENT_MASK_FIELD,D4  
000019A4  6000 0002               1234                          BRA         FIND_MM_START_A_LOOP 
000019A8                          1235  
000019A8  0B04                    1236  FIND_MM_START_A_LOOP    BTST.L      D5,D4
000019AA  6600 005A               1237                          BNE         DISP_MM_START_A  
000019AE  5205                    1238                          ADD.B       #1,D5
000019B0  BA7C 0010               1239                          CMP         #16,D5   
000019B4  6DF2                    1240                          BLT         FIND_MM_START_A_LOOP
000019B6  6000 0016               1241                          BRA         FIND_MM_START_D        ; stop searching for start A once we reach 16.  
000019BA                          1242  
000019BA                          1243       *find the ending address register in the list. (start is found.)
000019BA  6000 0002               1244  FIND_MM_END_A           BRA         FIND_MM_END_A_LOOP
000019BE                          1245                          
000019BE                          1246       * if we get to this loop, we know for sure that we will need to display an end An at some point, and also that we have a start An.
000019BE  0B04                    1247  FIND_MM_END_A_LOOP      BTST.L      D5,D4
000019C0  6700 0066               1248                          BEQ         DISP_MM_END_A            ; BEQ instead of BNE, since we are looking for the next 0 to tell us our end An. 
000019C4  5205                    1249                          ADD.B       #1,D5                    ; (it will be 9 below the index where we find the 0.)
000019C6  BA7C 0010               1250                          CMP         #16,D5   
000019CA  6DF2                    1251                          BLT         FIND_MM_END_A_LOOP
000019CC  60EC                    1252                          BRA         FIND_MM_END_A            ; stop searching for end A once we reach 15.  
000019CE                          1253                       
000019CE                          1254       *find the starting data register in the list.                        
000019CE  4244                    1255  FIND_MM_START_D         CLR         D4                       ; do not clear D3, since it is a flag we will use if we find any Dn.     
000019D0  4245                    1256                          CLR         D5 
000019D2  1A3C 0000               1257                          MOVE.B      #0,D5                    ; start looking for start D at index 0.
000019D6  3839 0000223E           1258                          MOVE.W      CURRENT_MASK_FIELD,D4
000019DC  6000 0002               1259                          BRA         FIND_MM_START_D_LOOP
000019E0                          1260                          
000019E0  0B04                    1261  FIND_MM_START_D_LOOP    BTST.L      D5,D4
000019E2  66A8                    1262                          BNE         CHECK_ADDR_IN_LIST_FLAG  ; if we find the start D, check to see whether we need a '/', then display the start D. 
000019E4  5205                    1263                          ADD.B       #1,D5
000019E6  BA7C 0008               1264                          CMP         #8,D5   
000019EA  6DF4                    1265                          BLT         FIND_MM_START_D_LOOP
000019EC  6000 00C0               1266                          BRA         MOVEM_LIST_DISPLAY_DONE  ; stop searching for start D once we reach 8. 
000019F0                          1267                          
000019F0                          1268       *find the ending data register in the list. (start is found.)
000019F0  6000 0002               1269  FIND_MM_END_D           BRA         FIND_MM_END_D_LOOP
000019F4                          1270  
000019F4                          1271       * if we get to this loop, we know for sure that we will need to display an end Dn at some point, and also that we have a start Dn.
000019F4  0B04                    1272  FIND_MM_END_D_LOOP      BTST.L      D5,D4
000019F6  6700 008C               1273                          BEQ         DISP_MM_END_D            ; BEQ instead of BNE, since we are looking for the next 0 to tell us our end Dn. 
000019FA  5205                    1274                          ADD.B       #1,D5                    ; (it will be 1 below the index where we find the 0.)
000019FC  BA7C 0008               1275                          CMP         #8,D5   
00001A00  6DF2                    1276                          BLT         FIND_MM_END_D_LOOP
00001A02  6000 0080               1277                          BRA         DISP_MM_END_D            ; stop searching for end D once we reach 8. 
00001A06                          1278                          
00001A06                          1279       *display the starting address register in the list.
00001A06  43F9 000021F2           1280  DISP_MM_START_A         LEA         MSG_A,A1          ; 'A'
00001A0C  103C 000E               1281                          MOVE.B      #14,D0      
00001A10  4E4F                    1282                          TRAP        #15
00001A12                          1283                          
00001A12  2205                    1284                          MOVE.L      D5,D1             ; print out the number of the starting address register in the list
00001A14  5141                    1285                          SUBQ        #8,D1             ; note that we have to subtract 8 because the index is 8 higher than the address register value.
00001A16  143C 0010               1286                          MOVE.B      #16,D2
00001A1A  103C 000F               1287                          MOVE.B      #15,D0
00001A1E  4E4F                    1288                          TRAP        #15
00001A20                          1289                          
00001A20  163C 0001               1290                          MOVE.B      #1,D3             ; D3 is flagged as 1, telling us we will need a / if we find any data registers.
00001A24                          1291                          
00001A24  6000 FF36               1292                          BRA         CHECK_SINGLE_A    ; see if we only had one A.
00001A28                          1293  
00001A28                          1294       *display the ending address register in the list.                        
00001A28  43F9 00001FCB           1295  DISP_MM_END_A           LEA         MINUS,A1        ; '-'
00001A2E  103C 000E               1296                          MOVE.B      #14,D0      
00001A32  4E4F                    1297                          TRAP        #15
00001A34                          1298  
00001A34  43F9 000021F2           1299                          LEA         MSG_A,A1        ; 'A'
00001A3A  103C 000E               1300                          MOVE.B      #14,D0      
00001A3E  4E4F                    1301                          TRAP        #15
00001A40                          1302                          
00001A40  2205                    1303                          MOVE.L      D5,D1           ; print out the number of the ending address register in the list
00001A42  5141                    1304                          SUBQ        #8,D1           ; since we are looking for the 'last 1', we subtract 9, since we found a 0 at the index in question.
00001A44  5341                    1305                          SUBQ        #1,D1
00001A46  143C 0010               1306                          MOVE.B      #16,D2
00001A4A  103C 000F               1307                          MOVE.B      #15,D0
00001A4E  4E4F                    1308                          TRAP        #15
00001A50                          1309                          
00001A50                          1310                          ;No need to change D5, since it will be reset at the start of the next loop anyway.
00001A50  163C 0001               1311                          MOVE.B      #1,D3           ; D3 is flagged as 1, telling us we will need a / if we find any data registers.
00001A54                          1312  
00001A54  6000 FF78               1313                          BRA         FIND_MM_START_D
00001A58                          1314                          
00001A58                          1315     * display a '/'. (not always necessecary.)
00001A58  43F9 00001FCD           1316  DISPLAY_SLASH           LEA         SLASH,A1          ; '/'
00001A5E  103C 000E               1317                          MOVE.B      #14,D0      
00001A62  4E4F                    1318                          TRAP        #15
00001A64                          1319  
00001A64  6000 0002               1320                          BRA         DISP_MM_START_D  
00001A68                          1321                          
00001A68                          1322     * display the starting data register in the list.
00001A68  43F9 000021F0           1323  DISP_MM_START_D         LEA         MSG_D,A1          ; 'D'
00001A6E  103C 000E               1324                          MOVE.B      #14,D0      
00001A72  4E4F                    1325                          TRAP        #15
00001A74                          1326                          
00001A74  2205                    1327                          MOVE.L      D5,D1             ; print out the number of the starting data register in the list
00001A76  143C 0010               1328                          MOVE.B      #16,D2
00001A7A  103C 000F               1329                          MOVE.B      #15,D0
00001A7E  4E4F                    1330                          TRAP        #15
00001A80                          1331                          
00001A80  6000 FEF2               1332                          BRA         CHECK_SINGLE_D    ; see if we only had one Dn.
00001A84                          1333                          
00001A84                          1334     * display the ending data register in the list.
00001A84  43F9 00001FCB           1335  DISP_MM_END_D           LEA         MINUS,A1        ; '-'
00001A8A  103C 000E               1336                          MOVE.B      #14,D0      
00001A8E  4E4F                    1337                          TRAP        #15
00001A90                          1338  
00001A90  43F9 000021F0           1339                          LEA         MSG_D,A1          ; 'D'
00001A96  103C 000E               1340                          MOVE.B      #14,D0      
00001A9A  4E4F                    1341                          TRAP        #15
00001A9C                          1342                          
00001A9C  2205                    1343                          MOVE.L      D5,D1             ; print out the number of the ending data register in the list
00001A9E  5341                    1344                          SUBQ        #1,D1             ; since we are looking for the 'last 1', we subtract 1, since we found a 0 at the index in question.
00001AA0                          1345  
00001AA0  143C 0010               1346                          MOVE.B      #16,D2
00001AA4  103C 000F               1347                          MOVE.B      #15,D0
00001AA8  4E4F                    1348                          TRAP        #15
00001AAA                          1349                          
00001AAA  6000 0002               1350                          BRA         MOVEM_LIST_DISPLAY_DONE
00001AAE                          1351                          
00001AAE  4E75                    1352  MOVEM_LIST_DISPLAY_DONE RTS ;not sure if this is right, but can't test it at the moment.
00001AB0                          1353   
00001AB0                          1354  *-----------------------ORI-related Subroutines------------------------------------
00001AB0  4EF8 1004               1355  ORI_FOUND               JMP         STOP ;TODO: case for ORI found
00001AB4                          1356  
00001AB4                          1357   *----------------------ANDI-related Subroutines------------------------------------
00001AB4  4EF8 1004               1358  ANDI_FOUND              JMP         STOP ;TODO: case for ANDI found
00001AB8                          1359  
00001AB8                          1360   *----------------------SUBI-related Subroutines------------------------------------
00001AB8  4EF8 1004               1361  SUBI_FOUND              JMP         STOP ;TODO: case for SUBI found
00001ABC                          1362  
00001ABC                          1363   *----------------------ADDI-related Subroutines------------------------------------
00001ABC  4EF8 1004               1364  ADDI_FOUND              JMP         STOP ;TODO: case for ADDI found
00001AC0                          1365   
00001AC0                          1366  *-----------------------EORI-related Subroutines------------------------------------
00001AC0  4EF8 1004               1367  EORI_FOUND              JMP         STOP ;TODO: case for EORI found
00001AC4                          1368   
00001AC4                          1369  *-----------------------CMPI-related Subroutines------------------------------------
00001AC4  4EF8 1004               1370  CMPI_FOUND              JMP         STOP ;TODO: case for CMPI found
00001AC8                          1371  
00001AC8                          1372  *-----------------------NEGX-related Subroutines------------------------------------
00001AC8  4EF8 1004               1373  NEGX_FOUND              JMP         STOP ;TODO: case for NEGX found 
00001ACC                          1374  
00001ACC                          1375  *-----------------------CLR-related Subroutines------------------------------------
00001ACC  4EF8 1004               1376  CLR_FOUND               JMP         STOP ;TODO: case for CLR found 
00001AD0                          1377  
00001AD0                          1378  *-----------------------NEG-related Subroutines------------------------------------
00001AD0  4EF8 1004               1379  NEG_FOUND               JMP         STOP ;TODO: case for NEG found 
00001AD4                          1380  
00001AD4                          1381  *-----------------------NOT-related Subroutines------------------------------------
00001AD4  4EF8 1004               1382  NOT_FOUND               JMP         STOP ;TODO: case for NOT found 
00001AD8                          1383  
00001AD8                          1384  *-----------------------ADD-related Subroutines------------------------------------
00001AD8                          1385  ADD_FOUND               ; TODO: case for ADD (next goal). Note that the program can definitely parse ADD instructions and read up to this point.
00001AD8                          1386                          ; start by reading the size and direction.
00001AD8                          1387                          ; note ADD always uses a data register as one of its operands, and the register number is always stored in destination register part of the word.
00001AD8  4EF8 1004               1388                          JMP         STOP 
00001ADC                          1389  
00001ADC                          1390  *-----------------------ADDX-related Subroutines------------------------------------
00001ADC  4EF8 1004               1391  ADDX_FOUND              JMP         STOP ;TODO: case for ADDX
00001AE0                          1392  
00001AE0                          1393  *-----------------------ADDA-related Subroutines------------------------------------
00001AE0  4EF8 1004               1394  ADDA_FOUND              JMP         STOP ;TODO: case for ADDA
00001AE4                          1395                      
00001AE4                          1396  *###################### END OPCODE ##################################
00001AE4                          1397  *###################### BEGIN EA ##################################
00001AE4                          1398  *** EA Subroutines are kept here ***
00001AE4                          1399  *----------------------Check the destination register of the current word.-------------
00001AE4  4244                    1400  READ_DEST_REG           CLR         D4
00001AE6  4239 00002230           1401                          CLR.B       CURRENT_DEST_REG
00001AEC  3839 00002218           1402                          MOVE.W      CURRENT_WORD,D4
00001AF2  0244 0E00               1403                          ANDI.W      #FILT_DEST_REG,D4       ; turn D4 into 0000 XXX0 0000 0000
00001AF6  E04C                    1404                          LSR.W       #8,D4                   ; turn D4 into 0000 0000 0000 0XXX
00001AF8  E24C                    1405                          LSR.W       #1,D4                   ; 9 would be invalid, so we shift 8, then 1
00001AFA  13C4 00002230           1406                          MOVE.B      D4,CURRENT_DEST_REG
00001B00  4E75                    1407                          RTS
00001B02                          1408  
00001B02                          1409  *----------------------Check the destination mode of the current word.-------------
00001B02                          1410  *(assuming the destination is where it would be in MOVE).
00001B02  4244                    1411  READ_DEST_MODE          CLR         D4
00001B04  4239 0000222F           1412                          CLR.B       CURRENT_DEST_MD
00001B0A  3839 00002218           1413                          MOVE.W      CURRENT_WORD,D4
00001B10  0244 01C0               1414                          ANDI.W      #FILT_DEST_MD,D4        ; turn D4 into 0000 000X XX00 0000
00001B14  EC4C                    1415                          LSR.W       #6,D4                   ; turn D4 into 0000 0000 0000 0XXX
00001B16  13C4 0000222F           1416                          MOVE.B      D4,CURRENT_DEST_MD
00001B1C  4E75                    1417                          RTS
00001B1E                          1418  
00001B1E                          1419  ;By this point, CURRENT WORD holds the first 16 bits of an instruction we are looking at.
00001B1E                          1420  ;(we should already know the OPcode by this point, so this will be called by various OPcode subroutines.)
00001B1E                          1421  *---------------------- Check the source mode of the current word.--------------------
00001B1E                          1422  *(assuming the source is where it would be in MOVE).
00001B1E  4244                    1423  READ_SOURCE_MODE        CLR         D4
00001B20  4239 0000222D           1424                          CLR.B       CURRENT_SRC_MD
00001B26  3839 00002218           1425                          MOVE.W      CURRENT_WORD,D4
00001B2C  0244 0038               1426                          ANDI.W      #FILT_SRC_MD,D4                 ; turn source mode into 0000 0000 00XX X000
00001B30  E64C                    1427                          LSR.W       #3,D4                           ; turn source mode into 0000 0000 0000 0XXX
00001B32  13C4 0000222D           1428                          MOVE.B      D4,CURRENT_SRC_MD
00001B38  4E75                    1429                          RTS
00001B3A                          1430                          
00001B3A                          1431  *----------------------Check the source register of the current word.-----------------
00001B3A  4244                    1432  READ_SOURCE_REG         CLR         D4
00001B3C  4239 0000222E           1433                          CLR.B       CURRENT_SRC_REG
00001B42  3839 00002218           1434                          MOVE.W      CURRENT_WORD,D4
00001B48  0244 0007               1435                          ANDI.W      #FILT_SRC_REG,D4                ; turn D4 into 0000 0000 0000 0XXX. (no need for LSR in this case.)
00001B4C  13C4 0000222E           1436                          MOVE.B      D4,CURRENT_SRC_REG
00001B52  4E75                    1437                          RTS
00001B54                          1438  *--------TODO: READ_OP_SIZE---------
00001B54                          1439                         
00001B54                          1440  *----------------------Read additional source data associated with the current word (if necessary).----------------- 
00001B54                          1441  *This needs to postincrement A5 as necessary for each case.
00001B54  4279 00002236           1442  READ_SOURCE_DATA        CLR         CURRENT_SRC_DATA
00001B5A  4279 00002232           1443                          CLR         CURRENT_DATA
00001B60  0C39 0007 0000222D      1444                          CMP.B       #CONST_ADDR_MISC_MD,CURRENT_SRC_MD ; check the source mode
00001B68  6700 0004               1445                          BEQ         CONFIRM_READ_SRC_DATA              ; see if we have a source mode that requires additional data.               
00001B6C  4E75                    1446                          RTS
00001B6E                          1447                          
00001B6E  4239 0000222C           1448  CONFIRM_READ_SRC_DATA   CLR.B       CURRENT_REG
00001B74  13F9 0000222E 0000222C  1449                          MOVE.B      CURRENT_SRC_REG,CURRENT_REG
00001B7E  6100 00BC               1450                          BSR         CONFIRM_READ_DATA
00001B82  23F9 00002232 00002236  1451                          MOVE.L      CURRENT_DATA,CURRENT_SRC_DATA
00001B8C  4E75                    1452                          RTS
00001B8E                          1453   
00001B8E                          1454  *----------------------Read additional destination data associated with the current word (if necessary).----------------- 
00001B8E                          1455  *This needs to postincrement A5 as necessary.                       
00001B8E  4279 0000223A           1456  READ_DEST_DATA          CLR         CURRENT_DEST_DATA
00001B94  4279 00002232           1457                          CLR         CURRENT_DATA
00001B9A  0C39 0007 0000222F      1458                          CMP.B       #CONST_ADDR_MISC_MD,CURRENT_DEST_MD  ; check the destination mode.
00001BA2  6700 0004               1459                          BEQ         CONFIRM_READ_DEST_DATA               ; see if we have a destination mode that requires additional data.                  
00001BA6  4E75                    1460                          RTS
00001BA8                          1461                                              
00001BA8  4239 0000222C           1462  CONFIRM_READ_DEST_DATA  CLR.B       CURRENT_REG
00001BAE  13F9 00002230 0000222C  1463                          MOVE.B      CURRENT_DEST_REG,CURRENT_REG
00001BB8  6100 0082               1464                          BSR         CONFIRM_READ_DATA
00001BBC  23F9 00002232 0000223A  1465                          MOVE.L      CURRENT_DATA,CURRENT_DEST_DATA
00001BC6  4E75                    1466                          RTS
00001BC8                          1467  
00001BC8                          1468  *-----------------------Read additional data in ways that are direction-oriented.--------------------------------------
00001BC8                          1469  
00001BC8                          1470      *Left
00001BC8  4279 0000221E           1471  READ_LEFT_DATA          CLR         CURRENT_L_DATA
00001BCE  4279 00002232           1472                          CLR         CURRENT_DATA
00001BD4  0C39 0007 0000221B      1473                          CMP.B       #CONST_ADDR_MISC_MD,CURRENT_L_MD     ; check the left mode.
00001BDC  6700 0004               1474                          BEQ         CONFIRM_READ_LEFT_DATA               ; see if we have a mode that requires additional data.                  
00001BE0  4E75                    1475                          RTS
00001BE2                          1476                                              
00001BE2  4239 0000222C           1477  CONFIRM_READ_LEFT_DATA  CLR.B       CURRENT_REG
00001BE8  13F9 0000221C 0000222C  1478                          MOVE.B      CURRENT_L_REG,CURRENT_REG
00001BF2  6100 0048               1479                          BSR         CONFIRM_READ_DATA
00001BF6  23F9 00002232 0000221E  1480                          MOVE.L      CURRENT_DATA,CURRENT_L_DATA
00001C00  4E75                    1481                          RTS
00001C02                          1482                          
00001C02                          1483      *Right
00001C02  4279 00002224           1484  READ_RIGHT_DATA         CLR         CURRENT_R_DATA
00001C08  4279 00002232           1485                          CLR         CURRENT_DATA
00001C0E  0C39 0007 00002222      1486                          CMP.B       #CONST_ADDR_MISC_MD,CURRENT_R_MD ; check the right mode.
00001C16  6700 0004               1487                          BEQ         CONFIRM_READ_RIGHT_DATA              ; see if we have a mode that requires additional data.                  
00001C1A  4E75                    1488                          RTS
00001C1C                          1489                                              
00001C1C  4239 0000222C           1490  CONFIRM_READ_RIGHT_DATA CLR.B       CURRENT_REG
00001C22  13F9 00002223 0000222C  1491                          MOVE.B      CURRENT_R_REG,CURRENT_REG
00001C2C  6100 000E               1492                          BSR         CONFIRM_READ_DATA
00001C30  23F9 00002232 00002224  1493                          MOVE.L      CURRENT_DATA,CURRENT_R_DATA
00001C3A  4E75                    1494                          RTS
00001C3C                          1495                          
00001C3C                          1496  *-----------------------Read some additional data.----------------------------------------------------------
00001C3C                          1497        ; This same subroutine is used for reading any kind of data, as long as CURRENT_REG is set beforehand.
00001C3C                          1498        ; By this point, CURRENT_REG holds whatever register we currently care about. (could also use CURRENT_REG)         
00001C3C  0C39 0002 0000222C      1499  CONFIRM_READ_DATA       CMP.B       #CONST_COUNTR_DISPLC_REG,CURRENT_REG      ; see if we are reading counter w/ displacement
00001C44  6700 0034               1500                          BEQ         READ_COUNTR_DISPLC_DATA
00001C48                          1501                     
00001C48  0C39 0003 0000222C      1502                          CMP.B       #CONST_COUNTR_INDEX_REG,CURRENT_REG       ; see if we are reading counter w/ index
00001C50  6700 002A               1503                          BEQ         READ_COUNTR_INDEX_DATA
00001C54                          1504                          
00001C54  0C39 0000 0000222C      1505                          CMP.B       #CONST_ABS_SHORT_REG,CURRENT_REG          ; see if we are reading absolute short address
00001C5C  6700 0020               1506                          BEQ         READ_ABS_SHORT_DATA
00001C60                          1507                          
00001C60  0C39 0001 0000222C      1508                          CMP.B       #CONST_ABS_LONG_REG,CURRENT_REG           ; see if we are reading absolute long address
00001C68  6700 001C               1509                          BEQ         READ_ABS_LONG_DATA 
00001C6C                          1510                          
00001C6C  0C39 0004 0000222C      1511                          CMP.B       #CONST_IMMEDIATE_REG,CURRENT_REG          ; see if we are reading immediate data
00001C74  6700 0018               1512                          BEQ         READ_IMMEDIATE_DATA
00001C78                          1513       
00001C78  4E75                    1514                          RTS
00001C7A                          1515                          
00001C7A                          1516  ; TODO: each of these SRs should increment A5 by the proper amount while also storing the correct data in CURRENT_DATA.
00001C7A  4E75                    1517  READ_COUNTR_DISPLC_DATA RTS ; TODO: read data for counter w/ displacement (d16,PC)
00001C7C                          1518  
00001C7C  4E75                    1519  READ_COUNTR_INDEX_DATA  RTS ; TODO: read data for counter w/ index        (d16,PC,Xn)
00001C7E                          1520  
00001C7E                          1521  *-----------------------Read additional absolute word address---------------------------
00001C7E  33DD 00002232           1522  READ_ABS_SHORT_DATA     MOVE.W      (A5)+,CURRENT_DATA ; read data for absolute short address  (xxx).W
00001C84  4E75                    1523                          RTS
00001C86                          1524                          
00001C86                          1525  *-----------------------Read additional absolute long address---------------------------
00001C86  23DD 00002232           1526  READ_ABS_LONG_DATA      MOVE.L      (A5)+,CURRENT_DATA ; read data for absolute long address   (xxx).L
00001C8C  4E75                    1527                          RTS 
00001C8E                          1528  
00001C8E                          1529  *-----------------------Read additional immediate data---------------------------
00001C8E  0C39 0000 0000221A      1530  READ_IMMEDIATE_DATA     CMP.B       #BYTE_SIZE,CURRENT_OP_SIZE   ; see if we are reading immediate byte data
00001C96  6700 001C               1531                          BEQ         READ_IMMEDIATE_DATA_W
00001C9A                          1532                          
00001C9A  0C39 0001 0000221A      1533                          CMP.B       #WORD_SIZE,CURRENT_OP_SIZE   ; see if we are reading immediate word data
00001CA2  6700 0010               1534                          BEQ         READ_IMMEDIATE_DATA_W
00001CA6                          1535                          
00001CA6  0C39 0002 0000221A      1536                          CMP.B       #LONG_SIZE,CURRENT_OP_SIZE   ; see if we are reading immediate long data
00001CAE  6700 0012               1537                          BEQ         READ_IMMEDIATE_DATA_L
00001CB2                          1538                          ;TODO: error case goes here
00001CB2  4E75                    1539                          RTS
00001CB4                          1540  
00001CB4  4279 00002232           1541  READ_IMMEDIATE_DATA_W   CLR         CURRENT_DATA
00001CBA  33DD 00002232           1542                          MOVE.W      (A5)+,CURRENT_DATA
00001CC0  4E75                    1543                          RTS
00001CC2                          1544                          
00001CC2  4279 00002232           1545  READ_IMMEDIATE_DATA_L   CLR         CURRENT_DATA
00001CC8  23DD 00002232           1546                          MOVE.L      (A5)+,CURRENT_DATA
00001CCE  4E75                    1547                          RTS
00001CD0                          1548                          
00001CD0                          1549  *----------------------Display the source for the current instruction.-----------------
00001CD0                          1550  *by this point, error checking should already be done and CURRENT_SRC_MD and CURRENT_SRC_REG should have the data we need.
00001CD0  4239 0000222B           1551  DISPLAY_SOURCE          CLR.B       CURRENT_MD
00001CD6  4239 0000222C           1552                          CLR.B       CURRENT_REG
00001CDC  42B9 00002232           1553                          CLR.L       CURRENT_DATA
00001CE2                          1554                          
00001CE2  13F9 0000222D 0000222B  1555                          MOVE.B      CURRENT_SRC_MD,CURRENT_MD
00001CEC  13F9 0000222E 0000222C  1556                          MOVE.B      CURRENT_SRC_REG,CURRENT_REG    
00001CF6  23F9 00002236 00002232  1557                          MOVE.L      CURRENT_SRC_DATA,CURRENT_DATA
00001D00  6100 00A6               1558                          BSR         CHECK_ADDRESSING_MODES   
00001D04  4E75                    1559                          RTS  
00001D06                          1560                          
00001D06                          1561  *----------------------Display the destination for the current instruction.-----------------
00001D06                          1562  *by this point, error checking should already be done and CURRENT_DEST_MD and CURRENT_DEST_REG should have the data we need.
00001D06  4239 0000222B           1563  DISPLAY_DEST            CLR.B       CURRENT_MD
00001D0C  4239 0000222C           1564                          CLR.B       CURRENT_REG
00001D12  42B9 00002232           1565                          CLR.L       CURRENT_DATA
00001D18                          1566                          
00001D18  13F9 0000222F 0000222B  1567                          MOVE.B      CURRENT_DEST_MD,CURRENT_MD
00001D22  13F9 00002230 0000222C  1568                          MOVE.B      CURRENT_DEST_REG,CURRENT_REG    
00001D2C  23F9 0000223A 00002232  1569                          MOVE.L      CURRENT_DEST_DATA,CURRENT_DATA
00001D36  6100 0070               1570                          BSR         CHECK_ADDRESSING_MODES     
00001D3A  4E75                    1571                          RTS  
00001D3C                          1572  
00001D3C                          1573  *----------------------Display the left side of the current instruction.-----------------------                        
00001D3C  4239 0000222B           1574  DISPLAY_LEFT            CLR.B       CURRENT_MD
00001D42  4239 0000222C           1575                          CLR.B       CURRENT_REG
00001D48  42B9 00002232           1576                          CLR.L       CURRENT_DATA
00001D4E                          1577                          
00001D4E  13F9 0000221B 0000222B  1578                          MOVE.B      CURRENT_L_MD,CURRENT_MD
00001D58  13F9 0000221C 0000222C  1579                          MOVE.B      CURRENT_L_REG,CURRENT_REG    
00001D62  23F9 0000221E 00002232  1580                          MOVE.L      CURRENT_L_DATA,CURRENT_DATA
00001D6C  6100 003A               1581                          BSR         CHECK_ADDRESSING_MODES   
00001D70  4E75                    1582                          RTS  
00001D72                          1583                          
00001D72                          1584  *----------------------Display the right side of the current instruction.-----------------------  
00001D72  4239 0000222B           1585  DISPLAY_RIGHT           CLR.B       CURRENT_MD
00001D78  4239 0000222C           1586                          CLR.B       CURRENT_REG
00001D7E  42B9 00002232           1587                          CLR.L       CURRENT_DATA
00001D84                          1588                          
00001D84  13F9 00002222 0000222B  1589                          MOVE.B      CURRENT_R_MD,CURRENT_MD
00001D8E  13F9 00002223 0000222C  1590                          MOVE.B      CURRENT_R_REG,CURRENT_REG    
00001D98  23F9 00002224 00002232  1591                          MOVE.L      CURRENT_R_DATA,CURRENT_DATA
00001DA2  6100 0004               1592                          BSR         CHECK_ADDRESSING_MODES   
00001DA6  4E75                    1593                          RTS  
00001DA8                          1594                          
00001DA8                          1595  *-----------------------Mode checks (for displaying)---------
00001DA8                          1596  *these do not care whether the mode is for source or destination.
00001DA8  0C39 0000 0000222B      1597  CHECK_ADDRESSING_MODES  CMP.B       #CONST_DATA_REG_MD,CURRENT_MD   ; check for CURRENT_MD = ...0000
00001DB0  6700 0058               1598                          BEQ         DISPLAY_DATA_REG
00001DB4  0C39 0001 0000222B      1599                          CMP.B       #CONST_ADDR_REG_MD,CURRENT_MD    ; check for CURRENT_MD = ...0001
00001DBC  6700 006C               1600                          BEQ         DISPLAY_ADDR_REG
00001DC0  0C39 0002 0000222B      1601                          CMP.B       #CONST_ADDR_IND_MD,CURRENT_MD    ; check for CURRENT_MD = ...0010
00001DC8  6700 0080               1602                          BEQ         DISPLAY_ADDR_IND
00001DCC  0C39 0003 0000222B      1603                          CMP.B       #CONST_ADDR_INCR_MD,CURRENT_MD   ; check for CURRENT_MD = ...0011
00001DD4  6700 00AC               1604                          BEQ         DISPLAY_ADDR_INCR
00001DD8  0C39 0004 0000222B      1605                          CMP.B       #CONST_ADDR_DECR_MD,CURRENT_MD   ; check for CURRENT_MD = ...0100
00001DE0  6700 00E4               1606                          BEQ         DISPLAY_ADDR_DECR
00001DE4  0C39 0005 0000222B      1607                          CMP.B       #CONST_ADDR_DISPLC_MD,CURRENT_MD ; check for CURRENT_MD = ...0101
00001DEC  6700 011C               1608                          BEQ         DISPLAY_ADDR_DISPLC
00001DF0  0C39 0006 0000222B      1609                          CMP.B       #CONST_ADDR_INDEX_MD,CURRENT_MD  ; check for CURRENT_MD = ...0110
00001DF8  6700 0112               1610                          BEQ         DISPLAY_ADDR_INDEX
00001DFC  0C39 0007 0000222B      1611                          CMP.B       #CONST_ADDR_MISC_MD,CURRENT_MD   ; check for CURRENT_MD = ...0111
00001E04  6700 0108               1612                          BEQ         CHECK_MISC_ADDRESSINGS
00001E08                          1613                          ;TODO: error cases? 
00001E08  4E75                    1614                          RTS
00001E0A                          1615  
00001E0A                          1616  ; case for displaying data register.          
00001E0A  43F9 000021F0           1617  DISPLAY_DATA_REG        LEA         MSG_D,A1               ; print out 'D' (later, send this to dislpay buffer)
00001E10  103C 000E               1618                          MOVE.B      #14,D0
00001E14  4E4F                    1619                          TRAP        #15
00001E16                          1620                          
00001E16  4241                    1621                          CLR         D1
00001E18  1239 0000222C           1622                          MOVE.B      (CURRENT_REG),D1      ; print out the number of the data register.
00001E1E  143C 0010               1623                          MOVE.B      #16,D2
00001E22  103C 000F               1624                          MOVE.B      #15,D0
00001E26  4E4F                    1625                          TRAP        #15
00001E28                          1626                          
00001E28  4E75                    1627                          RTS
00001E2A                          1628  
00001E2A                          1629  ; case for displaying address register. 
00001E2A  43F9 000021F2           1630  DISPLAY_ADDR_REG        LEA         MSG_A,A1               ; print out 'A'
00001E30  103C 000E               1631                          MOVE.B      #14,D0
00001E34  4E4F                    1632                          TRAP        #15
00001E36                          1633                          
00001E36  4241                    1634                          CLR         D1
00001E38  1239 0000222C           1635                          MOVE.B      (CURRENT_REG),D1       ; print out the number of the data register.
00001E3E  143C 0010               1636                          MOVE.B      #16,D2
00001E42  103C 000F               1637                          MOVE.B      #15,D0
00001E46  4E4F                    1638                          TRAP        #15
00001E48                          1639                          
00001E48  4E75                    1640                          RTS
00001E4A                          1641  
00001E4A                          1642  ; case for displaying address register indirect.                        
00001E4A  43F9 00001FC5           1643  DISPLAY_ADDR_IND        LEA         OPEN_PARENS,A1         ; print out '(' (later, send this to dislpay buffer)
00001E50  103C 000E               1644                          MOVE.B      #14,D0
00001E54  4E4F                    1645                          TRAP        #15
00001E56                          1646                          
00001E56  43F9 000021F2           1647                          LEA         MSG_A,A1               ; print out 'A'
00001E5C  103C 000E               1648                          MOVE.B      #14,D0
00001E60  4E4F                    1649                          TRAP        #15
00001E62                          1650                          
00001E62  4241                    1651                          CLR         D1
00001E64  1239 0000222C           1652                          MOVE.B      (CURRENT_REG),D1      ; print out the number of the data register.
00001E6A  143C 0010               1653                          MOVE.B      #16,D2
00001E6E  103C 000F               1654                          MOVE.B      #15,D0
00001E72  4E4F                    1655                          TRAP        #15
00001E74                          1656                          
00001E74  43F9 00001FC7           1657                          LEA         CLOSE_PARENS,A1       ; print out ')'
00001E7A  103C 000E               1658                          MOVE.B      #14,D0
00001E7E  4E4F                    1659                          TRAP        #15
00001E80                          1660                          
00001E80  4E75                    1661                          RTS
00001E82                          1662  
00001E82                          1663  ; case for displaying address indirect postincrement.
00001E82  43F9 00001FC5           1664  DISPLAY_ADDR_INCR       LEA         OPEN_PARENS,A1        ; print out '(' (later, send this to dislpay buffer)
00001E88  103C 000E               1665                          MOVE.B      #14,D0
00001E8C  4E4F                    1666                          TRAP        #15
00001E8E                          1667                          
00001E8E  43F9 000021F2           1668                          LEA         MSG_A,A1              ; print out 'A'
00001E94  103C 000E               1669                          MOVE.B      #14,D0
00001E98  4E4F                    1670                          TRAP        #15
00001E9A                          1671                          
00001E9A  4241                    1672                          CLR         D1
00001E9C  1239 0000222C           1673                          MOVE.B      (CURRENT_REG),D1      ; print out the number of the data register.
00001EA2  143C 0010               1674                          MOVE.B      #16,D2
00001EA6  103C 000F               1675                          MOVE.B      #15,D0
00001EAA  4E4F                    1676                          TRAP        #15
00001EAC                          1677                          
00001EAC  43F9 00001FC7           1678                          LEA         CLOSE_PARENS,A1       ; print out ')'
00001EB2  103C 000E               1679                          MOVE.B      #14,D0
00001EB6  4E4F                    1680                          TRAP        #15
00001EB8                          1681                          
00001EB8  43F9 00001FC9           1682                          LEA         PLUS,A1               ; print out '+'
00001EBE  103C 000E               1683                          MOVE.B      #14,D0
00001EC2  4E4F                    1684                          TRAP        #15
00001EC4                          1685                          
00001EC4  4E75                    1686                          RTS
00001EC6                          1687                          
00001EC6                          1688  ; case for displaying address indirect preedecrement mode.
00001EC6  43F9 00001FCB           1689  DISPLAY_ADDR_DECR       LEA         MINUS,A1               ; print out '-'
00001ECC  103C 000E               1690                          MOVE.B      #14,D0
00001ED0  4E4F                    1691                          TRAP        #15                                           
00001ED2                          1692  
00001ED2  43F9 00001FC5           1693                          LEA         OPEN_PARENS,A1        ; print out '(' (later, send this to dislpay buffer)
00001ED8  103C 000E               1694                          MOVE.B      #14,D0
00001EDC  4E4F                    1695                          TRAP        #15
00001EDE                          1696                          
00001EDE  43F9 000021F2           1697                          LEA         MSG_A,A1              ; print out 'A'
00001EE4  103C 000E               1698                          MOVE.B      #14,D0
00001EE8  4E4F                    1699                          TRAP        #15
00001EEA                          1700                          
00001EEA  4241                    1701                          CLR         D1
00001EEC  1239 0000222C           1702                          MOVE.B      (CURRENT_REG),D1      ; print out the number of the data register.
00001EF2  143C 0010               1703                          MOVE.B      #16,D2
00001EF6  103C 000F               1704                          MOVE.B      #15,D0
00001EFA  4E4F                    1705                          TRAP        #15
00001EFC                          1706                          
00001EFC  43F9 00001FC7           1707                          LEA         CLOSE_PARENS,A1       ; print out ')'
00001F02  103C 000E               1708                          MOVE.B      #14,D0
00001F06  4E4F                    1709                          TRAP        #15
00001F08                          1710                          
00001F08  4E75                    1711                          RTS     
00001F0A                          1712  
00001F0A                          1713  DISPLAY_ADDR_DISPLC     ;TODO: case for source mode is address with displacement mode.
00001F0A  4E75                    1714                          RTS    
00001F0C                          1715  
00001F0C                          1716  DISPLAY_ADDR_INDEX      ;TODO: case for source mode is address with index mode.
00001F0C  4E75                    1717                          RTS 
00001F0E                          1718  
00001F0E                          1719  *-----------------------Register checks (for displaying only)---------
00001F0E                          1720  *these do not care whether the register is for source or destination.
00001F0E                          1721  *not for cases where reg is simply a number (like D5, A5, (A5), etc),
00001F0E                          1722  *only for miscellaneous addressings where mode is 111.                        
00001F0E  0C39 0002 0000222C      1723  CHECK_MISC_ADDRESSINGS  CMP.B       #CONST_COUNTR_DISPLC_REG,CURRENT_REG
00001F16  6700 0034               1724                          BEQ         DISPLAY_COUNTR_DISPLC
00001F1A                          1725                          
00001F1A  0C39 0003 0000222C      1726                          CMP.B       #CONST_COUNTR_INDEX_REG,CURRENT_REG
00001F22  6700 002A               1727                          BEQ         DISPLAY_COUNTR_INDEX
00001F26                          1728                          
00001F26  0C39 0000 0000222C      1729                          CMP.B       #CONST_ABS_SHORT_REG,CURRENT_REG
00001F2E  6700 0020               1730                          BEQ         DISPLAY_ABS_SHORT
00001F32                          1731                          
00001F32  0C39 0001 0000222C      1732                          CMP.B       #CONST_ABS_LONG_REG,CURRENT_REG
00001F3A  6700 0034               1733                          BEQ         DISPLAY_ABS_LONG
00001F3E                          1734                          
00001F3E  0C39 0004 0000222C      1735                          CMP.B       #CONST_IMMEDIATE_REG,CURRENT_REG
00001F46  6700 0048               1736                          BEQ         DISPLAY_IMMEDIATE
00001F4A                          1737                          
00001F4A                          1738                          ; TODO: error case?
00001F4A                          1739                          
00001F4A  4E75                    1740                          RTS
00001F4C                          1741                          
00001F4C  4E75                    1742  DISPLAY_COUNTR_DISPLC   RTS         ;TODO   
00001F4E                          1743  
00001F4E  4E75                    1744  DISPLAY_COUNTR_INDEX    RTS         ;TODO   
00001F50                          1745  
00001F50  43F9 00001FBF           1746  DISPLAY_ABS_SHORT       LEA         DOLLAR,A1             ; print out '$'. 
00001F56  103C 000E               1747                          MOVE.B      #14,D0
00001F5A  4E4F                    1748                          TRAP        #15
00001F5C                          1749  
00001F5C  4241                    1750                          CLR         D1
00001F5E  3239 00002232           1751                          MOVE.W      (CURRENT_DATA),D1     ; print out the absolute short address we are concerned with in hex. 
00001F64  143C 0010               1752                          MOVE.B      #16,D2
00001F68  103C 000F               1753                          MOVE.B      #15,D0
00001F6C  4E4F                    1754                          TRAP        #15
00001F6E                          1755                          
00001F6E  4E75                    1756                          RTS 
00001F70                          1757  
00001F70  43F9 00001FBF           1758  DISPLAY_ABS_LONG        LEA         DOLLAR,A1             ; print out '$'. 
00001F76  103C 000E               1759                          MOVE.B      #14,D0
00001F7A  4E4F                    1760                          TRAP        #15
00001F7C                          1761  
00001F7C  4241                    1762                          CLR         D1
00001F7E  2239 00002232           1763                          MOVE.L      (CURRENT_DATA),D1     ; print out the absolute long address we are concerned with in hex. 
00001F84  143C 0010               1764                          MOVE.B      #16,D2
00001F88  103C 000F               1765                          MOVE.B      #15,D0
00001F8C  4E4F                    1766                          TRAP        #15
00001F8E                          1767                          
00001F8E  4E75                    1768                          RTS 
00001F90                          1769  
00001F90  43F9 00001FC3           1770  DISPLAY_IMMEDIATE       LEA         HASH,A1               ; print out '#'. (NOTE: should send this to display buffer instead.)
00001F96  103C 000E               1771                          MOVE.B      #14,D0
00001F9A  4E4F                    1772                          TRAP        #15
00001F9C                          1773                          
00001F9C  43F9 00001FBF           1774                          LEA         DOLLAR,A1             ; print out '$'. (this saves time since we can more easily find the hex value of the immediate data.)
00001FA2  103C 000E               1775                          MOVE.B      #14,D0
00001FA6  4E4F                    1776                          TRAP        #15
00001FA8                          1777                          
00001FA8  3239 00002232           1778                          MOVE.W      (CURRENT_DATA),D1     ; print out the immediate data we are concerned with in hex. 
00001FAE  143C 0010               1779                          MOVE.B      #16,D2
00001FB2  103C 000F               1780                          MOVE.B      #15,D0
00001FB6  4E4F                    1781                          TRAP        #15
00001FB8                          1782                          
00001FB8  4E75                    1783                          RTS
00001FBA                          1784                          
00001FBA                          1785  *###################### END EA ##################################
00001FBA                          1786  *############# BEGIN VARIABLES/CONSTANTS #########################
00001FBA                          1787  *** Variables and Constants are kept here ***
00001FBA                          1788  
00001FBA                          1789  *output characters
00001FBA  =0000000D               1790  CR                      EQU         $0D
00001FBA  =0000000A               1791  LF                      EQU         $0A
00001FBA= 0D 0A 00                1792  RETURN                  DC.B        CR,LF,0
00001FBD= 20 00                   1793  SPACE                   DC.B        ' ',0
00001FBF= 24 00                   1794  DOLLAR                  DC.B        '$',0
00001FC1= 2C 00                   1795  COMMA                   DC.B        ',',0
00001FC3= 23 00                   1796  HASH                    DC.B        '#',0
00001FC5= 28 00                   1797  OPEN_PARENS             DC.B        '(',0
00001FC7= 29 00                   1798  CLOSE_PARENS            DC.B        ')',0
00001FC9= 2B 00                   1799  PLUS                    DC.B        '+',0
00001FCB= 2D 00                   1800  MINUS                   DC.B        '-',0
00001FCD= 2F 00                   1801  SLASH                   DC.B        '/',0
00001FCF                          1802  
00001FCF                          1803  *output messages
00001FCF                          1804      ;TODO: consider also giving the user the range of valid start/end addresses
00001FCF= 50 6C 65 61 73 65 ...   1805  START_ADDR_MSG          DC.B        'Please enter a starting hex address to read from.',CR,LF,0
00002003= 50 6C 65 61 73 65 ...   1806  END_ADDR_MSG            DC.B        'Please enter an ending hex address to read from.',CR,LF,0
00002036                          1807  
00002036= 4E 6F 74 20 61 20 ...   1808  INVALID_LEN_MSG         DC.B        'Not a valid length for input address.',CR,LF
0000205D= 50 6C 65 61 73 65 ...   1809                          DC.B        'Please enter a valid-length address.',CR,LF,0
00002084= 4E 6F 74 20 61 20 ...   1810  INVALID_ADDR_MSG        DC.B        'Not a valid address.',CR,LF
0000209A= 50 6C 65 61 73 65 ...   1811                          DC.B        'Please enter a valid address.',CR,LF,0
000020BA= 4E 6F 74 20 61 20 ...   1812  INVALID_END_ADDR_MSG    DC.B        'Not a valid end address.',CR,LF
000020D4= 50 6C 65 61 73 65 ...   1813                          DC.B        'Please enter an end address after the start address.',CR,LF,0
0000210B                          1814                        
0000210B= 4E 6F 74 20 61 20 ...   1815  INVALID_ADDR_L_MSG      DC.B        'Not a valid address (too low).',CR,LF
0000212B= 50 6C 65 61 73 65 ...   1816                          DC.B        'Please enter a valid address.',CR,LF,0
0000214B                          1817                          
0000214B= 4E 6F 74 20 61 20 ...   1818  INVALID_ADDR_H_MSG      DC.B        'Not a valid address (too high).',CR,LF
0000216C= 50 6C 65 61 73 65 ...   1819                          DC.B        'Please enter a valid address.',CR,LF,0
0000218C                          1820                          
0000218C= 44 6F 6E 65 20 72 ...   1821  DONE_READING_MSG        DC.B        'Done reading the program.',CR,LF,0
000021A8                          1822  
000021A8                          1823  *output instruction names (OPcodes)
000021A8                          1824      ;sizes
000021A8= 2E 42 00                1825  BYTE_SIZE_MSG           DC.B        '.B',0
000021AB= 2E 57 00                1826  WORD_SIZE_MSG           DC.B        '.W',0
000021AE= 2E 4C 00                1827  LONG_SIZE_MSG           DC.B        '.L',0
000021B1                          1828  
000021B1                          1829      ;constants
000021B1= 52 45 53 45 54 00       1830  RESET_MSG               DC.B        'RESET',0
000021B7= 4E 4F 50 00             1831  NOP_MSG                 DC.B        'NOP',0
000021BB= 53 54 4F 50 00          1832  STOP_MSG                DC.B        'STOP',0
000021C0                          1833      ;moves
000021C0= 4D 4F 56 45 00          1834  MOVE_MSG                DC.B        'MOVE',0
000021C5= 4D 4F 56 45 2E 42 00    1835  MOVE_B_MSG              DC.B        'MOVE.B',0
000021CC= 4D 4F 56 45 2E 57 00    1836  MOVE_W_MSG              DC.B        'MOVE.W',0
000021D3= 4D 4F 56 45 2E 4C 00    1837  MOVE_L_MSG              DC.B        'MOVE.L',0
000021DA                          1838  
000021DA= 4D 4F 56 45 51 00       1839  MOVEQ_MSG               DC.B        'MOVEQ',0
000021E0                          1840  
000021E0= 4D 4F 56 45 4D 2E ...   1841  MOVEM_W_MSG             DC.B        'MOVEM.W',0
000021E8= 4D 4F 56 45 4D 2E ...   1842  MOVEM_L_MSG             DC.B        'MOVEM.L',0
000021F0                          1843  
000021F0                          1844  *other output instruction message constants
000021F0= 44 00                   1845  MSG_D                   DC.B        'D',0
000021F2= 41 00                   1846  MSG_A                   DC.B        'A',0
000021F4                          1847  
000021F4                          1848  *storage locations for input
000021F4                          1849  START_ADDR_IN           DS.B        20
00002208                          1850  
00002208                          1851  *other I/O-related variables/constants
00002208  =00000001               1852  INPUTTING_START         SET         1 ;if 1, we are inputting start address. If 0, we are inputting end address.
00002208                          1853  OPCODE_BUFFER           DS.L        1 ; can hold at most 4 characters
0000220C                          1854  SIZE_BUFFER             DS.W        1 ;cand hold at most 2 characters
0000220E                          1855  DISPLAY_BUFFER          DS.W        5
00002218                          1856  
00002218                          1857  *EA/OPcode parsed instruction variables/constants
00002218                          1858  
00002218                          1859  CURRENT_WORD            DS.W        1 ; current first 16 bits of an instruction.
0000221A                          1860  CURRENT_OP_SIZE         DS.B        1 ; current operation size. Byte = 01, Word = 11, Long = 10
0000221B                          1861  
0000221B                          1862      *Direction-oriented variables
0000221B                          1863          *left
0000221B                          1864  CURRENT_L_MD            DS.B        1 ; current left mode (printing-wise) we are concerned with.
0000221C                          1865  CURRENT_L_REG           DS.B        1 ; current left register (printing-wise) we are concerned with.
0000221E                          1866  CURRENT_L_DATA          DS.L        1
00002222                          1867          *right
00002222                          1868  CURRENT_R_MD            DS.B        1 ; current right mode (printing-wise) we are concerned with.
00002223                          1869  CURRENT_R_REG           DS.B        1 ; current right register (printing-wise) we are concerned with.
00002224                          1870  CURRENT_R_DATA          DS.L        1
00002228                          1871  
00002228                          1872  
00002228                          1873      *Destination/source-oriented variables
00002228                          1874  CURRENT_EA_MD           DS.B        1 ; current EA mode we are concerned with.
00002229                          1875  CURRENT_EA_REG          DS.B        1 ; current EA register we are concerned with.
0000222A                          1876  
0000222A                          1877  CURRENT_DIRECTION       DS.B        1 ; current direction of an operation.
0000222B                          1878  
0000222B                          1879  CURRENT_MD              DS.B        1 ; current mode we are concerened with (ex: 000 for data register mode.)
0000222C                          1880  CURRENT_REG             DS.B        1 ; current register number we are concerned with(address, data, etc) that we are looking at. Ex: D0,A5,etc
0000222D                          1881  
0000222D                          1882  CURRENT_SRC_MD          DS.B        1 ; current source mode
0000222E                          1883  CURRENT_SRC_REG         DS.B        1 ; current source register
0000222F                          1884  CURRENT_DEST_MD         DS.B        1 ; current desination mode
00002230                          1885  CURRENT_DEST_REG        DS.B        1 ; current desination register
00002231                          1886  
00002232                          1887  CURRENT_DATA            DS.L        1 ; current addition data we are concerned with
00002236                          1888  CURRENT_SRC_DATA        DS.L        1 ; current additional data for source (like absolute addresses, immediate data, etc)
0000223A                          1889  CURRENT_DEST_DATA       DS.L        1 ; current additional data for destination (like absolute addresses, immediate data, etc) 
0000223E                          1890  
0000223E                          1891      *miscellaneous EA variables
0000223E                          1892  CURRENT_MASK_FIELD      DS.W        1 ; right now, this is only used for MOVEM.
00002240                          1893  
00002240                          1894  *size constants
00002240  =00000000               1895  BYTE_SIZE               EQU         $00 ; 0000 0000
00002240  =00000001               1896  WORD_SIZE               EQU         $01 ; 0000 0001
00002240  =00000002               1897  LONG_SIZE               EQU         $02 ; 0000 0010
00002240                          1898  
00002240  =00000001               1899  BYTE_SIZE_M             EQU         $01 ; 0000 0001
00002240  =00000003               1900  WORD_SIZE_M             EQU         $03 ; 0000 0011
00002240  =00000002               1901  LONG_SIZE_M             EQU         $02 ; 0000 0010
00002240                          1902  
00002240  =00000000               1903  WORD_SIZE_MOVEM         EQU         $00 ; 0000 0000
00002240  =00000001               1904  LONG_SIZE_MOVEM         EQU         $01 ; 0000 0001
00002240                          1905  
00002240                          1906  *address constants
00002240  =00004000               1907  MIN_ADDRESS             EQU         $00004000
00002240  =0FFF0000               1908  MAX_ADDRESS             EQU         $0FFF0000
00002240                          1909  
00002240                          1910  *address variables
00002240  =00007000               1911  TEST_ORIGIN             SET         $00007000
00002240  =00007000               1912  NEXT_ADDR               SET         TEST_ORIGIN
00002240  =00009000               1913  END_ADDR                SET         $00009000
00002240                          1914  
00002240                          1915  *filters for isolating parts of a hexa instruction. X means 'unknown' and can be 0 or one after ANDI filter.
00002240                          1916  *To filter an instruction, ANDI it with the desired filter.
00002240                          1917  *note: I'm not sure if it matters much whether you have the 4 leading 0s in these filters, but I don't want to
00002240                          1918  *risk changing it. Therefore, some filters have leading 0s and some do not.
00002240                          1919      * general filters
00002240  =0000C000               1920  FILT_2BIT_1             EQU         $0000C000   ; first 2 bits:                         XX00 0000 0000 0000
00002240  =0000F000               1921  FILT_NIB_1              EQU         $0000F000   ; first nibble:                         XXXX 0000 0000 0000
00002240  =00000F00               1922  FILT_NIB_2              EQU         $00000F00   ; second nibble:                        0000 XXXX 0000 0000
00002240  =00000800               1923  FILT_BIT_5              EQU         $00000800   ; 5th bit:                              0000 X000 0000 0000
00002240  =00000100               1924  FILT_BIT_8              EQU         $00000100   ; 8th bit:                              0000 000X 0000 0000
00002240                          1925  
00002240                          1926      * source/destination filters (not applicable for bidirectional operations)
00002240  =00000E00               1927  FILT_DEST_REG           EQU         $00000E00   ; destination register:                 0000 XXX0 0000 0000
00002240  =000001C0               1928  FILT_DEST_MD            EQU         $000001C0   ; destination mode:                     0000 000X XX00 0000
00002240  =00000038               1929  FILT_SRC_MD             EQU         $00000038   ; source mode:                          0000 0000 00XX X000
00002240  =00000007               1930  FILT_SRC_REG            EQU         $00000007   ; source register:                      0000 0000 0000 0XXX
00002240                          1931  
00002240                          1932      * move filters
00002240  =00003000               1933  FILT_MOVE_SIZE          EQU         $00003000   ; Size of a move operation:             00XX 0000 0000 0000
00002240  =0000FB80               1934  FILT_MOVEM              EQU         $0000FB80   ; check for a MOVEM instruction:        XXXX X0XX X000 0000
00002240  =00000040               1935  FILT_MOVEM_SIZE         EQU         $00000040   ; Size of a MOVEM operation             0000 0000 0X00 0000
00002240  =00000400               1936  FILT_MOVEM_DIR          EQU         $00000400   ; direction of a MOVEM operation:       0000 0X00 0000 0000
00002240                          1937  
00002240                          1938      * filters for BRA, BSR, BCC, and MOVEQ (the same filter, but named differently for clarity.)
00002240  =000000FF               1939  FILT_DISPLACEMENT       EQU         $00FF       ; Displacment of branch instruction:    0000 0000 XXXX XXXX
00002240  =000000FF               1940  FILT_MOVEQ_DATA         EQU         $00FF       ; Data of MOVEQ instruction:            0000 0000 XXXX XXXX
00002240                          1941  
00002240                          1942      * ADD-type method filters
00002240  =00000130               1943  FILT_ADDX               EQU         $0130       ; filter what is normally dest. and md. 0000 000X 00XX 0000   
00002240  =000000C0               1944  FILT_ADDA               EQU         $00C0       ; filter what is normally the size.     0000 0000 XX00 0000
00002240                          1945  
00002240                          1946      * EXT filter
00002240  =0000FFB8               1947  FILT_EXT                EQU         $FFB8       ; check for an EXT instruction:         XXXX XXXX X0XX X000
00002240                          1948  
00002240                          1949  * constants for comparing with filtered instructions. X means 'don't care' (and will be set to 0 by previous filter)
00002240                          1950  *(These do not represent the complete insturctions.)
00002240                          1951  *(Also note that repetition is allowed for clarity's sake, so two constants can share a value.)
00002240                          1952  
00002240                          1953      * general filters
00002240  =00000000               1954  CONST_ALL_0             EQU         $0000    ; all 0s:                               0000 0000 0000 0000
00002240                          1955  
00002240                          1956      * Nibble 1 filters
00002240  =00004000               1957  CONST_NIB1_0100         EQU         $4000    ; first nibble is 0100                  0100 XXXX XXXX XXXX
00002240  =00005000               1958  CONST_NIB1_0101         EQU         $5000    ; first nibble is 0101                  0101 XXXX XXXX XXXX
00002240  =00006000               1959  CONST_NIB1_0110         EQU         $6000    ; first nibble is 0110                  0110 XXXX XXXX XXXX
00002240  =00008000               1960  CONST_NIB1_1000         EQU         $8000    ; first nibble is 1000                  1000 XXXX XXXX XXXX
00002240  =00009000               1961  CONST_NIB1_1001         EQU         $9000    ; first nibble is 1001                  1001 XXXX XXXX XXXX
00002240  =0000B000               1962  CONST_NIB1_1011         EQU         $B000    ; first nibble is 1011                  1011 XXXX XXXX XXXX
00002240  =0000C000               1963  CONST_NIB1_1100         EQU         $C000    ; first nibble is 1100                  1100 XXXX XXXX XXXX
00002240  =0000D000               1964  CONST_NIB1_1101         EQU         $D000    ; first nibble is 1101                  1101 XXXX XXXX XXXX
00002240  =0000E000               1965  CONST_NIB1_1110         EQU         $E000    ; first nibble is 1110                  1110 XXXX XXXX XXXX
00002240                          1966  
00002240                          1967      * Nibble 2 filters
00002240  =00000800               1968  CONST_NIB2_1000         EQU         $0800    ; second nibble is 1000                 XXXX 1000 XXXX XXXX
00002240  =00000A00               1969  CONST_NIB2_1010         EQU         $0A00    ; second nibble is 1010                 XXXX 1010 XXXX XXXX
00002240  =00000E00               1970  CONST_NIB2_1110         EQU         $0E00    ; second nibble is 1110                 XXXX 1110 XXXX XXXX
00002240                          1971  
00002240                          1972  * Immediate operation constants
00002240                          1973      * ANDI
00002240  =00000000               1974  CONST_ORI_DEST_REG      EQU         $0000    ; confirm ORI                           XXXX 000X XXXX XXXX
00002240                          1975      * ANDI
00002240  =00000200               1976  CONST_ANDI_DEST_REG     EQU         $0200    ; confirm ANDI                          XXXX 001X XXXX XXXX
00002240                          1977      * SUBI
00002240  =00000400               1978  CONST_SUBI_DEST_REG     EQU         $0400    ; confirm SUBI                          XXXX 010X XXXX XXXX
00002240                          1979      * ADDI
00002240  =00000600               1980  CONST_ADDI_DEST_REG     EQU         $0600    ; confirm ADDI                          XXXX 011X XXXX XXXX
00002240                          1981      * EORI
00002240  =00000A00               1982  CONST_EORI_DEST_REG     EQU         $0A00    ; confirm EORI                          XXXX 101X XXXX XXXX
00002240                          1983      * CMPI
00002240  =00000C00               1984  CONST_CMPI_DEST_REG     EQU         $0C00    ; confirm CMPI                          XXXX 110X XXXX XXXX
00002240                          1985  
00002240                          1986  * Constants for matching based on 2nd nibble
00002240                          1987      *NEGX
00002240  =00000000               1988  CONST_NEGX_OP           EQU         $0000    ; confirm NEGX                          XXXX 0000 XXXX XXXX
00002240                          1989      *CLR
00002240  =00000200               1990  CONST_CLR_OP            EQU         $0200    ; confirm CLR                           XXXX 0010 XXXX XXXX
00002240                          1991      *NEG
00002240  =00000400               1992  CONST_NEG_OP            EQU         $0400    ; confirm NEG                           XXXX 0100 XXXX XXXX
00002240                          1993      *NOT
00002240  =00000600               1994  CONST_NOT_OP            EQU         $0600    ; confirm NOT                           XXXX 0110 XXXX XXXX
00002240                          1995  
00002240                          1996  * EXT constant
00002240  =00004880               1997  CONST_EXT               EQU         $4880    ; confirm EXT                           0100 1000 1X00 0XXX
00002240                          1998  
00002240                          1999  * Other constants
00002240                          2000      * BTST,BCHG,BCLR,BSET
00002240  =00000800               2001  CONST_B_OP              EQU         $0800    ; BTST,BCHG,BCLR,BSET                   XXXX 100X XXXX XXXX
00002240                          2002  
00002240                          2003      * MOVE
00002240  =00001000               2004  CONST_MOVE_B            EQU         $1000    ; MOVE.B (use first nib)                0001 XXXX XXXX XXXX
00002240  =00003000               2005  CONST_MOVE_W            EQU         $3000    ; MOVE.W (use first nib)                0011 XXXX XXXX XXXX
00002240  =00002000               2006  CONST_MOVE_L            EQU         $2000    ; MOVE.L (use first nib)                0010 XXXX XXXX XXXX
00002240                          2007  
00002240                          2008      * MOVEQ
00002240  =00007000               2009  CONST_MOVEQ             EQU         $7000    ; MOVEQ.L (use first nib)               0111 XXXX XXXX XXXX    
00002240                          2010           
00002240                          2011      * MOVEM                      
00002240  =00004880               2012  CONST_MOVEM             EQU         $4880    ; confirm MOVEM (use FILT_MOVEM)        0100 1X00 1XXX XXXX        
00002240  =00000000               2013  CONST_MOVEM_DIR_0       EQU         $0000    ; MOVEM list to EA direction            XXXX XXXX XXXX XXX0
00002240  =00000001               2014  CONST_MOVEM_DIR_1       EQU         $0001    ; MOVEM EA to list direction            XXXX XXXX XXXX XXX1    
00002240                          2015  
00002240                          2016      * ADDX
00002240  =00000100               2017  CONST_ADDX              EQU         $0100    ; confirm ADDX                          XXXX XXX1 XX00 XXXX        
00002240                          2018          
00002240                          2019      * ADDA
00002240  =000000C0               2020  CONST_ADDA              EQU         $00C0    ; confirm ADDA                          XXXX XXXX 11XX XXXX
00002240                          2021   
00002240                          2022  * Mode/register constants
00002240                          2023  
00002240                          2024      * Mode values
00002240  =00000000               2025  CONST_DATA_REG_MD       EQU         $00      ; Data register mode:     Dn            XXXX X000
00002240  =00000001               2026  CONST_ADDR_REG_MD       EQU         $01      ; Address register mode:  An            XXXX X001
00002240  =00000002               2027  CONST_ADDR_IND_MD       EQU         $02      ; Address indirect mode:  (An)          XXXX X010
00002240  =00000003               2028  CONST_ADDR_INCR_MD      EQU         $03      ; Address postincr. mode: (An)+         XXXX X011
00002240  =00000004               2029  CONST_ADDR_DECR_MD      EQU         $04      ; Address predecr. mode:  -(An)         XXXX X100
00002240  =00000005               2030  CONST_ADDR_DISPLC_MD    EQU         $05      ; Address w/ displacement:(d16,An)      XXXX X101
00002240  =00000006               2031  CONST_ADDR_INDEX_MD     EQU         $06      ; Address w/ index:       (d8,PC,Xn)    XXXX X110
00002240  =00000007               2032  CONST_ADDR_MISC_MD      EQU         $07      ; Various other addressing modes        XXXX X111
00002240                          2033  
00002240                          2034      * Constant register values (should not be necessary for register numbers like D5)
00002240  =00000002               2035  CONST_COUNTR_DISPLC_REG EQU         $02      ; Counter w/ displacement:(d16,PC)      XXXX X010
00002240  =00000003               2036  CONST_COUNTR_INDEX_REG  EQU         $03      ; Counter w/ index:       (d16,PC,Xn)   XXXX X011
00002240  =00000000               2037  CONST_ABS_SHORT_REG     EQU         $00      ; Absolute word:          (xxx).W       XXXX X000
00002240  =00000001               2038  CONST_ABS_LONG_REG      EQU         $01      ; Absolute long:          (xxx).L       XXXX X001
00002240  =00000004               2039  CONST_IMMEDIATE_REG     EQU         $04      ; Immediate data:         #imm          XXXX X100
00002240                          2040  
00002240                          2041  *full OPcode contstants
00002240  =00004E70               2042  RESET_CODE              EQU         $4E70    ; RESET                                 0100 1110 0111 0001
00002240  =00004E71               2043  NOP_CODE                EQU         $4E71    ; NOP                                   0100 1110 0111 0001
00002240  =00004E72               2044  STOP_CODE               EQU         $4E72    ; STOP                                  0100 1110 0111 0010
00002240                          2045  
00002240                          2046    
00002240                          2047  *############# END VARIABLES/CONSTANTS #########################
00002240                          2048  
00002240                          2049      END START        ; last line of source, very end of the program

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDA_FOUND          1AE0
ADDI_FOUND          1ABC
ADDX_FOUND          1ADC
ADD_FOUND           1AD8
ANDI_FOUND          1AB4
ASCII_TO_HEX        10B4
BEGIN_READ          12E2
BYTE_SIZE           0
BYTE_SIZE_M         1
BYTE_SIZE_MSG       21A8
CHECK_ADDRESSING_MODES  1DA8
CHECK_ADDR_IN_LIST_FLAG  198C
CHECK_CONSTANTS     134A
CHECK_DONE_READING  1308
CHECK_EXT           1622
CHECK_MISC_ADDRESSINGS  1F0E
CHECK_MOVE          15E6
CHECK_MOVEM         1638
CHECK_MOVEQ         160C
CHECK_NIB1_0000     13EE
CHECK_NIB1_0100     1404
CHECK_NIB1_0101     141A
CHECK_NIB1_0110     1430
CHECK_NIB1_1000     1446
CHECK_NIB1_1001     145A
CHECK_NIB1_1011     1470
CHECK_NIB1_1100     1486
CHECK_NIB1_1101     149C
CHECK_NIB1_1110     14B2
CHECK_NON_CONSTANTS  13B2
CHECK_SINGLE_A      195C
CHECK_SINGLE_D      1974
CLOSE_PARENS        1FC7
CLR_FOUND           1ACC
CMPI_FOUND          1AC4
COMMA               1FC1
CONFIRMED_NEXT_OP   12F6
CONFIRM_0000_XXX0   14E0
CONFIRM_0100_0XXX   153A
CONFIRM_0100_1000   1592
CONFIRM_0100_1010   1596
CONFIRM_0100_1110   159A
CONFIRM_0100_1XXX   156A
CONFIRM_NIB1_0000   14C8
CONFIRM_NIB1_0100   151E
CONFIRM_NIB1_0101   159E
CONFIRM_NIB1_0110   15A2
CONFIRM_NIB1_1000   15A6
CONFIRM_NIB1_1001   15AA
CONFIRM_NIB1_1011   15AE
CONFIRM_NIB1_1100   15B2
CONFIRM_NIB1_1101   15B6
CONFIRM_NIB1_1110   15E2
CONFIRM_READ_DATA   1C3C
CONFIRM_READ_DEST_DATA  1BA8
CONFIRM_READ_LEFT_DATA  1BE2
CONFIRM_READ_RIGHT_DATA  1C1C
CONFIRM_READ_SRC_DATA  1B6E
CONST_ABS_LONG_REG  1
CONST_ABS_SHORT_REG  0
CONST_ADDA          C0
CONST_ADDI_DEST_REG  600
CONST_ADDR_DECR_MD  4
CONST_ADDR_DISPLC_MD  5
CONST_ADDR_INCR_MD  3
CONST_ADDR_INDEX_MD  6
CONST_ADDR_IND_MD   2
CONST_ADDR_MISC_MD  7
CONST_ADDR_REG_MD   1
CONST_ADDX          100
CONST_ALL_0         0
CONST_ANDI_DEST_REG  200
CONST_B_OP          800
CONST_CLR_OP        200
CONST_CMPI_DEST_REG  C00
CONST_COUNTR_DISPLC_REG  2
CONST_COUNTR_INDEX_REG  3
CONST_DATA_REG_MD   0
CONST_EORI_DEST_REG  A00
CONST_EXT           4880
CONST_IMMEDIATE_REG  4
CONST_MOVEM         4880
CONST_MOVEM_DIR_0   0
CONST_MOVEM_DIR_1   1
CONST_MOVEQ         7000
CONST_MOVE_B        1000
CONST_MOVE_L        2000
CONST_MOVE_W        3000
CONST_NEGX_OP       0
CONST_NEG_OP        400
CONST_NIB1_0100     4000
CONST_NIB1_0101     5000
CONST_NIB1_0110     6000
CONST_NIB1_1000     8000
CONST_NIB1_1001     9000
CONST_NIB1_1011     B000
CONST_NIB1_1100     C000
CONST_NIB1_1101     D000
CONST_NIB1_1110     E000
CONST_NIB2_1000     800
CONST_NIB2_1010     A00
CONST_NIB2_1110     E00
CONST_NOT_OP        600
CONST_ORI_DEST_REG  0
CONST_SUBI_DEST_REG  400
CONVERSION_DONE     12B0
COUNT_INPUT_DIGITS  1046
CR                  D
CURRENT_DATA        2232
CURRENT_DEST_DATA   223A
CURRENT_DEST_MD     222F
CURRENT_DEST_REG    2230
CURRENT_DIRECTION   222A
CURRENT_EA_MD       2228
CURRENT_EA_REG      2229
CURRENT_L_DATA      221E
CURRENT_L_MD        221B
CURRENT_L_REG       221C
CURRENT_MASK_FIELD  223E
CURRENT_MD          222B
CURRENT_OP_SIZE     221A
CURRENT_REG         222C
CURRENT_R_DATA      2224
CURRENT_R_MD        2222
CURRENT_R_REG       2223
CURRENT_SRC_DATA    2236
CURRENT_SRC_MD      222D
CURRENT_SRC_REG     222E
CURRENT_WORD        2218
DIG_CONV_DONE_1     10DE
DIG_CONV_DONE_2     1112
DIG_CONV_DONE_3     114A
DIG_CONV_DONE_4     1182
DIG_CONV_DONE_5     11BA
DIG_CONV_DONE_6     11F2
DIG_CONV_DONE_7     122A
DIG_CONV_DONE_8     1262
DISPLAY_ABS_LONG    1F70
DISPLAY_ABS_SHORT   1F50
DISPLAY_ADDR_DECR   1EC6
DISPLAY_ADDR_DISPLC  1F0A
DISPLAY_ADDR_INCR   1E82
DISPLAY_ADDR_IND    1E4A
DISPLAY_ADDR_INDEX  1F0C
DISPLAY_ADDR_REG    1E2A
DISPLAY_BUFFER      220E
DISPLAY_COUNTR_DISPLC  1F4C
DISPLAY_COUNTR_INDEX  1F4E
DISPLAY_CURRENT_ADDRESS  1324
DISPLAY_DATA_REG    1E0A
DISPLAY_DEST        1D06
DISPLAY_IMMEDIATE   1F90
DISPLAY_LEFT        1D3C
DISPLAY_MOVEM_DATA  18B4
DISPLAY_MOVEM_DIR_0  18C4
DISPLAY_MOVEM_DIR_1  18E6
DISPLAY_MOVEM_LIST  1908
DISPLAY_MOVEM_LIST_FWD  1918
DISPLAY_MOVEM_LIST_REV  1922
DISPLAY_MOVEQ_DATA  176C
DISPLAY_MOVE_DATA   16F8
DISPLAY_RIGHT       1D72
DISPLAY_SLASH       1A58
DISPLAY_SOURCE      1CD0
DISP_MM_END_A       1A28
DISP_MM_END_D       1A84
DISP_MM_START_A     1A06
DISP_MM_START_D     1A68
DOLLAR              1FBF
DONE_READING        1310
DONE_READING_MSG    218C
END_ADDR            9000
END_ADDR_MSG        2003
EORI_FOUND          1AC0
EXT_FOUND           17A8
FILT_2BIT_1         C000
FILT_ADDA           C0
FILT_ADDX           130
FILT_BIT_5          800
FILT_BIT_8          100
FILT_DEST_MD        1C0
FILT_DEST_REG       E00
FILT_DISPLACEMENT   FF
FILT_EXT            FFB8
FILT_MOVEM          FB80
FILT_MOVEM_DIR      400
FILT_MOVEM_SIZE     40
FILT_MOVEQ_DATA     FF
FILT_MOVE_SIZE      3000
FILT_NIB_1          F000
FILT_NIB_2          F00
FILT_SRC_MD         38
FILT_SRC_REG        7
FIND_MM_END_A       19BA
FIND_MM_END_A_LOOP  19BE
FIND_MM_END_D       19F0
FIND_MM_END_D_LOOP  19F4
FIND_MM_START_A     1998
FIND_MM_START_A_LOOP  19A8
FIND_MM_START_D     19CE
FIND_MM_START_D_LOOP  19E0
GO_TO_NEXT_OP       12F2
HASH                1FC3
INPUTTING_START     1
INVALID_ADDR_HIGH   12A0
INVALID_ADDR_H_MSG  214B
INVALID_ADDR_INPUT  1270
INVALID_ADDR_LOW    1290
INVALID_ADDR_L_MSG  210B
INVALID_ADDR_MSG    2084
INVALID_END_ADDR    1280
INVALID_END_ADDR_MSG  20BA
INVALID_LEN_MSG     2036
LF                  A
LONG_SIZE           2
LONG_SIZE_M         2
LONG_SIZE_MOVEM     1
LONG_SIZE_MSG       21AE
MAX_ADDRESS         FFF0000
MINUS               1FCB
MIN_ADDRESS         4000
MOVEM_FOUND         17AC
MOVEM_LIST_DISPLAY_DONE  1AAE
MOVEM_L_FOUND       17F6
MOVEM_L_MSG         21E8
MOVEM_W_FOUND       17CA
MOVEM_W_MSG         21E0
MOVEQ_FOUND         171A
MOVEQ_MSG           21DA
MOVE_B_FOUND        164E
MOVE_B_MSG          21C5
MOVE_L_FOUND        16AE
MOVE_L_MSG          21D3
MOVE_MSG            21C0
MOVE_W_FOUND        167E
MOVE_W_MSG          21CC
MSG_A               21F2
MSG_D               21F0
NEGX_FOUND          1AC8
NEG_FOUND           1AD0
NEXT_ADDR           7000
NOP_CODE            4E71
NOP_FOUND           1390
NOP_MSG             21B7
NOT_FOUND           1AD4
OPCODE_BUFFER       2208
OPEN_PARENS         1FC5
ORI_FOUND           1AB0
PARSE_MOVEM_DATA    1822
PARSE_MOVEM_DIR_0   186A
PARSE_MOVEM_DIR_1   1888
PARSE_MOVEM_MASK_FIELD  18A6
PARSE_MOVEQ_DATA    174A
PARSE_MOVE_DATA     16DE
PLUS                1FC9
PREPARE_DISPLAY     12EE
PROMPT_INPUT        1008
READ_ABS_LONG_DATA  1C86
READ_ABS_SHORT_DATA  1C7E
READ_COUNTR_DISPLC_DATA  1C7A
READ_COUNTR_INDEX_DATA  1C7C
READ_CURRENT_OP     1320
READ_DEST_DATA      1B8E
READ_DEST_MODE      1B02
READ_DEST_REG       1AE4
READ_IMMEDIATE_DATA  1C8E
READ_IMMEDIATE_DATA_L  1CC2
READ_IMMEDIATE_DATA_W  1CB4
READ_LEFT_DATA      1BC8
READ_MOVEM_DIR      1852
READ_MOVEQ_DATA     178E
READ_RIGHT_DATA     1C02
READ_SOURCE_DATA    1B54
READ_SOURCE_MODE    1B1E
READ_SOURCE_REG     1B3A
RESET_CODE          4E70
RESET_FOUND         1372
RESET_MSG           21B1
RETURN              1FBA
REVERSE_MASK_FIELD  1930
REVERSE_MASK_FIELD_LOOP  194C
SET_END_ADDR        12D8
SET_START_ADDR      12D2
SIZE_BUFFER         220C
SLASH               1FCD
SPACE               1FBD
START               1000
START_ADDR_IN       21F4
START_ADDR_MSG      1FCF
STOP                1004
STOP_CODE           4E72
STOP_FOUND          13AE
STOP_MSG            21BB
SUBI_FOUND          1AB8
TAKE_USER_INPUT     1034
TAKE_USER_IN_E      1020
TAKE_USER_IN_S      100C
TEST_ORIGIN         7000
VALID_ADDR          12C6
WORD_SIZE           1
WORD_SIZE_M         3
WORD_SIZE_MOVEM     0
WORD_SIZE_MSG       21AB
