00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.14.00
Created On: 2/22/2014 8:03:41 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Disassembler
00000000                             3  * Written by : Robert Brandenburg, Danielle Jenkins, Shahin Nahar
00000000                             4  * Date       : 2/13/14
00000000                             5  * Description: Disassemble hex machine code instructions into 68K instructions
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8  * TODO: write disassembler
00000000                             9  * TODO: more specific TODOs for our plan
00000000                            10  * TODO: comments saying who is working where
00000000                            11  
00000000                            12  
00000000                            13  * Commenting Key: 
00000000                            14  *    "----------"  <-- subroutine commenting
00000000                            15  *    "##########"  <-- section/role commenting
00000000                            16  
00000000                            17  * Notes on saving registers on run:
00000000                            18  *    MOVEM.L A0-A3/D0-D7, -(A7) * copies all working registers to stack
00000000                            19  *    MOVEM.L (A7)+, A0-A3/D0-D7 *Restore the registers
00000000                            20  
00000000                            21  * Notes on AND filters (bit masking):
00000000                            22  * Example:
00000000                            23  *       0001 000 001 111 100   (say you want "001")
00000000                            24  *   AND 0000 000 111 000 000   (0 <-- don't want, 1 <-- do want)
00000000                            25  *       --------------------
00000000                            26  *     = 0000 000 001 000 000
00000000                            27  *
00000000                            28  * Relevant wiki page:
00000000                            29  *   https://en.wikipedia.org/wiki/Mask_(computing)#Masking_bits_to_0
00000000                            30  *
00000000                            31  *################ TODO LIST ################################
00000000                            32  *----------------OPcode TODOS (ROBERT)-----------------------------
00000000                            33  * Implement a method to reverse the mask words for MOVEM commands with -(An).
00000000                            34  * This means no need for special reverse reading methods in this case.
00000000                            35  
00000000                            36  * Fix the current bugs with MOVEs performed on absolute addresses. Not sure why these errors occur.
00000000                            37  *   -consult the bug report before trying to debug.
00000000                            38  * Continue decoding OPcodes in the following order: (with sizes)
00000000                            39  *   NOTE: I will delete OPcodes from this list as I implement them.
00000000                            40  
00000000                            41  *   -ADD    (B,W,L) (will need shahin's size filter for this and below)
00000000                            42  *   -ADDA   (W,L)
00000000                            43  *   -ADDI   (B,W,L)
00000000                            44  *   -SUB    (B,W,L)
00000000                            45  *   -SUBA   (W,L)
00000000                            46  
00000000                            47  *   -SUBQ   (B,W,L)
00000000                            48  *   -MULS   (W)     (not MULU?)
00000000                            49  *   -DIVU   (W      (not DIVU?)
00000000                            50  *   -LEA    (?)
00000000                            51  *   -CLR    (B,W,L)
00000000                            52  
00000000                            53  *   -AND    (B,W,L)
00000000                            54  *   -ANDI   (B,W,L)
00000000                            55  *   -EOR    (B,W,L)
00000000                            56  *   -EORI   (B,W,L)
00000000                            57  *   -ASR    (B,W,L) (no ASL?)
00000000                            58  
00000000                            59  *   -LSL    (B,W,L) (no LSR?)
00000000                            60  *   -ROL    (B,W,L)
00000000                            61  *   -ROR    (B,W,L)
00000000                            62  *   -BCHG   (?)
00000000                            63  *   -CMP    (B,W,L)
00000000                            64  
00000000                            65  *   -CMPA   (W,L)
00000000                            66  *   -CMPI   (B,W,L)
00000000                            67  *   -JSR    (N/A)
00000000                            68  
00000000                            69  *   (add others if we have time)
00000000                            70  *
00000000                            71  *----------------I/O TODOS (DANIELLE)-----------------------------
00000000                            72  * (TODOs for I/O go here.)
00000000                            73  *----------------EA TODOS  (SHAHIN)-----------------------------
00000000                            74  * (TODOs for EA go here.)
00000000                            75  *################ BEGIN MAIN ###############################
00000000                            76  *** All subroutine calls are made here ***
00001000                            77  START                   ORG        $1000       ; first instruction of program
00001000  6000 0006                 78                          BRA        PROMPT_INPUT            ; prompt the user for input
00001004                            79                   
00001004  4E72 2700                 80  STOP                    STOP       #$2700          ; halt simulator, end of main
00001008                            81  
00001008                            82  *################ END MAIN ###############################
00001008                            83  *################ BEGIN IO ###############################
00001008                            84  *** IO Subroutines are kept here ***
00001008                            85  
00001008                            86  *-------------------- Print ASCII logo ----------------------
00001008  6000 0002                 87  PROMPT_INPUT            BRA         TAKE_USER_IN_S ;TODO: change to welcome/ASCII logo
0000100C                            88  *------------------- Prompt user for input -------------------
0000100C                            89  
0000100C                            90                  
0000100C  163C 0001                 91  TAKE_USER_IN_S          MOVE.B      #1,D3
00001010  43F9 00001FE7             92                          LEA         START_ADDR_MSG,A1  ; Prompt user for starting address
00001016  103C 000E                 93                          MOVE.B      #14,D0
0000101A  4E4F                      94                          TRAP        #15
0000101C                            95  
0000101C  6000 0016                 96                          BRA         TAKE_USER_INPUT
00001020                            97  
00001020  163C 0000                 98  TAKE_USER_IN_E          MOVE.B      #0,D3
00001024  43F9 0000201B             99                          LEA         END_ADDR_MSG,A1  ; prompt user for ending address
0000102A  103C 000E                100                          MOVE.B      #14,D0
0000102E  4E4F                     101                          TRAP        #15
00001030                           102                          
00001030  6000 0002                103                          BRA         TAKE_USER_INPUT
00001034                           104                          
00001034  7200                     105  TAKE_USER_INPUT         MOVE.L      #$00000000,D1   ; need to clear out the data registers we are about to use to avoid junk data.   
00001036  7A00                     106                          MOVE.L      #$00000000,D5    
00001038  7C00                     107                          MOVE.L      #$00000000,D6
0000103A  7E00                     108                          MOVE.L      #$00000000,D7
0000103C                           109  
0000103C  103C 0002                110                          MOVE.B      #2,D0           ; Take user input for next address.
00001040  327C 3000                111                          MOVEA.W     #$3000,A1       ; Store the ascii input in A1,(note that we might not want to use 3000 here)
00001044  4E4F                     112                          TRAP        #15             ; and the length in D1.W.  
00001046                           113  
00001046  327C 3001                114  COUNT_INPUT_DIGITS      MOVEA.W     #$3001,A1
0000104A  B27C 0001                115                          CMP         #1,D1
0000104E  6700 0064                116                          BEQ         ASCII_TO_HEX  ;start converting if we have 1 digit.
00001052                           117            
00001052  327C 3002                118                          MOVEA.W     #$3002,A1
00001056  B27C 0002                119                          CMP         #2,D1
0000105A  6700 0058                120                          BEQ         ASCII_TO_HEX  ;start converting if we have 2 digits.
0000105E                           121            
0000105E  327C 3003                122                          MOVEA.W     #$3003,A1
00001062  B27C 0003                123                          CMP         #3,D1
00001066  6700 004C                124                          BEQ         ASCII_TO_HEX  ;start converting if we have 3 digits.
0000106A                           125            
0000106A  327C 3004                126                          MOVEA.W     #$3004,A1
0000106E  B27C 0004                127                          CMP         #4,D1
00001072  6700 0040                128                          BEQ         ASCII_TO_HEX  ;start converting if we have 4 digits.
00001076                           129            
00001076  327C 3005                130                          MOVEA.W     #$3005,A1
0000107A  B27C 0005                131                          CMP         #5,D1
0000107E  6700 0034                132                          BEQ         ASCII_TO_HEX  ;start converting if we have 5 digits.
00001082                           133            
00001082  327C 3006                134                          MOVEA.W     #$3006,A1
00001086  B27C 0006                135                          CMP         #6,D1
0000108A  6700 0028                136                          BEQ         ASCII_TO_HEX  ;start converting if we have 6 digits.
0000108E                           137            
0000108E  327C 3007                138                          MOVEA.W     #$3007,A1
00001092  B27C 0007                139                          CMP         #7,D1
00001096  6700 001C                140                          BEQ         ASCII_TO_HEX  ;start converting if we have 7 digits.
0000109A                           141            
0000109A  327C 3008                142                          MOVEA.W     #$3008,A1
0000109E  B27C 0008                143                          CMP         #8,D1
000010A2  6700 0010                144                          BEQ         ASCII_TO_HEX  ;start converting if we have 8 digits.
000010A6                           145            
000010A6  43F9 0000204E            146                          LEA         INVALID_LEN_MSG,A1         ; If we get an invalid length, give and error message and... branch back asking user for input again
000010AC  103C 000E                147                          MOVE.B      #14,D0
000010B0  4E4F                     148                          TRAP        #15
000010B2                           149  
000010B2  6780                     150                          BEQ         TAKE_USER_INPUT               
000010B4                           151  
000010B4                           152  
000010B4                           153  
000010B4                           154  *------------------- Convert to hex subroutine -------------------
000010B4                           155  
000010B4  7C00                     156  ASCII_TO_HEX            MOVE.L      #$00000000,D6      ; running total of converted hex number
000010B6                           157                  
000010B6                           158                          ;first digit
000010B6  1A21                     159                          MOVE.B      -(A1),D5  ; Move the raw ascii value of first digit into 3007.
000010B8  BA7C 0030                160                          CMP         #$30,D5
000010BC  6D00 01B2                161                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
000010C0  BA7C 0040                162                          CMP         #$40,D5
000010C4  6700 01AA                163                          BEQ         INVALID_ADDR_INPUT
000010C8  BA7C 0046                164                          CMP         #$46,D5
000010CC  6E00 01A2                165                          BGT         INVALID_ADDR_INPUT   
000010D0                           166                          ; Convert ascii to hex for that digit.
000010D0  0445 0030                167                          SUB         #$30,D5   ;
000010D4  BA7C 000A                168                          CMP         #$A,D5
000010D8  6D00 0004                169                          BLT         DIG_CONV_DONE_1 ; Necessary to convert some ASCII values.
000010DC  5F05                     170                          SUB.B       #7, D5                      ; TODO: errors for invalid ASCII values.
000010DE                           171                  
000010DE  DC45                     172  DIG_CONV_DONE_1         ADD.W       D5,D6
000010E0  B27C 0001                173                          CMP         #1,D1
000010E4  6700 01CA                174                          BEQ         CONVERSION_DONE
000010E8                           175                  
000010E8                           176                          ;second digit
000010E8  7A00                     177                          MOVE.L      #$00000000,D5
000010EA  1A21                     178                          MOVE.B      -(A1),D5
000010EC  BA7C 0030                179                          CMP         #$30,D5
000010F0  6D00 017E                180                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
000010F4  BA7C 0040                181                          CMP         #$40,D5
000010F8  6700 0176                182                          BEQ         INVALID_ADDR_INPUT
000010FC  BA7C 0046                183                          CMP         #$46,D5
00001100  6E00 016E                184                          BGT         INVALID_ADDR_INPUT   
00001104  0445 0030                185                          SUB         #$30,D5
00001108  BA7C 000A                186                          CMP         #$A,D5            
0000110C  6D00 0004                187                          BLT         DIG_CONV_DONE_2    ;digit conversion done 1
00001110  5F05                     188                          SUB.B       #7, D5             ; if we have A or greater, then we need to subtract 1.
00001112                           189               
00001112  CAFC 0010                190  DIG_CONV_DONE_2         MULU.W      #$00000010,D5  ; this part adds $10 * (2nd digit) to our running total.
00001116  DC45                     191                          ADD.W       D5,D6 
00001118                           192                    
00001118  B27C 0002                193                          CMP         #2,D1
0000111C  6700 0192                194                          BEQ         CONVERSION_DONE
00001120                           195                  
00001120                           196                          ;third digit
00001120  7A00                     197                          MOVE.L      #$00000000,D5
00001122  1A21                     198                          MOVE.B      -(A1),D5
00001124  BA7C 0030                199                          CMP         #$30,D5
00001128  6D00 0146                200                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
0000112C  BA7C 0040                201                          CMP         #$40,D5
00001130  6700 013E                202                          BEQ         INVALID_ADDR_INPUT
00001134  BA7C 0046                203                          CMP         #$46,D5
00001138  6E00 0136                204                          BGT         INVALID_ADDR_INPUT   
0000113C  0445 0030                205                          SUB         #$30,D5
00001140  BA7C 000A                206                          CMP         #$A,D5
00001144  6D00 0004                207                          BLT         DIG_CONV_DONE_3 
00001148  5F05                     208                          SUB.B       #7, D5
0000114A                           209                  
0000114A  CAFC 0100                210  DIG_CONV_DONE_3         MULU.W      #$00000100,D5
0000114E  DC45                     211                          ADD.W       D5,D6 
00001150                           212      
00001150  B27C 0003                213                          CMP         #3,D1
00001154  6700 015A                214                          BEQ         CONVERSION_DONE
00001158                           215                  
00001158                           216                          ;fourth digit
00001158  7A00                     217                          MOVE.L      #$00000000,D5
0000115A  1A21                     218                          MOVE.B      -(A1),D5
0000115C  BA7C 0030                219                          CMP         #$30,D5
00001160  6D00 010E                220                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
00001164  BA7C 0040                221                          CMP         #$40,D5
00001168  6700 0106                222                          BEQ         INVALID_ADDR_INPUT
0000116C  BA7C 0046                223                          CMP         #$46,D5
00001170  6E00 00FE                224                          BGT         INVALID_ADDR_INPUT   
00001174  0445 0030                225                          SUB         #$30,D5
00001178  BA7C 000A                226                          CMP         #$A,D5
0000117C  6D00 0004                227                          BLT         DIG_CONV_DONE_4
00001180  5F05                     228                          SUB.B       #7,D5
00001182                           229                  
00001182  CAFC 1000                230  DIG_CONV_DONE_4         MULU.W      #$00001000,D5
00001186  DC45                     231                          ADD.W       D5,D6 
00001188                           232      
00001188  B27C 0004                233                          CMP         #4,D1
0000118C  6700 0122                234                          BEQ         CONVERSION_DONE
00001190                           235                  
00001190                           236                          ;fifth digit
00001190  7A00                     237                          MOVE.L      #$00000000,D5
00001192  1A21                     238                          MOVE.B      -(A1),D5
00001194  BA7C 0030                239                          CMP         #$30,D5
00001198  6D00 00D6                240                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
0000119C  BA7C 0040                241                          CMP         #$40,D5
000011A0  6700 00CE                242                          BEQ         INVALID_ADDR_INPUT
000011A4  BA7C 0046                243                          CMP         #$46,D5
000011A8  6E00 00C6                244                          BGT         INVALID_ADDR_INPUT   
000011AC  0445 0030                245                          SUB         #$30,D5
000011B0  BA7C 000A                246                          CMP         #$A,D5
000011B4  6D00 0004                247                          BLT         DIG_CONV_DONE_5
000011B8  5F05                     248                          SUB.B       #$7, D5
000011BA                           249                  
000011BA  CAFC 0001                250  DIG_CONV_DONE_5         MULU.W      #$0001,D5
000011BE  DE45                     251                          ADD.W       D5,D7 
000011C0                           252  
000011C0  B27C 0005                253                          CMP         #5,D1
000011C4  6700 00EA                254                          BEQ         CONVERSION_DONE
000011C8                           255                  
000011C8                           256                          ;sixth digit
000011C8  7A00                     257                          MOVE.L      #$00000000,D5
000011CA  1A21                     258                          MOVE.B      -(A1),D5
000011CC  BA7C 0030                259                          CMP         #$30,D5
000011D0  6D00 009E                260                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
000011D4  BA7C 0040                261                          CMP         #$40,D5
000011D8  6700 0096                262                          BEQ         INVALID_ADDR_INPUT
000011DC  BA7C 0046                263                          CMP         #$46,D5
000011E0  6E00 008E                264                          BGT         INVALID_ADDR_INPUT   
000011E4  0445 0030                265                          SUB         #$30,D5
000011E8  BA7C 000A                266                          CMP         #$A,D5
000011EC  6D00 0004                267                          BLT         DIG_CONV_DONE_6
000011F0  5F05                     268                          SUB.B       #$7, D5
000011F2                           269                  
000011F2  CAFC 0010                270  DIG_CONV_DONE_6         MULU.W      #$0010,D5
000011F6  DE45                     271                          ADD.W       D5,D7
000011F8                           272      
000011F8  B27C 0006                273                          CMP         #6,D1
000011FC  6700 00B2                274                          BEQ         CONVERSION_DONE
00001200                           275                  
00001200                           276                          ;seventh digit
00001200  7A00                     277                          MOVE.L      #$00000000,D5
00001202  1A21                     278                          MOVE.B      -(A1),D5
00001204  BA7C 0030                279                          CMP         #$30,D5
00001208  6D00 0066                280                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
0000120C  BA7C 0040                281                          CMP         #$40,D5
00001210  6700 005E                282                          BEQ         INVALID_ADDR_INPUT
00001214  BA7C 0046                283                          CMP         #$46,D5
00001218  6E00 0056                284                          BGT         INVALID_ADDR_INPUT   
0000121C  0445 0030                285                          SUB         #$30,D5
00001220  BA7C 000A                286                          CMP         #$A,D5
00001224  6D00 0004                287                          BLT         DIG_CONV_DONE_7
00001228  5F05                     288                          SUB.B       #7, D5
0000122A                           289                  
0000122A  CAFC 0100                290  DIG_CONV_DONE_7         MULU.W      #$0100,D5
0000122E  DE45                     291                          ADD.W       D5,D7
00001230                           292      
00001230  B27C 0007                293                          CMP         #7,D1
00001234  6700 007A                294                          BEQ         CONVERSION_DONE
00001238                           295                  
00001238                           296                          ;eighth digit
00001238  7A00                     297                          MOVE.L      #$00000000,D5
0000123A  1A21                     298                          MOVE.B      -(A1),D5
0000123C  BA7C 0030                299                          CMP         #$30,D5
00001240  6D00 002E                300                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
00001244  BA7C 0040                301                          CMP         #$40,D5
00001248  6700 0026                302                          BEQ         INVALID_ADDR_INPUT
0000124C  BA7C 0046                303                          CMP         #$46,D5
00001250  6E00 001E                304                          BGT         INVALID_ADDR_INPUT   
00001254  0445 0030                305                          SUB         #$30,D5
00001258  BA7C 000A                306                          CMP         #$A,D5
0000125C  6D00 0004                307                          BLT         DIG_CONV_DONE_8
00001260  5F05                     308                          SUB.B       #7, D5
00001262                           309                  
00001262  CAFC 1000                310  DIG_CONV_DONE_8         MULU.W      #$1000,D5
00001266  DE45                     311                          ADD.W       D5,D7
00001268                           312      
00001268  B27C 0008                313                          CMP         #8,D1
0000126C  6700 0042                314                          BEQ         CONVERSION_DONE    ;the input was valid and we are done with the conversion
00001270                           315                  
00001270  43F9 0000209C            316  INVALID_ADDR_INPUT      LEA         INVALID_ADDR_MSG,A1    ;tell the user the address was invalid and prompt input again.
00001276  103C 000E                317                          MOVE.B      #14,D0
0000127A  4E4F                     318                          TRAP        #15
0000127C                           319                          
0000127C  6000 FDB6                320                          BRA         TAKE_USER_INPUT
00001280                           321                          
00001280  43F9 000020D2            322  INVALID_END_ADDR        LEA         INVALID_END_ADDR_MSG,A1
00001286  103C 000E                323                          MOVE.B      #14,D0
0000128A  4E4F                     324                          TRAP        #15
0000128C                           325                          
0000128C  6000 FDA6                326                          BRA         TAKE_USER_INPUT
00001290                           327                          
00001290  43F9 00002123            328  INVALID_ADDR_LOW        LEA         INVALID_ADDR_L_MSG,A1    ;tell the user the address was invalid and prompt input again.
00001296  103C 000E                329                          MOVE.B      #14,D0
0000129A  4E4F                     330                          TRAP        #15
0000129C                           331                          
0000129C  6000 FD96                332                          BRA         TAKE_USER_INPUT
000012A0                           333  
000012A0  43F9 00002163            334  INVALID_ADDR_HIGH       LEA         INVALID_ADDR_H_MSG,A1    ;tell the user the address was invalid and prompt input again.
000012A6  103C 000E                335                          MOVE.B      #14,D0
000012AA  4E4F                     336                          TRAP        #15
000012AC                           337                          
000012AC  6000 FD86                338                          BRA         TAKE_USER_INPUT
000012B0                           339                 
000012B0  E18F                     340  CONVERSION_DONE         LSL.L       #8,D7   ; Prepare for concatenation
000012B2  E18F                     341                          LSL.L       #8,D7   ; Got to perform the same operation twice to get it all the way to the left
000012B4  DE46                     342                          ADD.W       D6,D7  ; concatenate the two data registers into one value
000012B6                           343                          
000012B6  BEBC 00004000            344                          CMP.L       #MIN_ADDRESS,D7
000012BC  6DD2                     345                          BLT         INVALID_ADDR_LOW ;Not a valid address-- too low.
000012BE                           346                          
000012BE  BEBC 0FFF0000            347                          CMP.L       #MAX_ADDRESS,D7
000012C4  6EDA                     348                          BGT         INVALID_ADDR_HIGH  ;Not a valid address-- too high.
000012C6                           349                          
000012C6  0C43 0001                350  VALID_ADDR              CMPI        #1,D3
000012CA                           351                          
000012CA  6700 0006                352                          BEQ         SET_START_ADDR
000012CE  6000 0008                353                          BRA         SET_END_ADDR              
000012D2                           354                                                 
000012D2  2A47                     355  SET_START_ADDR          MOVEA.L     D7,A5  ;when a valid start address is inputted, store and ask the user for an end address.
000012D4  6000 FD4A                356                          BRA         TAKE_USER_IN_E
000012D8                           357  
000012D8  BE8D                     358  SET_END_ADDR            CMP.L       A5,D7    ;if end address is lower than start address, we get an error.
000012DA  6DA4                     359                          BLT         INVALID_END_ADDR           
000012DC                           360                          
000012DC  2C47                     361                          MOVEA.L     D7,A6  ;when a valid start address is inputted, store and ask the user for an end address.
000012DE  6000 0002                362                          BRA         BEGIN_READ
000012E2                           363                          
000012E2  284D                     364  BEGIN_READ              MOVEA.L      A5,A4 ; keep track of address to print with A4. TODO: could also add this value to the display buffer.
000012E4  33DD 00002230            365                          MOVE.W      (A5)+,CURRENT_WORD ;look at the first instruction word at the starting address.
000012EA  6000 0002                366                          BRA         PREPARE_DISPLAY
000012EE                           367  
000012EE                           368  *------------------- Add to display buffer -------------------
000012EE                           369  ;At this point A5 is a valid start address and A6 is a valid end address.
000012EE                           370  ;TODO: prepare the display buffer
000012EE  6000 0030                371  PREPARE_DISPLAY         BRA         READ_CURRENT_OP    ;TEMP (though we might still call this after the display buffer is prepared)                       
000012F2                           372                 
000012F2                           373  *------------------- Move address pointer for data reading -------------------
000012F2                           374  ; This method is specifically for reading the next OPword.
000012F2  6000 0014                375  GO_TO_NEXT_OP           BRA         CHECK_DONE_READING
000012F6                           376                           
000012F6  4279 00002230            377  CONFIRMED_NEXT_OP       CLR         CURRENT_WORD
000012FC  284D                     378                          MOVEA.L     A5,A4 ; keep track of address to print with A4. 
000012FE  33DD 00002230            379                          MOVE.W      (A5)+,CURRENT_WORD
00001304  6000 001A                380                          BRA         READ_CURRENT_OP
00001308                           381                          
00001308                           382  *------------------- Print display buffer -------------------
00001308                           383  
00001308                           384  ;TODO
00001308                           385  
00001308                           386  *------------------- Check if end of data -------------------
00001308  BACE                     387  CHECK_DONE_READING      CMPA        A6,A5       ; TODO: this comparison is not sufficient, because it will say that $8000 is less than $7000 (since $8000 is negative.)
0000130A  6DEA                     388                          BLT         CONFIRMED_NEXT_OP
0000130C  6000 0002                389                          BRA         DONE_READING
00001310                           390                          
00001310                           391  *------------------- Confirm end of data -------------------
00001310  43F9 000021A4            392  DONE_READING            LEA         DONE_READING_MSG,A1 ; when we reach the end address, say so and halt the program. TODO: ask user whether we want to read the data again.
00001316  103C 000E                393                          MOVE.B      #14,D0
0000131A  4E4F                     394                          TRAP        #15
0000131C  4EF8 1004                395                          JMP         STOP
00001320                           396                          
00001320                           397  *################## END IO  #####################################
00001320                           398  *################## BEGIN OPCODE ##########################
00001320                           399  *** OPcode Subroutines are kept here ***
00001320                           400  
00001320                           401  ; planned process for reading hex instructions:
00001320                           402          ; NOTE: this process is tentative and subject to change as OPcode person implements. 
00001320                           403                  ;           1) Go to start of instruction reading loop, passing in the address of next instruction.
00001320                           404                  ;           2) Store a word (16 bits) from that address.
00001320                           405                  ;           3) Read the first 4 bits of the word using a filter.
00001320                           406                  ;           4) branch to one of the following paths based on these bits:
00001320                           407                  ;               a) 0000: Read the next 3 bits (i.e., the destination mode). Branch:
00001320                           408                  ;                   i.   000: Read the bits at 0000 0000 XXXX XXXX (may want to make this filter) Branch:
00001320                           409                  ;                       1) 00 111 100: ORI TO CCR (need to read data, I think)
00001320                           410                  ;                       2) 01 111 100: ORI TO SR (need to read data, I think)
00001320                           411                  ;                       3) (default) ORI. Now, read and store:
00001320                           412                  ;                           SIZE:       0000 0000 XX00 0000 (need to make this filter)
00001320                           413                  ;                           MODE:       0000 0000 00XX X000 (need to make this filter)
00001320                           414                  ;                           REGISTER:   0000 0000 0000 0XXX (need to make this filter)
00001320                           415                  ;                           only mandatory additional data is the immediate data.
00001320                           416                  ;                   ii.  001: Read the bits at 0000 0000 XXXX XXXX (may want to make this filter) Branch:
00001320                           417                  ;                       1) 00 111 100: ANDI TO CCR (need to read data, I think)
00001320                           418                  ;                       2) 01 111 100: ANDI TO SR (need to read data, I think)
00001320                           419                  ;                       3) (default) ANDI. Now, read and store:
00001320                           420                  ;                           SIZE:       0000 0000 XX00 0000 (need to make this filter)
00001320                           421                  ;                           MODE:       0000 0000 00XX X000 (need to make this filter)
00001320                           422                  ;                           REGISTER:   0000 0000 0000 0XXX (need to make this filter)
00001320                           423                  ;                           only mandatory additional data is the immediate data.
00001320                           424                  ;                   iii. 101: Read the bits at 0000 0000 XXXX XXXX (may want to make this filter) Branch:
00001320                           425                  ;                       1) 00 111 100: EORI TO CCR (need to read data, I think)
00001320                           426                  ;                       2) 01 111 100: EORI TO SR (need to read data, I think)
00001320                           427                  ;                       3) (default) EORI. Now, read and store:
00001320                           428                  ;                           SIZE:       0000 0000 XX00 0000 (need to make this filter)
00001320                           429                  ;                           MODE:       0000 0000 00XX X000 (FILT_SRC_MODE)
00001320                           430                  ;                           REGISTER:   0000 0000 0000 0XXX (FILT_SRC_REG)
00001320                           431                  ;                           only mandatory additional data is the immediate data.
00001320                           432                  ;                   iv.  011: ADDI. Now read and store:
00001320                           433                  ;                           SIZE:       0000 0000 XX00 0000 (need to make this filter)
00001320                           434                  ;                           MODE:       0000 0000 00XX X000 (FILT_SRC_MODE)
00001320                           435                  ;                           REGISTER:   0000 0000 0000 0XXX (FILT_SRC_REG)
00001320                           436                  ;                           only mandatory additional data is the immediate data.
00001320                           437                  ;                   v.   010: SUBI. Now read and store:
00001320                           438                  ;                           SIZE:       0000 0000 XX00 0000 (need to make this filter)
00001320                           439                  ;                           MODE:       0000 0000 00XX X000 (FILT_SRC_MODE)
00001320                           440                  ;                           REGISTER:   0000 0000 0000 0XXX (FILT_SRC_REG)
00001320                           441                  ;                           only mandatory additional data is the immediate data.
00001320                           442                  ;                   vi.  110: CMPI. Now read and store:
00001320                           443                  ;                           SIZE:       0000 0000 XX00 0000 (need to make this filter)
00001320                           444                  ;                           MODE:       0000 0000 00XX X000 (FILT_SRC_MODE)
00001320                           445                  ;                           REGISTER:   0000 0000 0000 0XXX (FILT_SRC_REG)
00001320                           446                  ;                           only mandatory additional data is the immediate data.
00001320                           447                  ;                   vii. 100: BTST, BCHG, BCLR, BSET (TODO: expand this section if we need these OPcodes)
00001320                           448                  ;                   viii.(default): BTST, BCHG, BCLR, BSET (with data register)(TODO: expand this section if we need these OPcodes)
00001320                           449                  ;               b) 0001: (MOVE.B). Now read and store:
00001320                           450                  ;                           DESTINATION REGISTER: 0000 XXX0 0000 0000 (FILT_DEST_REG)
00001320                           451                  ;                           DESTINATION MODE:     0000 000X XX00 0000 (FILT_DEST_MODE)
00001320                           452                  ;                           SOURCE MODE:          0000 0000 00XX X000 (FILT_SCR_MODE)
00001320                           453                  ;                           SOURCE REGISTER:      0000 0000 0000 0XXX (FILT_SRC_REG)
00001320                           454                  ;                           The modes (and maybe register) will tell us whether we need to read additional data for this MOVE.
00001320                           455                  ;               c) 0011: (MOVE.W). Now read and store:
00001320                           456                  ;                           DESTINATION REGISTER: 0000 XXX0 0000 0000 (FILT_DEST_REG)
00001320                           457                  ;                           DESTINATION MODE:     0000 000X XX00 0000 (FILT_DEST_MODE)
00001320                           458                  ;                           SOURCE MODE:          0000 0000 00XX X000 (FILT_SCR_MODE)
00001320                           459                  ;                           SOURCE REGISTER:      0000 0000 0000 0XXX (FILT_SRC_REG)
00001320                           460                  ;                           The modes (and maybe register) will tell us whether we need to read additional data for this MOVE.
00001320                           461                  ;               d) 0010: (MOVE.L). Now read and store:
00001320                           462                  ;                           DESTINATION REGISTER: 0000 XXX0 0000 0000 (FILT_DEST_REG)
00001320                           463                  ;                           DESTINATION MODE:     0000 000X XX00 0000 (FILT_DEST_MODE)
00001320                           464                  ;                           SOURCE MODE:          0000 0000 00XX X000 (FILT_SCR_MODE)
00001320                           465                  ;                           SOURCE REGISTER:      0000 0000 0000 0XXX (FILT_SRC_REG)
00001320                           466                  ;                           The modes (and maybe register) will tell us whether we need to read additional data for this MOVE.
00001320                           467                  ;               e) 0100: Read the bits at 0000 XXXX 0000 0000 (need filter) Branch:
00001320                           468                  ;                   i.      0000: Read the bits at 0000 0000 XX00 0000 (need filter) Branch:
00001320                           469                  ;                               1. 11: MOVE from SR. (TODO)
00001320                           470                  ;                               2. (DEFAULT) NEGX. (the two bits are size) (TODO)
00001320                           471                  ;                   ii.     0100: Read the bits at 0000 0000 XX00 0000 (need filter) Branch:
00001320                           472                  ;                               1. 11 MOVE to CCR. (TODO)
00001320                           473                  ;                               2. (DEFAULT) NEG. (the two bits are size) (TODO)
00001320                           474                  ;                   iii.    0110: Read the bits at 0000 0000 XX00 0000 (need filter) Branch:
00001320                           475                  ;                               1. 11 MOVE to SR. (TODO)
00001320                           476                  ;                               2. (DEFAULT) NOT. (the two bits are size) (TODO)
00001320                           477                  ;                   iv.     0010: CLR. (TODO)
00001320                           478                  ;                    v.     1000: (EXT, NBCD, SWAP, PEA, MOVEM (dir 0)) (TODO)
00001320                           479                  ;                   vi.     1010: Check the bits at 0000 XX00 0000 0000 (need filter) Branch:
00001320                           480                  ;                           1. 11: check the bits at 0000 00XX XXXX XXXX (need filter) Branch:
00001320                           481                  ;                               a. 11 1100: ILLEGAL (TODO)
00001320                           482                  ;                               b. (default) TAS (TODO)
00001320                           483                  ;                           2. (default) TST (TODO)
00001320                           484                  ;                  vii.     1110: (TRAP, LINK, UNLK, MOVE USP, RESET, NOP, STOP, RTE, RTS, TRAPV, RTR, JSR, JMP) (TODO)
00001320                           485                  ;                 viii.     (DEFAULT): (MOVEM, LEA, CHK,) (TODO)    
00001320                           486                  ;               f) 0101: (ADDQ, SUBQ, Scc, DBcc): Read the bits at 0000 0000 XX00 0000 (need filter) Branch:
00001320                           487                  ;                    i. 11: Read the bit at 0000 000X 0000 0000 (need filter) Branch:
00001320                           488                  ;                           1. 0: ADDQ (TODO)
00001320                           489                  ;                           2. 1: SUBQ (TODO)
00001320                           490                  ;                   ii. (default) (bits are size) read the bits at 0000 00XX X000 (FILT_SRC_MODE). Branch:
00001320                           491                  ;                           1. 001: DBCC (TODO)
00001320                           492                  ;                           2. (default): Scc (TODO)
00001320                           493                  ;               g) 0110: Read the bit at 0000 XXXX 0000 0000 (need filter) Branch:
00001320                           494                  ;                    i. 0000: BRA (TODO)
00001320                           495                  ;                   ii. 0001: BSR (TODO)
00001320                           496                  ;                  iii. (default) Bcc (TODO)
00001320                           497                  ;               h) 0111: MOVEQ (TODO)
00001320                           498                  ;               i) 1000: (DIVU, DIVS, SBCD, OR) (TODO)
00001320                           499                  ;               j) 1001: (SUB, SUBX, SUBA) (TODO)
00001320                           500                  ;               k) 1011: (EOR, CMPM, CMP, CMPA) (TODO)
00001320                           501                  ;               l) 1100: (MULU, MULS, ABCD, EXG, AND) (TODO)
00001320                           502                  ;               m) 1101: (ADD, ADDX, ADDA) (TODO)
00001320                           503                  ;               n) 1110: (ASd, LSd, ROXd, ROd, ASd, LSd, ROXd, ROd) (TODO)
00001320                           504                  ;               o) (default) The code is invalid. Not yet sure what we do in this case.
00001320                           505                  ;   
00001320                           506                  ;   
00001320                           507                  ;
00001320                           508                  
00001320                           509                  ;TODO: Use AND operations with filters to create values which can be
00001320                           510                  ;      checked against constants to narrow down OPcodes.
00001320                           511                  
00001320                           512                  ;TODO: Since it will take a while to decode every possible OPcode, we
00001320                           513                  ;      should first have a default "Error" subroutine which the program
00001320                           514                  ;      branches to once all other possibilities have been ruled out.
00001320                           515  
00001320                           516  *------------------- Read current OPcode -------------------
00001320                           517  ; By this point, CURRENT_WORD should store a potential beginning of an instruction, so we should not increment A5.
00001320  6000 0028                518  READ_CURRENT_OP         BRA         CHECK_CONSTANTS
00001324                           519                          
00001324                           520    
00001324                           521  *------------------- Display current address we are reading -------------------
00001324  43F9 00001FD7            522  DISPLAY_CURRENT_ADDRESS LEA         DOLLAR,A1       ; '$'
0000132A  103C 000E                523                          MOVE.B      #14,D0
0000132E  4E4F                     524                          TRAP        #15
00001330                           525                  
00001330  220C                     526                          MOVE.L      A4,D1           ; display the address the instruction was found at
00001332  143C 0010                527                          MOVE.B      #16,D2
00001336  103C 000F                528                          MOVE.B      #15,D0
0000133A  4E4F                     529                          TRAP        #15
0000133C                           530  
0000133C  43F9 00001FD5            531                          LEA         SPACE,A1        ; ' '
00001342  103C 000E                532                          MOVE.B      #14,D0      
00001346  4E4F                     533                          TRAP        #15     
00001348                           534                          
00001348  4E75                     535                          RTS
0000134A                           536   
0000134A                           537  *------------------ Check current word for constants---------
0000134A                           538  ; By this point, the current word should store a potential beginning of an instruction.                   
0000134A  0C79 4E70 00002230       539  CHECK_CONSTANTS         CMP         #RESET_CODE,(CURRENT_WORD)
00001352  6700 001E                540                          BEQ         RESET_FOUND
00001356  0C79 4E71 00002230       541                          CMP         #NOP_CODE,(CURRENT_WORD)
0000135E  6700 0030                542                          BEQ         NOP_FOUND
00001362  0C79 4E72 00002230       543                          CMP         #STOP_CODE,(CURRENT_WORD)
0000136A  6700 0042                544                          BEQ         STOP_FOUND
0000136E  6000 0042                545                          BRA         CHECK_NON_CONSTANTS     ;Once we rule out all the constants we know of, we check for non-constants.
00001372                           546  
00001372                           547  ; TODO: change the structure of these subroutines to be like the nice structure used in EA SRs.
00001372                           548                         
00001372  61B0                     549  RESET_FOUND             BSR         DISPLAY_CURRENT_ADDRESS
00001374                           550  
00001374  43F9 000021C9            551                          LEA         RESET_MSG,A1    ; 'RESET'
0000137A  103C 000E                552                          MOVE.B      #14,D0
0000137E  4E4F                     553                          TRAP        #15
00001380                           554                          
00001380  43F9 00001FD2            555                          LEA         RETURN,A1       ; (return)
00001386  103C 000E                556                          MOVE.B      #14,D0
0000138A  4E4F                     557                          TRAP        #15
0000138C                           558                 
0000138C  6000 FF64                559                          BRA         GO_TO_NEXT_OP   
00001390                           560   
00001390                           561  ; NOTE: this SR is temporary. Once we have the display buffer, it will work differently.                 
00001390  6192                     562  NOP_FOUND               BSR         DISPLAY_CURRENT_ADDRESS
00001392                           563  
00001392  43F9 000021CF            564                          LEA         NOP_MSG,A1    ; 'NOP'
00001398  103C 000E                565                          MOVE.B      #14,D0
0000139C  4E4F                     566                          TRAP        #15
0000139E                           567                          
0000139E  43F9 00001FD2            568                          LEA         RETURN,A1     ; (return)
000013A4  103C 000E                569                          MOVE.B      #14,D0
000013A8  4E4F                     570                          TRAP        #15
000013AA                           571                 
000013AA  6000 FF46                572                          BRA         GO_TO_NEXT_OP   ; when we are done parsing and displaying the NOP instruction, go to the next OPcode.
000013AE                           573  
000013AE  4EF8 1004                574  STOP_FOUND              JMP         STOP  ;TODO: case for stop found. (NOTE that STOP instructions have additional data.)               
000013B2                           575  
000013B2                           576  ;TODO: add cases for rest of valid constant OPcodes here
000013B2                           577  
000013B2                           578  *----------------- Check current word for non-constants---------
000013B2                           579  ;NOTE: we currently know that CURRENT_WORD is not a constant by the time we reach this SR.
000013B2                           580  
000013B2  6100 0232                581  CHECK_NON_CONSTANTS     BSR         CHECK_MOVE        ; MOVE is a special case because of how its first nibble is structured.     
000013B6  6100 0254                582                          BSR         CHECK_MOVEQ       ; MOVEQ is also a special case.
000013BA  6100 0266                583                          BSR         CHECK_EXT         ; need to rule out EXT before checking MOVEM, because they have very similar OPcodes.
000013BE  6100 0278                584                          BSR         CHECK_MOVEM      
000013C2  6100 002A                585                          BSR         CHECK_NIB1_0000 
000013C6  6100 003C                586                          BSR         CHECK_NIB1_0100 
000013CA  6100 004E                587                          BSR         CHECK_NIB1_0101
000013CE  6100 0060                588                          BSR         CHECK_NIB1_0110
000013D2  6100 0072                589                          BSR         CHECK_NIB1_1000
000013D6  6100 0082                590                          BSR         CHECK_NIB1_1001
000013DA  6100 0094                591                          BSR         CHECK_NIB1_1011
000013DE  6100 00A6                592                          BSR         CHECK_NIB1_1100
000013E2  6100 00B8                593                          BSR         CHECK_NIB1_1101
000013E6  6100 00CA                594                          BSR         CHECK_NIB1_1110
000013EA                           595                          
000013EA                           596                          ; TODO: If we get to here, there should be an error.
000013EA                           597                          
000013EA                           598                          ;NOTE: we do not check for most specific instructions here.
000013EA                           599  
000013EA                           600                          ; TODO: go into the subroutines below and *fully* implement the followings:
000013EA                           601                          *   -ADD    (B,W,L) (will need shahin's size filter for this and below)
000013EA                           602                          *   -ADDA   (W,L)
000013EA                           603                          *   -ADDI   (B,W,L)
000013EA                           604                          *   -SUB    (B,W,L)
000013EA                           605                          ;etc
000013EA  4EF8 1004                606                          JMP         STOP
000013EE                           607                          ;TODO: check for other instructions instead of stopping if it's not one of these.
000013EE                           608    
000013EE                           609  *-----------------------First 4bit checks go here-----------------------------------
000013EE                           610    
000013EE                           611  *-----------------------Check if the current word starts with 0000--------------------
000013EE  4243                     612  CHECK_NIB1_0000         CLR         D3
000013F0  3639 00002230            613                          MOVE.W      CURRENT_WORD,D3
000013F6  0243 F000                614                          ANDI.W      #FILT_NIB_1,D3  ; filter out the first 4 bits of the word
000013FA  B67C 0000                615                          CMP         #CONST_ALL_0,D3 ; see if they are 0000
000013FE  6700 00C8                616                          BEQ         CONFIRM_NIB1_0000
00001402  4E75                     617                          RTS 
00001404                           618                          
00001404  4243                     619  CHECK_NIB1_0100         CLR         D3 
00001406  3639 00002230            620                          MOVE.W      CURRENT_WORD,D3
0000140C  0243 F000                621                          ANDI.W      #FILT_NIB_1,D3      ; filter out the first 4 bits of the word
00001410  B67C 4000                622                          CMP         #CONST_NIB1_0100,D3 ; see if they are 0100
00001414  6700 0108                623                          BEQ         CONFIRM_NIB1_0100
00001418  4E75                     624                          RTS                        
0000141A                           625                          
0000141A  4243                     626  CHECK_NIB1_0101         CLR         D3 
0000141C  3639 00002230            627                          MOVE.W      CURRENT_WORD,D3
00001422  0243 F000                628                          ANDI.W      #FILT_NIB_1,D3      ; filter out the first 4 bits of the word
00001426  B67C 5000                629                          CMP         #CONST_NIB1_0101,D3 ; see if they are 0101
0000142A  6700 0172                630                          BEQ         CONFIRM_NIB1_0101
0000142E  4E75                     631                          RTS  
00001430                           632                
00001430  4243                     633  CHECK_NIB1_0110         CLR         D3 
00001432  3639 00002230            634                          MOVE.W      CURRENT_WORD,D3
00001438  0243 F000                635                          ANDI.W      #FILT_NIB_1,D3      ; filter out the first 4 bits of the word
0000143C  B67C 6000                636                          CMP         #CONST_NIB1_0110,D3 ; see if they are 0110
00001440  6700 0160                637                          BEQ         CONFIRM_NIB1_0110
00001444  4E75                     638                          RTS  
00001446                           639                     
00001446  4243                     640  CHECK_NIB1_1000         CLR         D3 
00001448  3639 00002230            641                          MOVE.W      CURRENT_WORD,D3
0000144E  0243 F000                642                          ANDI.W      #FILT_NIB_1,D3      ; filter out the first 4 bits of the word
00001452  B67C 8000                643                          CMP         #CONST_NIB1_1000,D3 ; see if they are 1000
00001456  6700 014E                644                          BEQ         CONFIRM_NIB1_1000
0000145A                           645          
0000145A  4243                     646  CHECK_NIB1_1001         CLR         D3 
0000145C  3639 00002230            647                          MOVE.W      CURRENT_WORD,D3
00001462  0243 F000                648                          ANDI.W      #FILT_NIB_1,D3      ; filter out the first 4 bits of the word
00001466  B67C 9000                649                          CMP         #CONST_NIB1_1001,D3 ; see if they are 1001
0000146A  6700 013E                650                          BEQ         CONFIRM_NIB1_1001
0000146E  4E75                     651                          RTS
00001470                           652  
00001470  4243                     653  CHECK_NIB1_1011         CLR         D3 
00001472  3639 00002230            654                          MOVE.W      CURRENT_WORD,D3
00001478  0243 F000                655                          ANDI.W      #FILT_NIB_1,D3      ; filter out the first 4 bits of the word
0000147C  B67C B000                656                          CMP         #CONST_NIB1_1011,D3 ; see if they are 1011
00001480  6700 012C                657                          BEQ         CONFIRM_NIB1_1011
00001484  4E75                     658                          RTS 
00001486                           659  
00001486  4243                     660  CHECK_NIB1_1100         CLR         D3 
00001488  3639 00002230            661                          MOVE.W      CURRENT_WORD,D3
0000148E  0243 F000                662                          ANDI.W      #FILT_NIB_1,D3      ; filter out the first 4 bits of the word
00001492  B67C C000                663                          CMP         #CONST_NIB1_1100,D3 ; see if they are 1100
00001496  6700 011A                664                          BEQ         CONFIRM_NIB1_1100
0000149A  4E75                     665                          RTS 
0000149C                           666  
0000149C  4243                     667  CHECK_NIB1_1101         CLR         D3 
0000149E  3639 00002230            668                          MOVE.W      CURRENT_WORD,D3
000014A4  0243 F000                669                          ANDI.W      #FILT_NIB_1,D3      ; filter out the first 4 bits of the word
000014A8  B67C D000                670                          CMP         #CONST_NIB1_1101,D3 ; see if they are 1101
000014AC  6700 0108                671                          BEQ         CONFIRM_NIB1_1101
000014B0  4E75                     672                          RTS 
000014B2                           673                          
000014B2  4243                     674  CHECK_NIB1_1110         CLR         D3 
000014B4  3639 00002230            675                          MOVE.W      CURRENT_WORD,D3
000014BA  0243 F000                676                          ANDI.W      #FILT_NIB_1,D3      ; filter out the first 4 bits of the word
000014BE  B67C E000                677                          CMP         #CONST_NIB1_1110,D3 ; see if they are 1110
000014C2  6700 011E                678                          BEQ         CONFIRM_NIB1_1110
000014C6  4E75                     679                          RTS 
000014C8                           680                          
000014C8                           681  *-----------------------First 4bit confirms go here--------------------------------------
000014C8                           682  
000014C8                           683  *-----------------------Cases where the current word starts with 0000--------------------                       
000014C8  4243                     684  CONFIRM_NIB1_0000       CLR         D3
000014CA  3639 00002230            685                          MOVE.W      CURRENT_WORD,D3
000014D0  0243 0100                686                          ANDI.W      #FILT_BIT_8,D3  ; turn word into 0000 000X 0000 0000
000014D4  E04B                     687                          LSR.W       #8,D3           ; turn word into 0000 0000 0000 000X
000014D6  B67C 0000                688                          CMP         #CONST_ALL_0,D3 ; see if the word is still 0.
000014DA  6700 0004                689                          BEQ         CONFIRM_0000_XXX0
000014DE                           690                          ; if we get to here, then the word must be BCHG, BCLR, BSET, or MOVEP.
000014DE                           691                          ; BCHG is required
000014DE                           692                          ; if our disassembler doesn't consider any of those valid, there should be an error message here.
000014DE  4E75                     693                          RTS 
000014E0                           694                          
000014E0                           695  ; at this point, the word is of the form 0000 XXX0...
000014E0  4243                     696  CONFIRM_0000_XXX0       CLR         D3
000014E2  3639 00002230            697                          MOVE.W      CURRENT_WORD,D3
000014E8  0243 0E00                698                          ANDI.W      #FILT_DEST_REG,D3  ; turn word into 0000 XXX0 0000 0000          
000014EC                           699                          
000014EC                           700                          ; now figure out which operation we have: (note that constants have been ruled out by this point)
000014EC                           701                          
000014EC  B67C 0000                702                          CMP         #CONST_ORI_DEST_REG,D3  ; ORI 
000014F0  6700 05BE                703                          BEQ         ORI_FOUND           
000014F4                           704                          
000014F4  B67C 0200                705                          CMP         #CONST_ANDI_DEST_REG,D3 ; ANDI 
000014F8  6700 05BA                706                          BEQ         ANDI_FOUND
000014FC                           707                          
000014FC  B67C 0400                708                          CMP         #CONST_SUBI_DEST_REG,D3 ; SUBI
00001500  6700 05B6                709                          BEQ         SUBI_FOUND
00001504                           710                          ;
00001504  B67C 0600                711                          CMP         #CONST_ADDI_DEST_REG,D3 ; ADDI
00001508  6700 05B2                712                          BEQ         ADDI_FOUND
0000150C                           713                          
0000150C  B67C 0A00                714                          CMP         #CONST_EORI_DEST_REG,D3 ; EORI
00001510  6700 05AE                715                          BEQ         EORI_FOUND
00001514                           716                          
00001514  B67C 0C00                717                          CMP         #CONST_CMPI_DEST_REG,D3 ; CMPI
00001518  6700 05AA                718                          BEQ         CMPI_FOUND
0000151C                           719                          
0000151C                           720                          ;TODO: remaining: BTST, BCHG, BCLR, or BSET. 
0000151C                           721                          ;      if none of them, an error case should occur here.
0000151C                           722                          ;     (note that BCHG is required, though we don't know which version.)
0000151C                           723                          
0000151C  4E75                     724                          RTS     ;change RTS to whatever branch instruction is appropriate here.
0000151E                           725                          
0000151E                           726  *-----------------------Cases where the current word starts with 0100-----------------
0000151E                           727  
0000151E                           728  CONFIRM_NIB1_0100       ; TODO: check for MOVE from SR, MOVE to CCR, MOVE to SR here.
0000151E  4243                     729                          CLR         D3              
00001520  3639 00002230            730                          MOVE.W      CURRENT_WORD,D3
00001526  0243 0800                731                          ANDI.W      #FILT_BIT_5,D3  ; turn word into 0000 X000 0000 0000
0000152A  E04B                     732                          LSR.W       #8,D3           ; turn word into 0000 0000 0000 000X
0000152C  E64B                     733                          LSR.W       #3,D3
0000152E  B67C 0000                734                          CMP         #CONST_ALL_0,D3 ; see if the word is still 0.
00001532  6700 0006                735                          BEQ         CONFIRM_0100_0XXX   ; branch based on the 5th bit.
00001536  6000 0032                736                          BRA         CONFIRM_0100_1XXX
0000153A                           737                          
0000153A  4243                     738  CONFIRM_0100_0XXX       CLR         D3              
0000153C  3639 00002230            739                          MOVE.W      CURRENT_WORD,D3
00001542  0243 0F00                740                          ANDI.W      #FILT_NIB_2,D3  ; turn word into 0000 XXXX 0000 0000
00001546                           741                          
00001546                           742                          ; now figure out which operation we have:
00001546                           743                          
00001546  B67C 0000                744                          CMP         #CONST_NEGX_OP,D3
0000154A  6700 057C                745                          BEQ         NEGX_FOUND
0000154E                           746                          
0000154E  B67C 0200                747                          CMP         #CONST_CLR_OP,D3
00001552  6700 0578                748                          BEQ         CLR_FOUND
00001556                           749                          
00001556  B67C 0400                750                          CMP         #CONST_NEG_OP,D3
0000155A  6700 0574                751                          BEQ         NEG_FOUND
0000155E                           752                          
0000155E  B67C 0600                753                          CMP         #CONST_NOT_OP,D3
00001562  6700 0570                754                          BEQ         NOT_FOUND         ; note that we could likely make a conflicting SR name with one.
00001566                           755                          
00001566                           756                          ; TODO: we definitely have an error at this point.
00001566                           757                          
00001566  4EF8 1004                758                          JMP         STOP     ;change STOP to whatever we want based on error. (probably some error case which will then branch to reading next OPcode.)
0000156A                           759                          
0000156A  4243                     760  CONFIRM_0100_1XXX       CLR         D3
0000156C  3639 00002230            761                          MOVE.W      CURRENT_WORD,D3
00001572  0243 0F00                762                          ANDI.W      #FILT_NIB_2,D3  ; turn word into 0000 XXXX 0000 0000
00001576                           763                          
00001576  B67C 0800                764                          CMP         #CONST_NIB2_1000,D3
0000157A  6700 0016                765                          BEQ         CONFIRM_0100_1000
0000157E                           766  
0000157E  B67C 0A00                767                          CMP         #CONST_NIB2_1010,D3
00001582  6700 0012                768                          BEQ         CONFIRM_0100_1010 
00001586                           769  
00001586  B67C 0E00                770                          CMP         #CONST_NIB2_1110,D3
0000158A  6700 000E                771                          BEQ         CONFIRM_0100_1110 
0000158E                           772                          ; TODO: remaining possibilities are LEA or CHK. (LEA is required.)
0000158E                           773  
0000158E  4EF8 1004                774                          JMP         STOP                      
00001592                           775                     
00001592  4EF8 1004                776  CONFIRM_0100_1000       JMP         STOP                       
00001596                           777  ; TODO: check for NBCD, SWAP, or PEA. (EXT is already ruled out.)              
00001596                           778   
00001596  4EF8 1004                779  CONFIRM_0100_1010       JMP         STOP  
0000159A                           780  ; TODO: check for TAS or TST. (ILLEGAL is already ruled out.)         
0000159A                           781         
0000159A  4EF8 1004                782  CONFIRM_0100_1110       JMP         STOP       
0000159E                           783  ; TODO: check for TRAP, LINK, UNLK, MOVE USP, JSR, or JMP. (some of these are required.)
0000159E                           784  
0000159E                           785  *-----------------------Cases where the current word starts with 0101-----------------
0000159E  4EF8 1004                786  CONFIRM_NIB1_0101        JMP         STOP
000015A2                           787        
000015A2                           788                          
000015A2                           789      ;TODO: ADDQ, SUBQ, Scc, DBcc (some of these are required)
000015A2                           790   
000015A2                           791  *-----------------------Cases where the current word starts with 0110-----------------
000015A2  4EF8 1004                792  CONFIRM_NIB1_0110        JMP         STOP
000015A6                           793      ;TODO: BRA, BSR, Bcc (some of these are required)   
000015A6                           794      
000015A6                           795  *-----------------------Cases where the current word starts with 1000-----------------
000015A6  4EF8 1004                796  CONFIRM_NIB1_1000        JMP         STOP
000015AA                           797      ;TODO: DIVU, DIVS, SBCD, OR (some of these are required)   
000015AA                           798      
000015AA                           799  *-----------------------Cases where the current word starts with 1001-----------------
000015AA  4EF8 1004                800  CONFIRM_NIB1_1001        JMP         STOP
000015AE                           801      ;TODO: SUB, SUBX, SUBA (some of these are required) 
000015AE                           802   
000015AE                           803  *-----------------------Cases where the current word starts with 1011-----------------
000015AE  4EF8 1004                804  CONFIRM_NIB1_1011        JMP         STOP
000015B2                           805      ;TODO: EOR, CMPM, CMP, CMPA (some of these are required)  
000015B2                           806      
000015B2                           807  *-----------------------Cases where the current word starts with 1100-----------------
000015B2  4EF8 1004                808  CONFIRM_NIB1_1100        JMP         STOP
000015B6                           809      ;TODO: MULU, MULS, ABCD, EXG, AND (some of these are required) 
000015B6                           810      
000015B6                           811  *-----------------------Cases where the current word starts with 1101-----------------
000015B6  4243                     812  CONFIRM_NIB1_1101        CLR         D3                 ; XXXX XXXX 11XX XXXX means ADDA
000015B8  3639 00002230            813                           MOVE.W      CURRENT_WORD,D3
000015BE  0243 00C0                814                           ANDI.W      #FILT_ADDA,D3
000015C2  B67C 00C0                815                           CMP         #CONST_ADDA,D3
000015C6  6700 0530                816                           BEQ         ADDA_FOUND
000015CA                           817                           
000015CA  4243                     818                           CLR         D3                 ; XXXX XXX1 XX00 XXXX means ADDX 
000015CC  3639 00002230            819                           MOVE.W      CURRENT_WORD,D3
000015D2  0243 0130                820                           ANDI.W      #FILT_ADDX,D3
000015D6  B67C 0100                821                           CMP         #CONST_ADDX,D3
000015DA  6700 0518                822                           BEQ         ADDX_FOUND
000015DE                           823                           
000015DE  6000 04F8                824                           BRA         ADD_FOUND          ; everything else means ADD
000015E2                           825  
000015E2                           826      ; TODO: ADD (next major goal)
000015E2                           827      ; TODO: ADDX, ADDA (some of these are required) 
000015E2                           828      
000015E2                           829  *-----------------------Cases where the current word starts with 1110-----------------
000015E2  4EF8 1004                830  CONFIRM_NIB1_1110        JMP         STOP
000015E6                           831      ;TODO: ASR, ASL, LSR, LSL, ROXR, ROXL, ROR, ROL (these are all repeated twice on the sheet for some reason) 
000015E6                           832                                                      ;(some of these are required) 
000015E6                           833   
000015E6                           834  *-----------------------Special OPcode (but not constants) have checks here------------
000015E6                           835  * includes MOVE, MOVEQ, etc
000015E6                           836                                  
000015E6                           837  *-----------------------Check current word for MOVE------------------------------------
000015E6                           838  *MOVE can be B,W, or L.
000015E6  4243                     839  CHECK_MOVE              CLR         D3
000015E8  3639 00002230            840                          MOVE.W      CURRENT_WORD,D3
000015EE  0243 F000                841                          ANDI.W      #FILT_NIB_1,D3
000015F2  B67C 1000                842                          CMP         #CONST_MOVE_B,D3
000015F6  6700 0056                843                          BEQ         MOVE_B_FOUND
000015FA  B67C 3000                844                          CMP         #CONST_MOVE_W,D3
000015FE  6700 007E                845                          BEQ         MOVE_W_FOUND
00001602  B67C 2000                846                          CMP         #CONST_MOVE_L,D3
00001606  6700 00A6                847                          BEQ         MOVE_L_FOUND
0000160A  4E75                     848                          RTS 
0000160C                           849                          
0000160C                           850  *-----------------------Check current word for MOVEQ------------------------------------
0000160C                           851  *MOVEQ can only be L.                       
0000160C  4243                     852  CHECK_MOVEQ             CLR         D3
0000160E  3639 00002230            853                          MOVE.W      CURRENT_WORD,D3
00001614  0243 F000                854                          ANDI.W      #FILT_NIB_1,D3
00001618  B67C 7000                855                          CMP         #CONST_MOVEQ,D3
0000161C  6700 00FC                856                          BEQ         MOVEQ_FOUND
00001620  4E75                     857                          RTS 
00001622                           858                          
00001622                           859  
00001622                           860  *-----------------------Check current word for EXT------------------------------------  
00001622                           861  *check EXT before MOVEM, since they can be easily confused.
00001622                           862  *EXT can be W or L.                  
00001622  4243                     863  CHECK_EXT               CLR         D3                  
00001624  3639 00002230            864                          MOVE.W      CURRENT_WORD,D3
0000162A  0243 FFB8                865                          ANDI.W      #FILT_EXT,D3
0000162E  B67C 4880                866                          CMP         #CONST_EXT,D3
00001632  6700 0174                867                          BEQ         EXT_FOUND
00001636  4E75                     868                          RTS 
00001638                           869                          
00001638                           870  *-----------------------Check current word for MOVEM------------------------------------  
00001638                           871  *MOVEM can be W or L.                  
00001638  4243                     872  CHECK_MOVEM             CLR         D3                         
0000163A  3639 00002230            873                          MOVE.W      CURRENT_WORD,D3
00001640  0243 FB80                874                          ANDI.W      #FILT_MOVEM,D3
00001644  B67C 4880                875                          CMP         #CONST_MOVEM,D3
00001648  6700 0162                876                          BEQ         MOVEM_FOUND
0000164C  4E75                     877                          RTS 
0000164E                           878                          
0000164E                           879  *---------------------- END OPWORD CHECKS -----------------------------------------
0000164E                           880  
0000164E                           881  *---------------------- BEGIN CASES FOR FOUND OPCODES------------------------------
0000164E                           882  
0000164E                           883  *-----------------------MOVE-related Subroutines------------------------------------
0000164E                           884  
0000164E                           885  *-----------------------Cases for finding different MOVE OPcodes------------------------------------
0000164E                           886  *MOVE.B
0000164E  13FC 0000 00002232       887  MOVE_B_FOUND            MOVE.B      #BYTE_SIZE,CURRENT_OP_SIZE
00001656  6100 FCCC                888                          BSR         DISPLAY_CURRENT_ADDRESS
0000165A  6100 0082                889                          BSR         PARSE_MOVE_DATA                           
0000165E                           890                         
0000165E  43F9 000021DD            891                          LEA         MOVE_B_MSG,A1      ; 'MOVE.B'
00001664  103C 000E                892                          MOVE.B      #14,D0
00001668  4E4F                     893                          TRAP        #15
0000166A                           894                          
0000166A  43F9 00001FD5            895                          LEA         SPACE,A1           ; ' '
00001670  103C 000E                896                          MOVE.B      #14,D0      
00001674  4E4F                     897                          TRAP        #15
00001676                           898                          
00001676  6100 0080                899                          BSR         DISPLAY_MOVE_DATA
0000167A  6000 FC76                900                          BRA         GO_TO_NEXT_OP
0000167E                           901  
0000167E                           902  *MOVE.W                        
0000167E  13FC 0001 00002232       903  MOVE_W_FOUND            MOVE.B      #WORD_SIZE,CURRENT_OP_SIZE
00001686  6100 FC9C                904                          BSR         DISPLAY_CURRENT_ADDRESS
0000168A  6100 0052                905                          BSR         PARSE_MOVE_DATA       
0000168E                           906                          
0000168E  43F9 000021E4            907                          LEA         MOVE_W_MSG,A1      ; 'MOVE.W'
00001694  103C 000E                908                          MOVE.B      #14,D0
00001698  4E4F                     909                          TRAP        #15
0000169A                           910                          
0000169A  43F9 00001FD5            911                          LEA         SPACE,A1           ; ' '
000016A0  103C 000E                912                          MOVE.B      #14,D0      
000016A4  4E4F                     913                          TRAP        #15
000016A6                           914                          
000016A6  6100 0050                915                          BSR         DISPLAY_MOVE_DATA
000016AA  6000 FC46                916                          BRA         GO_TO_NEXT_OP  
000016AE                           917  
000016AE                           918  *MOVE.L                        
000016AE  13FC 0002 00002232       919  MOVE_L_FOUND            MOVE.B      #LONG_SIZE,CURRENT_OP_SIZE
000016B6  6100 FC6C                920                          BSR         DISPLAY_CURRENT_ADDRESS
000016BA  6100 0022                921                          BSR         PARSE_MOVE_DATA       
000016BE                           922                          
000016BE  43F9 000021EB            923                          LEA         MOVE_L_MSG,A1      ; 'MOVE.L'
000016C4  103C 000E                924                          MOVE.B      #14,D0
000016C8  4E4F                     925                          TRAP        #15
000016CA                           926                          
000016CA  43F9 00001FD5            927                          LEA         SPACE,A1           ; ' '
000016D0  103C 000E                928                          MOVE.B      #14,D0      
000016D4  4E4F                     929                          TRAP        #15
000016D6                           930                          
000016D6  6100 0020                931                          BSR         DISPLAY_MOVE_DATA
000016DA  6000 FC16                932                          BRA         GO_TO_NEXT_OP 
000016DE                           933                         
000016DE                           934  *-----------------------Parse data for any-sized MOVE instruction---------------------
000016DE                           935  *Note that the size of the MOVE is stored in CURRENT_OP_SIZE.
000016DE                           936  PARSE_MOVE_DATA         ; TODO: error checking 
000016DE                           937                          ;(maybe after reading the first 4 instruction parts, but before reading additional data)
000016DE                           938                          ;IMPORTANT: remember that different MOVE error are specific to different MOVE sizes.
000016DE                           939                          ; example: MOVE.B  A0,D3 is invalid. However, MOVE.W  A0,D3 is valid.
000016DE                           940                          ;
000016DE                           941                          ; possible errors:
000016DE                           942                          ;       CURRENT_DEST_MD = CONST_IMMEDIATE_REG (immediate data cannot be a destination)
000016DE                           943                          ;       CURRENT_SRC_MD  = CONST_ADDR_REG_MD   (byte is not a valid size for this move)
000016DE                           944                          ;       CURRENT_DEST_MD = CONST_ADDR_REG_MD   (byte is not a valid size, although we should be using MOVEA at this point, not MOVE.)
000016DE                           945                          ;       TODO: figure out other possible errors.
000016DE                           946                          
000016DE                           947                          ; after we confirm that there are no errors, we know that we can safely check for additional data and display the instruction.
000016DE                           948                          
000016DE                           949                          
000016DE                           950                          ; at this point, need to read more information (parsed by EA, probably)
000016DE                           951                          ; now that we have a move instruction, we set our EA variables accordingly:
000016DE  6100 041C                952                          BSR         READ_DEST_REG      ; EA will set CURRENT_DEST_REG.
000016E2  6100 0436                953                          BSR         READ_DEST_MODE     ; EA will set CURRENT_DEST_MD.
000016E6  6100 044E                954                          BSR         READ_SOURCE_MODE   ; EA will set CURRENT_SRC_MD.
000016EA  6100 0466                955                          BSR         READ_SOURCE_REG    ; EA will set CURRENT_SRC_REG.
000016EE                           956                          
000016EE                           957                          ; need to check whether we need to read additional data before we start displaying the
000016EE                           958                          ; instruction (for instance, this is necessary for MOVE.B #10,D0).
000016EE  6100 047C                959                          BSR         READ_SOURCE_DATA   ; EA will set CURRENT_SOURCE_DATA if necessary.
000016F2  6100 04B2                960                          BSR         READ_DEST_DATA     ; EA will set CURRENT_DEST_DATA if necessary. 
000016F6  4E75                     961                          RTS         
000016F8                           962  
000016F8  6100 05EE                963  DISPLAY_MOVE_DATA       BSR         DISPLAY_SOURCE     ; Tell EA to parse and display the source. EX: (A1)   D3    #10   $1000 etc
000016FC                           964                          
000016FC  43F9 00001FD9            965                          LEA         COMMA,A1           ; ','
00001702  103C 000E                966                          MOVE.B      #14,D0      
00001706  4E4F                     967                          TRAP        #15
00001708                           968                          
00001708  6100 0614                969                          BSR         DISPLAY_DEST       ; Tell EA to parse and display the destination.
0000170C                           970                          
0000170C  43F9 00001FD2            971                          LEA         RETURN,A1          ; (return)
00001712  103C 000E                972                          MOVE.B      #14,D0
00001716  4E4F                     973                          TRAP        #15
00001718                           974  
00001718  4E75                     975                          RTS  
0000171A                           976  
0000171A                           977  *-----------------------MOVEQ-related Subroutines------------------------------------
0000171A                           978  
0000171A                           979  *-----------------------Case for finding MOVEQ------------------------------------
0000171A  13FC 0002 00002232       980  MOVEQ_FOUND             MOVE.B      #LONG_SIZE,CURRENT_OP_SIZE
00001722  6100 FC00                981                          BSR         DISPLAY_CURRENT_ADDRESS
00001726  6100 0022                982                          BSR         PARSE_MOVEQ_DATA       
0000172A                           983                          
0000172A  43F9 000021F2            984                          LEA         MOVEQ_MSG,A1      ; 'MOVEQ'
00001730  103C 000E                985                          MOVE.B      #14,D0
00001734  4E4F                     986                          TRAP        #15
00001736                           987                          
00001736  43F9 00001FD5            988                          LEA         SPACE,A1           ; ' '
0000173C  103C 000E                989                          MOVE.B      #14,D0      
00001740  4E4F                     990                          TRAP        #15
00001742                           991                          
00001742  6100 0028                992                          BSR         DISPLAY_MOVEQ_DATA
00001746  6000 FBAA                993                          BRA         GO_TO_NEXT_OP  
0000174A                           994  
0000174A                           995  PARSE_MOVEQ_DATA        ;TODO: check that 0000 000X 0000 0000 equals zero. If not, error.
0000174A                           996                          
0000174A  6100 03B0                997                          BSR         READ_DEST_REG                       ; EA will set CURRENT_DEST_REG.
0000174E  13FC 0000 00002247       998                          MOVE.B      #CONST_DATA_REG_MD,CURRENT_DEST_MD  ; data register is the only allowed destination for MOVEQ.
00001756  6100 0036                999                          BSR         READ_MOVEQ_DATA                     ; 0000 0000 XXXX XXXX will set CURRENT_SOURCE_DATA (I think.)
0000175A                          1000                          
0000175A  13FC 0007 00002245      1001                          MOVE.B      #CONST_ADDR_MISC_MD,CURRENT_SRC_MD
00001762  13FC 0004 00002246      1002                          MOVE.B      #CONST_IMMEDIATE_REG,CURRENT_SRC_REG
0000176A                          1003                          
0000176A  4E75                    1004                          RTS 
0000176C                          1005  
0000176C  6100 057A               1006  DISPLAY_MOVEQ_DATA      BSR         DISPLAY_SOURCE     ; Tell EA to parse and display the source. 
00001770                          1007                          
00001770  43F9 00001FD9           1008                          LEA         COMMA,A1           ; ','
00001776  103C 000E               1009                          MOVE.B      #14,D0      
0000177A  4E4F                    1010                          TRAP        #15
0000177C                          1011                          
0000177C  6100 05A0               1012                          BSR         DISPLAY_DEST       ; Tell EA to parse and display the destination.
00001780                          1013                          
00001780  43F9 00001FD2           1014                          LEA         RETURN,A1          ; (return)
00001786  103C 000E               1015                          MOVE.B      #14,D0
0000178A  4E4F                    1016                          TRAP        #15
0000178C                          1017  
0000178C  4E75                    1018                          RTS        
0000178E                          1019  
0000178E                          1020  ;NOTE: this SR is stored here and not in EA because it is specific to MOVEQ.
0000178E  4244                    1021  READ_MOVEQ_DATA         CLR         D4
00001790  4279 0000224E           1022                          CLR         CURRENT_SRC_DATA
00001796  3839 00002230           1023                          MOVE.W      CURRENT_WORD,D4
0000179C  0244 00FF               1024                          ANDI.W      #FILT_MOVEQ_DATA,D4        ; turn D4 into 0000 0000 XXXX XXXX (no shift necessary)
000017A0  33C4 0000224E           1025                          MOVE.W      D4,CURRENT_SRC_DATA
000017A6  4E75                    1026                          RTS
000017A8                          1027                      
000017A8                          1028    ; TODO: (in order)
000017A8                          1029      *   -MOVEM  (W,L)
000017A8                          1030      *   -ADD    (B,W,L) (will need shahin's size filter for this and below)
000017A8                          1031      *   -ADDA   (W,L)
000017A8                          1032      *   -ADDI   (B,W,L)
000017A8                          1033      *   -SUB    (B,W,L)
000017A8                          1034    ; see comment block at the top of the program for the full list of codes.
000017A8                          1035    ; see huge comment block at the top of OPcode section for tentative OPcode parsing implementation plan.
000017A8                          1036    
000017A8                          1037  *-----------------------EXT-related Subroutines------------------------------------
000017A8  4EF8 1004               1038  EXT_FOUND               JMP         STOP ;TODO: case for EXT found
000017AC                          1039  
000017AC                          1040  ;TODO: first thing: read the correct size for MOVEM
000017AC                          1041  *-----------------------MOVEM-related Subroutines------------------------------------
000017AC  6100 FB76               1042  MOVEM_FOUND             BSR         DISPLAY_CURRENT_ADDRESS
000017B0  4244                    1043                          CLR         D4
000017B2  3839 00002230           1044                          MOVE.W      CURRENT_WORD,D4
000017B8  0244 0040               1045                          ANDI.W      #FILT_MOVEM_SIZE,D4 ; 0000 0000 0X00 0000 filter out size and set CURRENT_OP_SIZE accordingly
000017BC  EC4C                    1046                          LSR.W       #6,D4               ; 0000 0000 0000 000X
000017BE  B87C 0000               1047                          CMP         #WORD_SIZE_MOVEM,D4
000017C2  6700 0006               1048                          BEQ         MOVEM_W_FOUND
000017C6  6000 002E               1049                          BRA         MOVEM_L_FOUND
000017CA                          1050      
000017CA  13FC 0001 00002232      1051  MOVEM_W_FOUND           MOVE.B      #WORD_SIZE,CURRENT_OP_SIZE
000017D2  6100 004E               1052                          BSR         PARSE_MOVEM_DATA
000017D6                          1053  
000017D6  43F9 000021F8           1054                          LEA         MOVEM_W_MSG,A1      ; 'MOVEM.W'
000017DC  103C 000E               1055                          MOVE.B      #14,D0
000017E0  4E4F                    1056                          TRAP        #15
000017E2                          1057                          
000017E2  43F9 00001FD5           1058                          LEA         SPACE,A1           ; ' '
000017E8  103C 000E               1059                          MOVE.B      #14,D0      
000017EC  4E4F                    1060                          TRAP        #15  
000017EE                          1061                          
000017EE  6100 00C4               1062                          BSR         DISPLAY_MOVEM_DATA
000017F2  6000 FAFE               1063                          BRA         GO_TO_NEXT_OP                               
000017F6                          1064  
000017F6  13FC 0002 00002232      1065  MOVEM_L_FOUND           MOVE.B      #LONG_SIZE,CURRENT_OP_SIZE
000017FE  6100 0022               1066                          BSR         PARSE_MOVEM_DATA   ; parse MOVEM data for direction, EA, etc
00001802                          1067  
00001802  43F9 00002200           1068                          LEA         MOVEM_L_MSG,A1      ; 'MOVEM.L'
00001808  103C 000E               1069                          MOVE.B      #14,D0
0000180C  4E4F                    1070                          TRAP        #15
0000180E                          1071                          
0000180E  43F9 00001FD5           1072                          LEA         SPACE,A1           ; ' '
00001814  103C 000E               1073                          MOVE.B      #14,D0      
00001818  4E4F                    1074                          TRAP        #15 
0000181A                          1075                          
0000181A  6100 0098               1076                          BSR         DISPLAY_MOVEM_DATA
0000181E  6000 FAD2               1077                          BRA         GO_TO_NEXT_OP 
00001822                          1078                          
00001822  6100 032E               1079  PARSE_MOVEM_DATA        BSR         READ_SOURCE_REG                 ; EA will set CURRENT_SRC_REG.
00001826  6100 030E               1080                          BSR         READ_SOURCE_MODE                ; EA will set CURRENT_SRC_MD.
0000182A  6100 0026               1081                          BSR         READ_MOVEM_DIR                  ; read and store the direction of the current operation.
0000182E  13F9 00002246 00002241  1082                          MOVE.B      CURRENT_SRC_REG,CURRENT_EA_REG  ; our current EA reg comes from  0000 0000 0000 0XXX.
00001838  13F9 00002245 00002240  1083                          MOVE.B      CURRENT_SRC_MD,CURRENT_EA_MD    ; our current EA mode comes from 0000 0000 00XX X000.
00001842                          1084                          
00001842                          1085                          ; TODO: add any other parsing methods that should be true for both directions (and precede error checking) here.
00001842                          1086                          ; TODO: error cases to add here:
00001842                          1087                          ; TODO: error case for CURRENT_EA_MD = CONST_DATA_REG_MD: Dn
00001842                          1088                          ; TODO: error case for CURRENT_EA_MD = CONST_ADDR_REG_MD: An
00001842                          1089                          ; TODO: error case for CURRENT_EA_MD = CONST_ADDR_MISC_MD *and* CURRENT_EA_REG = CONST_IMMEDIATE REG: #<data>
00001842                          1090                          ; (note that these are not all error cases for MOVEM, but they are the only ones we are able to check in this subroutine.)
00001842                          1091                          
00001842  0C39 0000 00002242      1092                          CMP.B       #CONST_MOVEM_DIR_0,CURRENT_DIRECTION
0000184A  6700 001E               1093                          BEQ         PARSE_MOVEM_DIR_0
0000184E  6000 0038               1094                          BRA         PARSE_MOVEM_DIR_1
00001852                          1095                          
00001852  4244                    1096  READ_MOVEM_DIR          CLR         D4
00001854  3839 00002230           1097                          MOVE.W      CURRENT_WORD,D4    
0000185A  0244 0400               1098                          ANDI.W      #FILT_MOVEM_DIR,D4 ; 0000 0X00 0000 0000     filter out direction 
0000185E  E04C                    1099                          LSR.W       #8,D4              ; 0000 0000 0000 000X
00001860  E44C                    1100                          LSR.W       #2,D4
00001862  13C4 00002242           1101                          MOVE.B      D4,CURRENT_DIRECTION
00001868  4E75                    1102                          RTS
0000186A                          1103                          
0000186A                          1104  PARSE_MOVEM_DIR_0       ;TODO : error case for  (An+): CURRENT_EA_MD = CONST_ADDR_INCR_MD
0000186A  13F9 00002240 0000223A  1105                          MOVE.B      CURRENT_EA_MD,CURRENT_R_MD      ; put EA on the right.
00001874  13F9 00002241 0000223B  1106                          MOVE.B      CURRENT_EA_REG,CURRENT_R_REG
0000187E                          1107                          ; by this point, we have done all necessary error checking, and we are ready to read the
0000187E                          1108                          ; next word of additional data.
0000187E  6100 0026               1109                          BSR         PARSE_MOVEM_MASK_FIELD
00001882  6100 0396               1110                          BSR         READ_RIGHT_DATA
00001886                          1111                          ; ...
00001886  4E75                    1112                          RTS
00001888                          1113  
00001888                          1114  PARSE_MOVEM_DIR_1       ;TODO : error case for  (-An): CURRENT_EA_MD = CONST_ADDR_DECR_MD
00001888  13F9 00002240 00002233  1115                          MOVE.B      CURRENT_EA_MD,CURRENT_L_MD      ; put EA on the left.
00001892  13F9 00002241 00002234  1116                          MOVE.B      CURRENT_EA_REG,CURRENT_L_REG
0000189C                          1117                          ; by this point, we have done all necessary error checking, and we are ready to read the
0000189C                          1118                          ; next word of additional data.
0000189C  6100 0008               1119                          BSR         PARSE_MOVEM_MASK_FIELD
000018A0  6100 033E               1120                          BSR         READ_LEFT_DATA
000018A4                          1121                          
000018A4  4E75                    1122                          RTS
000018A6                          1123                        
000018A6                          1124      *Parse the mask field, which will tell us which address/data registers we are moving to/from.
000018A6  4279 00002256           1125  PARSE_MOVEM_MASK_FIELD  CLR.W       CURRENT_MASK_FIELD
000018AC  33DD 00002256           1126                          MOVE.W      (A5)+,CURRENT_MASK_FIELD
000018B2                          1127                          ;TODO: if CURRENT_EA_MD = CONST_ADDR_DECR_MD, reverse the way we read the next word of additional data.
000018B2  4E75                    1128                          RTS
000018B4                          1129    
000018B4  0C39 0000 00002242      1130  DISPLAY_MOVEM_DATA      CMP.B       #CONST_MOVEM_DIR_0,CURRENT_DIRECTION
000018BC  6700 0006               1131                          BEQ         DISPLAY_MOVEM_DIR_0
000018C0  6000 0024               1132                          BRA         DISPLAY_MOVEM_DIR_1
000018C4                          1133                          
000018C4  6100 0042               1134  DISPLAY_MOVEM_DIR_0     BSR         DISPLAY_MOVEM_LIST ; display list, then ea.
000018C8                          1135                          
000018C8  43F9 00001FD9           1136                          LEA         COMMA,A1           ; ','
000018CE  103C 000E               1137                          MOVE.B      #14,D0      
000018D2  4E4F                    1138                          TRAP        #15
000018D4                          1139                          
000018D4  6100 04B4               1140                          BSR         DISPLAY_RIGHT
000018D8                          1141                          
000018D8  43F9 00001FD2           1142                          LEA         RETURN,A1          ; (return)
000018DE  103C 000E               1143                          MOVE.B      #14,D0
000018E2  4E4F                    1144                          TRAP        #15
000018E4                          1145                          
000018E4  4E75                    1146                          RTS
000018E6                          1147  
000018E6  6100 046C               1148  DISPLAY_MOVEM_DIR_1     BSR         DISPLAY_LEFT        ; display ea, then list.
000018EA                          1149                          
000018EA  43F9 00001FD9           1150                          LEA         COMMA,A1            ; ','
000018F0  103C 000E               1151                          MOVE.B      #14,D0      
000018F4  4E4F                    1152                          TRAP        #15
000018F6                          1153                         
000018F6  6100 0010               1154                          BSR         DISPLAY_MOVEM_LIST
000018FA                          1155                          
000018FA  43F9 00001FD2           1156                          LEA         RETURN,A1          ; (return)
00001900  103C 000E               1157                          MOVE.B      #14,D0
00001904  4E4F                    1158                          TRAP        #15
00001906                          1159   
00001906  4E75                    1160                          RTS
00001908                          1161                          
00001908  0C39 0004 00002240      1162  DISPLAY_MOVEM_LIST      CMP.B       #CONST_ADDR_DECR_MD,CURRENT_EA_MD
00001910  6700 0010               1163                          BEQ         DISPLAY_MOVEM_LIST_REV
00001914  6000 0002               1164                          BRA         DISPLAY_MOVEM_LIST_FWD
00001918                          1165  
00001918                          1166      * display and start from the right
00001918                          1167      * MOVEM list is displayed as Ai-Aj/Dx-Dy
00001918  4243                    1168  DISPLAY_MOVEM_LIST_FWD  CLR         D3 ; D3 is a flag which tells us if we find any address registers in the list.
0000191A  4244                    1169                          CLR         D4 ; D4 is a temp value for our mask field.
0000191C  4245                    1170                          CLR         D5 ; D5 will serve as our index counter.
0000191E  6000 0078               1171                          BRA         FIND_MM_START_A
00001922                          1172                          
00001922                          1173      * display and start from the left
00001922                          1174      * MOVEM list is displayed as Ai-Aj/Dx-Dy                        
00001922  4243                    1175  DISPLAY_MOVEM_LIST_REV  CLR         D3 ; D3 is a flag which tells us if we find any address registers in the list.
00001924  4244                    1176                          CLR         D4 ; D4 is a temp value for our mask field.
00001926  4245                    1177                          CLR         D5 ; D5 will serve as our index counter.
00001928  6100 0006               1178                          BSR         REVERSE_MASK_FIELD
0000192C  6000 006A               1179                          BRA         FIND_MM_START_A
00001930                          1180  
00001930                          1181      * reverse the mask field if EA mode is -(An).
00001930  4240                    1182  REVERSE_MASK_FIELD      CLR         D0
00001932  4241                    1183                          CLR         D1                          ; D1 will receive new value
00001934  4242                    1184                          CLR         D2
00001936  3439 00002256           1185                          MOVE.W      CURRENT_MASK_FIELD,D2
0000193C  303C 0010               1186                          MOVE        #16,D0                      ; Use D0 as counter
00001940  6100 000A               1187                          BSR         REVERSE_MASK_FIELD_LOOP
00001944  33C2 00002256           1188                          MOVE.W      D2,CURRENT_MASK_FIELD
0000194A  4E75                    1189                          RTS
0000194C                          1190                          
0000194C  E34A                    1191  REVERSE_MASK_FIELD_LOOP LSL         #1,D2                       ; Shift MSB of D2 into X bit
0000194E  E251                    1192                          ROXR        #1,D1                       ; Shift X bit into MSB of D1
00001950  5340                    1193                          SUB         #1,D0                       ; count down
00001952  B07C 0000               1194                          CMP         #0,D0
00001956  6EF4                    1195                          BGT         REVERSE_MASK_FIELD_LOOP     ; Repeat until D0 reaches -1
00001958  3401                    1196                          MOVE        D1,D2                       ; Put new value back in D2
0000195A  4E75                    1197                          RTS
0000195C                          1198   
0000195C                          1199       * after finding start A, see if we only had one address register in the list.
0000195C  4246                    1200  CHECK_SINGLE_A          CLR         D6                       ; we use D6 as a temporary register (only in this method) to examine the value 1 higher than D5.
0000195E  1C05                    1201                          MOVE.B      D5,D6                
00001960  5206                    1202                          ADD.B       #1,D6
00001962  BC7C 000F               1203                          CMP         #15,D6                   ; first, check if D5 is 15 or greater. (meaning D6 is 16 or greater.) If it is, there is no room for an end A.
00001966  6E00 0066               1204                          BGT         FIND_MM_START_D          ; This means we move on and look for start D.
0000196A  0D04                    1205                          BTST        D6,D4                    ; otherwise, we have to compare the 1-greater value to our mask field.
0000196C  6700 0060               1206                          BEQ         FIND_MM_START_D          ; If the next value is 0, there is no end An.
00001970  6000 0048               1207                          BRA         FIND_MM_END_A            ; final possibility: there are more address registers and we must find the end An.
00001974                          1208                          
00001974                          1209       * After finding start D, see if we only had one data register in the list.
00001974  4246                    1210  CHECK_SINGLE_D          CLR         D6                       ; we use D6 as a temporary register (only in this method) to examine the value 1 higher than D5.
00001976  1C05                    1211                          MOVE.B      D5,D6                
00001978  5206                    1212                          ADD.B       #1,D6
0000197A  BC7C 0007               1213                          CMP         #7,D6                    ; first, check if D5 is 7 or greater. (meaning D6 is 8 or greater.) If it is, there is no room for an end D.
0000197E  6E00 012E               1214                          BGT         MOVEM_LIST_DISPLAY_DONE  ; This means we are done displaying the list.
00001982  0D04                    1215                          BTST        D6,D4                    ; otherwise, we have to compare the 1-greater value to our mask field.
00001984  6700 0128               1216                          BEQ         MOVEM_LIST_DISPLAY_DONE  ; If the next value is 0, there is no end An.
00001988  6000 0066               1217                          BRA         FIND_MM_END_D            ; final possibility: there are more data registers and we must find the end Dn.
0000198C                          1218                          
0000198C                          1219       * after finding startD, check to see if we should print a '/' before displaying it.
0000198C  B67C 0001               1220  CHECK_ADDR_IN_LIST_FLAG CMP         #1,D3
00001990  6700 00C6               1221                          BEQ         DISPLAY_SLASH
00001994  6000 00D2               1222                          BRA         DISP_MM_START_D
00001998                          1223                          
00001998                          1224       *find the starting address register in the list .                       
00001998  4245                    1225  FIND_MM_START_A         CLR         D5
0000199A  1A3C 0008               1226                          MOVE.B      #8,D5   ;start looking for start A at the 8th bit.           
0000199E  3839 00002256           1227                          MOVE.W      CURRENT_MASK_FIELD,D4  
000019A4  6000 0002               1228                          BRA         FIND_MM_START_A_LOOP 
000019A8                          1229  
000019A8  0B04                    1230  FIND_MM_START_A_LOOP    BTST.L      D5,D4
000019AA  6600 005A               1231                          BNE         DISP_MM_START_A  
000019AE  5205                    1232                          ADD.B       #1,D5
000019B0  BA7C 0010               1233                          CMP         #16,D5   
000019B4  6DF2                    1234                          BLT         FIND_MM_START_A_LOOP
000019B6  6000 0016               1235                          BRA         FIND_MM_START_D        ; stop searching for start A once we reach 16.  
000019BA                          1236  
000019BA                          1237       *find the ending address register in the list. (start is found.)
000019BA  6000 0002               1238  FIND_MM_END_A           BRA         FIND_MM_END_A_LOOP
000019BE                          1239                          
000019BE                          1240       * if we get to this loop, we know for sure that we will need to display an end An at some point, and also that we have a start An.
000019BE  0B04                    1241  FIND_MM_END_A_LOOP      BTST.L      D5,D4
000019C0  6700 0066               1242                          BEQ         DISP_MM_END_A            ; BEQ instead of BNE, since we are looking for the next 0 to tell us our end An. 
000019C4  5205                    1243                          ADD.B       #1,D5                    ; (it will be 9 below the index where we find the 0.)
000019C6  BA7C 0010               1244                          CMP         #16,D5   
000019CA  6DF2                    1245                          BLT         FIND_MM_END_A_LOOP
000019CC  60EC                    1246                          BRA         FIND_MM_END_A            ; stop searching for end A once we reach 15.  
000019CE                          1247                       
000019CE                          1248       *find the starting data register in the list.                        
000019CE  4244                    1249  FIND_MM_START_D         CLR         D4                       ; do not clear D3, since it is a flag we will use if we find any Dn.     
000019D0  4245                    1250                          CLR         D5 
000019D2  1A3C 0000               1251                          MOVE.B      #0,D5                    ; start looking for start D at index 0.
000019D6  3839 00002256           1252                          MOVE.W      CURRENT_MASK_FIELD,D4
000019DC  6000 0002               1253                          BRA         FIND_MM_START_D_LOOP
000019E0                          1254                          
000019E0  0B04                    1255  FIND_MM_START_D_LOOP    BTST.L      D5,D4
000019E2  66A8                    1256                          BNE         CHECK_ADDR_IN_LIST_FLAG  ; if we find the start D, check to see whether we need a '/', then display the start D. 
000019E4  5205                    1257                          ADD.B       #1,D5
000019E6  BA7C 0008               1258                          CMP         #8,D5   
000019EA  6DF4                    1259                          BLT         FIND_MM_START_D_LOOP
000019EC  6000 00C0               1260                          BRA         MOVEM_LIST_DISPLAY_DONE  ; stop searching for start D once we reach 8. 
000019F0                          1261                          
000019F0                          1262       *find the ending data register in the list. (start is found.)
000019F0  6000 0002               1263  FIND_MM_END_D           BRA         FIND_MM_END_D_LOOP
000019F4                          1264  
000019F4                          1265       * if we get to this loop, we know for sure that we will need to display an end Dn at some point, and also that we have a start Dn.
000019F4  0B04                    1266  FIND_MM_END_D_LOOP      BTST.L      D5,D4
000019F6  6700 008C               1267                          BEQ         DISP_MM_END_D            ; BEQ instead of BNE, since we are looking for the next 0 to tell us our end Dn. 
000019FA  5205                    1268                          ADD.B       #1,D5                    ; (it will be 1 below the index where we find the 0.)
000019FC  BA7C 0008               1269                          CMP         #8,D5   
00001A00  6DF2                    1270                          BLT         FIND_MM_END_D_LOOP
00001A02  6000 0080               1271                          BRA         DISP_MM_END_D            ; stop searching for end D once we reach 8. 
00001A06                          1272                          
00001A06                          1273       *display the starting address register in the list.
00001A06  43F9 0000220A           1274  DISP_MM_START_A         LEA         MSG_A,A1          ; 'A'
00001A0C  103C 000E               1275                          MOVE.B      #14,D0      
00001A10  4E4F                    1276                          TRAP        #15
00001A12                          1277                          
00001A12  2205                    1278                          MOVE.L      D5,D1             ; print out the number of the starting address register in the list
00001A14  5141                    1279                          SUBQ        #8,D1             ; note that we have to subtract 8 because the index is 8 higher than the address register value.
00001A16  143C 0010               1280                          MOVE.B      #16,D2
00001A1A  103C 000F               1281                          MOVE.B      #15,D0
00001A1E  4E4F                    1282                          TRAP        #15
00001A20                          1283                          
00001A20  163C 0001               1284                          MOVE.B      #1,D3             ; D3 is flagged as 1, telling us we will need a / if we find any data registers.
00001A24                          1285                          
00001A24  6000 FF36               1286                          BRA         CHECK_SINGLE_A    ; see if we only had one A.
00001A28                          1287  
00001A28                          1288       *display the ending address register in the list.                        
00001A28  43F9 00001FE3           1289  DISP_MM_END_A           LEA         MINUS,A1        ; '-'
00001A2E  103C 000E               1290                          MOVE.B      #14,D0      
00001A32  4E4F                    1291                          TRAP        #15
00001A34                          1292  
00001A34  43F9 0000220A           1293                          LEA         MSG_A,A1        ; 'A'
00001A3A  103C 000E               1294                          MOVE.B      #14,D0      
00001A3E  4E4F                    1295                          TRAP        #15
00001A40                          1296                          
00001A40  2205                    1297                          MOVE.L      D5,D1           ; print out the number of the ending address register in the list
00001A42  5141                    1298                          SUBQ        #8,D1           ; since we are looking for the 'last 1', we subtract 9, since we found a 0 at the index in question.
00001A44  5341                    1299                          SUBQ        #1,D1
00001A46  143C 0010               1300                          MOVE.B      #16,D2
00001A4A  103C 000F               1301                          MOVE.B      #15,D0
00001A4E  4E4F                    1302                          TRAP        #15
00001A50                          1303                          
00001A50                          1304                          ;No need to change D5, since it will be reset at the start of the next loop anyway.
00001A50  163C 0001               1305                          MOVE.B      #1,D3           ; D3 is flagged as 1, telling us we will need a / if we find any data registers.
00001A54                          1306  
00001A54  6000 FF78               1307                          BRA         FIND_MM_START_D
00001A58                          1308                          
00001A58                          1309     * display a '/'. (not always necessecary.)
00001A58  43F9 00001FE5           1310  DISPLAY_SLASH           LEA         SLASH,A1          ; '/'
00001A5E  103C 000E               1311                          MOVE.B      #14,D0      
00001A62  4E4F                    1312                          TRAP        #15
00001A64                          1313  
00001A64  6000 0002               1314                          BRA         DISP_MM_START_D  
00001A68                          1315                          
00001A68                          1316     * display the starting data register in the list.
00001A68  43F9 00002208           1317  DISP_MM_START_D         LEA         MSG_D,A1          ; 'D'
00001A6E  103C 000E               1318                          MOVE.B      #14,D0      
00001A72  4E4F                    1319                          TRAP        #15
00001A74                          1320                          
00001A74  2205                    1321                          MOVE.L      D5,D1             ; print out the number of the starting data register in the list
00001A76  143C 0010               1322                          MOVE.B      #16,D2
00001A7A  103C 000F               1323                          MOVE.B      #15,D0
00001A7E  4E4F                    1324                          TRAP        #15
00001A80                          1325                          
00001A80  6000 FEF2               1326                          BRA         CHECK_SINGLE_D    ; see if we only had one Dn.
00001A84                          1327                          
00001A84                          1328     * display the ending data register in the list.
00001A84  43F9 00001FE3           1329  DISP_MM_END_D           LEA         MINUS,A1          ; '-'
00001A8A  103C 000E               1330                          MOVE.B      #14,D0      
00001A8E  4E4F                    1331                          TRAP        #15
00001A90                          1332  
00001A90  43F9 00002208           1333                          LEA         MSG_D,A1          ; 'D'
00001A96  103C 000E               1334                          MOVE.B      #14,D0      
00001A9A  4E4F                    1335                          TRAP        #15
00001A9C                          1336                          
00001A9C  2205                    1337                          MOVE.L      D5,D1             ; print out the number of the ending data register in the list
00001A9E  5341                    1338                          SUBQ        #1,D1             ; since we are looking for the 'last 1', we subtract 1, since we found a 0 at the index in question.
00001AA0                          1339  
00001AA0  143C 0010               1340                          MOVE.B      #16,D2
00001AA4  103C 000F               1341                          MOVE.B      #15,D0
00001AA8  4E4F                    1342                          TRAP        #15
00001AAA                          1343                          
00001AAA  6000 0002               1344                          BRA         MOVEM_LIST_DISPLAY_DONE
00001AAE                          1345                          
00001AAE  4E75                    1346  MOVEM_LIST_DISPLAY_DONE RTS ;not sure if this is right, but can't test it at the moment.
00001AB0                          1347   
00001AB0                          1348  *-----------------------ORI-related Subroutines------------------------------------
00001AB0  4EF8 1004               1349  ORI_FOUND               JMP         STOP ;TODO: case for ORI found
00001AB4                          1350  
00001AB4                          1351   *----------------------ANDI-related Subroutines------------------------------------
00001AB4  4EF8 1004               1352  ANDI_FOUND              JMP         STOP ;TODO: case for ANDI found
00001AB8                          1353  
00001AB8                          1354   *----------------------SUBI-related Subroutines------------------------------------
00001AB8  4EF8 1004               1355  SUBI_FOUND              JMP         STOP ;TODO: case for SUBI found
00001ABC                          1356  
00001ABC                          1357   *----------------------ADDI-related Subroutines------------------------------------
00001ABC  4EF8 1004               1358  ADDI_FOUND              JMP         STOP ;TODO: case for ADDI found
00001AC0                          1359   
00001AC0                          1360  *-----------------------EORI-related Subroutines------------------------------------
00001AC0  4EF8 1004               1361  EORI_FOUND              JMP         STOP ;TODO: case for EORI found
00001AC4                          1362   
00001AC4                          1363  *-----------------------CMPI-related Subroutines------------------------------------
00001AC4  4EF8 1004               1364  CMPI_FOUND              JMP         STOP ;TODO: case for CMPI found
00001AC8                          1365  
00001AC8                          1366  *-----------------------NEGX-related Subroutines------------------------------------
00001AC8  4EF8 1004               1367  NEGX_FOUND              JMP         STOP ;TODO: case for NEGX found 
00001ACC                          1368  
00001ACC                          1369  *-----------------------CLR-related Subroutines------------------------------------
00001ACC  4EF8 1004               1370  CLR_FOUND               JMP         STOP ;TODO: case for CLR found 
00001AD0                          1371  
00001AD0                          1372  *-----------------------NEG-related Subroutines------------------------------------
00001AD0  4EF8 1004               1373  NEG_FOUND               JMP         STOP ;TODO: case for NEG found 
00001AD4                          1374  
00001AD4                          1375  *-----------------------NOT-related Subroutines------------------------------------
00001AD4  4EF8 1004               1376  NOT_FOUND               JMP         STOP ;TODO: case for NOT found 
00001AD8                          1377  
00001AD8                          1378  *-----------------------ADD-related Subroutines------------------------------------
00001AD8                          1379  ADD_FOUND               ; TODO: case for ADD (next goal). Note that the program can definitely parse ADD instructions and get to this point.
00001AD8                          1380                          ; start by reading the size and direction.
00001AD8                          1381                          ; then, read destination register part of word and store it in left or right depending on direction.
00001AD8                          1382                          ; note ADD always uses a data register as one of its operands, 
00001AD8                          1383                          ; and the register number is always stored in destination register part of the word.
00001AD8  6100 F84A               1384                          BSR         DISPLAY_CURRENT_ADDRESS
00001ADC  4244                    1385                          CLR         D4
00001ADE  3839 00002230           1386                          MOVE.W      CURRENT_WORD,D4
00001AE4                          1387                              ;TODO: use the correct filter, LSR, and comparison constant.
00001AE4                          1388                          ;ANDI.W      #FILT_MOVEM_SIZE,D4 ; 0000 0000 0X00 0000 filter out size and set CURRENT_OP_SIZE accordingly
00001AE4                          1389                          ;LSR.W       #6,D4               ; 0000 0000 0000 000X
00001AE4                          1390                          ;CMP         #WORD_SIZE_MOVEM,D4
00001AE4                          1391                          ;BEQ         ADD_W_FOUND
00001AE4                          1392                          ;BRA         MOVEM_L_FOUND
00001AE4  4EF8 1004               1393                          JMP         STOP
00001AE8                          1394                          
00001AE8                          1395  ADD_B_FOUND             ;TODO 
00001AE8  4EF8 1004               1396                          JMP         STOP 
00001AEC                          1397                          
00001AEC                          1398  ADD_W_FOUND             ;TODO 
00001AEC  4EF8 1004               1399                          JMP         STOP   
00001AF0                          1400  
00001AF0                          1401  ADD_L_FOUND             ;TODO 
00001AF0  4EF8 1004               1402                          JMP         STOP                       
00001AF4                          1403  
00001AF4                          1404  *-----------------------ADDX-related Subroutines------------------------------------
00001AF4  4EF8 1004               1405  ADDX_FOUND              JMP         STOP ;TODO: case for ADDX
00001AF8                          1406  
00001AF8                          1407  *-----------------------ADDA-related Subroutines------------------------------------
00001AF8  4EF8 1004               1408  ADDA_FOUND              JMP         STOP ;TODO: case for ADDA
00001AFC                          1409                      
00001AFC                          1410  *###################### END OPCODE ##################################
00001AFC                          1411  *###################### BEGIN EA ##################################
00001AFC                          1412  *** EA Subroutines are kept here ***
00001AFC                          1413  *----------------------Check the destination register of the current word.-------------
00001AFC  4244                    1414  READ_DEST_REG           CLR         D4
00001AFE  4239 00002248           1415                          CLR.B       CURRENT_DEST_REG
00001B04  3839 00002230           1416                          MOVE.W      CURRENT_WORD,D4
00001B0A  0244 0E00               1417                          ANDI.W      #FILT_DEST_REG,D4       ; turn D4 into 0000 XXX0 0000 0000
00001B0E  E04C                    1418                          LSR.W       #8,D4                   ; turn D4 into 0000 0000 0000 0XXX
00001B10  E24C                    1419                          LSR.W       #1,D4                   ; 9 would be invalid, so we shift 8, then 1
00001B12  13C4 00002248           1420                          MOVE.B      D4,CURRENT_DEST_REG
00001B18  4E75                    1421                          RTS
00001B1A                          1422  
00001B1A                          1423  *----------------------Check the destination mode of the current word.-------------
00001B1A                          1424  *(assuming the destination is where it would be in MOVE).
00001B1A  4244                    1425  READ_DEST_MODE          CLR         D4
00001B1C  4239 00002247           1426                          CLR.B       CURRENT_DEST_MD
00001B22  3839 00002230           1427                          MOVE.W      CURRENT_WORD,D4
00001B28  0244 01C0               1428                          ANDI.W      #FILT_DEST_MD,D4        ; turn D4 into 0000 000X XX00 0000
00001B2C  EC4C                    1429                          LSR.W       #6,D4                   ; turn D4 into 0000 0000 0000 0XXX
00001B2E  13C4 00002247           1430                          MOVE.B      D4,CURRENT_DEST_MD
00001B34  4E75                    1431                          RTS
00001B36                          1432  
00001B36                          1433  ;By this point, CURRENT WORD holds the first 16 bits of an instruction we are looking at.
00001B36                          1434  ;(we should already know the OPcode by this point, so this will be called by various OPcode subroutines.)
00001B36                          1435  *---------------------- Check the source mode of the current word.--------------------
00001B36                          1436  *(assuming the source is where it would be in MOVE).
00001B36  4244                    1437  READ_SOURCE_MODE        CLR         D4
00001B38  4239 00002245           1438                          CLR.B       CURRENT_SRC_MD
00001B3E  3839 00002230           1439                          MOVE.W      CURRENT_WORD,D4
00001B44  0244 0038               1440                          ANDI.W      #FILT_SRC_MD,D4                 ; turn source mode into 0000 0000 00XX X000
00001B48  E64C                    1441                          LSR.W       #3,D4                           ; turn source mode into 0000 0000 0000 0XXX
00001B4A  13C4 00002245           1442                          MOVE.B      D4,CURRENT_SRC_MD
00001B50  4E75                    1443                          RTS
00001B52                          1444                          
00001B52                          1445  *----------------------Check the source register of the current word.-----------------
00001B52  4244                    1446  READ_SOURCE_REG         CLR         D4
00001B54  4239 00002246           1447                          CLR.B       CURRENT_SRC_REG
00001B5A  3839 00002230           1448                          MOVE.W      CURRENT_WORD,D4
00001B60  0244 0007               1449                          ANDI.W      #FILT_SRC_REG,D4                ; turn D4 into 0000 0000 0000 0XXX. (no need for LSR in this case.)
00001B64  13C4 00002246           1450                          MOVE.B      D4,CURRENT_SRC_REG
00001B6A  4E75                    1451                          RTS
00001B6C                          1452  *--------TODO: READ_OP_SIZE---------
00001B6C                          1453                         
00001B6C                          1454  *----------------------Read additional source data associated with the current word (if necessary).----------------- 
00001B6C                          1455  *This needs to postincrement A5 as necessary for each case.
00001B6C  4279 0000224E           1456  READ_SOURCE_DATA        CLR         CURRENT_SRC_DATA
00001B72  4279 0000224A           1457                          CLR         CURRENT_DATA
00001B78  0C39 0007 00002245      1458                          CMP.B       #CONST_ADDR_MISC_MD,CURRENT_SRC_MD ; check the source mode
00001B80  6700 0004               1459                          BEQ         CONFIRM_READ_SRC_DATA              ; see if we have a source mode that requires additional data.               
00001B84  4E75                    1460                          RTS
00001B86                          1461                          
00001B86  4239 00002244           1462  CONFIRM_READ_SRC_DATA   CLR.B       CURRENT_REG
00001B8C  13F9 00002246 00002244  1463                          MOVE.B      CURRENT_SRC_REG,CURRENT_REG
00001B96  6100 00BC               1464                          BSR         CONFIRM_READ_DATA
00001B9A  23F9 0000224A 0000224E  1465                          MOVE.L      CURRENT_DATA,CURRENT_SRC_DATA
00001BA4  4E75                    1466                          RTS
00001BA6                          1467   
00001BA6                          1468  *----------------------Read additional destination data associated with the current word (if necessary).----------------- 
00001BA6                          1469  *This needs to postincrement A5 as necessary.                       
00001BA6  4279 00002252           1470  READ_DEST_DATA          CLR         CURRENT_DEST_DATA
00001BAC  4279 0000224A           1471                          CLR         CURRENT_DATA
00001BB2  0C39 0007 00002247      1472                          CMP.B       #CONST_ADDR_MISC_MD,CURRENT_DEST_MD  ; check the destination mode.
00001BBA  6700 0004               1473                          BEQ         CONFIRM_READ_DEST_DATA               ; see if we have a destination mode that requires additional data.                  
00001BBE  4E75                    1474                          RTS
00001BC0                          1475                                              
00001BC0  4239 00002244           1476  CONFIRM_READ_DEST_DATA  CLR.B       CURRENT_REG
00001BC6  13F9 00002248 00002244  1477                          MOVE.B      CURRENT_DEST_REG,CURRENT_REG
00001BD0  6100 0082               1478                          BSR         CONFIRM_READ_DATA
00001BD4  23F9 0000224A 00002252  1479                          MOVE.L      CURRENT_DATA,CURRENT_DEST_DATA
00001BDE  4E75                    1480                          RTS
00001BE0                          1481  
00001BE0                          1482  *-----------------------Read additional data in ways that are direction-oriented.--------------------------------------
00001BE0                          1483  
00001BE0                          1484      *Left
00001BE0  4279 00002236           1485  READ_LEFT_DATA          CLR         CURRENT_L_DATA
00001BE6  4279 0000224A           1486                          CLR         CURRENT_DATA
00001BEC  0C39 0007 00002233      1487                          CMP.B       #CONST_ADDR_MISC_MD,CURRENT_L_MD     ; check the left mode.
00001BF4  6700 0004               1488                          BEQ         CONFIRM_READ_LEFT_DATA               ; see if we have a mode that requires additional data.                  
00001BF8  4E75                    1489                          RTS
00001BFA                          1490                                              
00001BFA  4239 00002244           1491  CONFIRM_READ_LEFT_DATA  CLR.B       CURRENT_REG
00001C00  13F9 00002234 00002244  1492                          MOVE.B      CURRENT_L_REG,CURRENT_REG
00001C0A  6100 0048               1493                          BSR         CONFIRM_READ_DATA
00001C0E  23F9 0000224A 00002236  1494                          MOVE.L      CURRENT_DATA,CURRENT_L_DATA
00001C18  4E75                    1495                          RTS
00001C1A                          1496                          
00001C1A                          1497      *Right
00001C1A  4279 0000223C           1498  READ_RIGHT_DATA         CLR         CURRENT_R_DATA
00001C20  4279 0000224A           1499                          CLR         CURRENT_DATA
00001C26  0C39 0007 0000223A      1500                          CMP.B       #CONST_ADDR_MISC_MD,CURRENT_R_MD ; check the right mode.
00001C2E  6700 0004               1501                          BEQ         CONFIRM_READ_RIGHT_DATA              ; see if we have a mode that requires additional data.                  
00001C32  4E75                    1502                          RTS
00001C34                          1503                                              
00001C34  4239 00002244           1504  CONFIRM_READ_RIGHT_DATA CLR.B       CURRENT_REG
00001C3A  13F9 0000223B 00002244  1505                          MOVE.B      CURRENT_R_REG,CURRENT_REG
00001C44  6100 000E               1506                          BSR         CONFIRM_READ_DATA
00001C48  23F9 0000224A 0000223C  1507                          MOVE.L      CURRENT_DATA,CURRENT_R_DATA
00001C52  4E75                    1508                          RTS
00001C54                          1509                          
00001C54                          1510  *-----------------------Read some additional data.----------------------------------------------------------
00001C54                          1511        ; This same subroutine is used for reading any kind of data, as long as CURRENT_REG is set beforehand.
00001C54                          1512        ; By this point, CURRENT_REG holds whatever register we currently care about. (could also use CURRENT_REG)         
00001C54  0C39 0002 00002244      1513  CONFIRM_READ_DATA       CMP.B       #CONST_COUNTR_DISPLC_REG,CURRENT_REG      ; see if we are reading counter w/ displacement
00001C5C  6700 0034               1514                          BEQ         READ_COUNTR_DISPLC_DATA
00001C60                          1515                     
00001C60  0C39 0003 00002244      1516                          CMP.B       #CONST_COUNTR_INDEX_REG,CURRENT_REG       ; see if we are reading counter w/ index
00001C68  6700 002A               1517                          BEQ         READ_COUNTR_INDEX_DATA
00001C6C                          1518                          
00001C6C  0C39 0000 00002244      1519                          CMP.B       #CONST_ABS_SHORT_REG,CURRENT_REG          ; see if we are reading absolute short address
00001C74  6700 0020               1520                          BEQ         READ_ABS_SHORT_DATA
00001C78                          1521                          
00001C78  0C39 0001 00002244      1522                          CMP.B       #CONST_ABS_LONG_REG,CURRENT_REG           ; see if we are reading absolute long address
00001C80  6700 001C               1523                          BEQ         READ_ABS_LONG_DATA 
00001C84                          1524                          
00001C84  0C39 0004 00002244      1525                          CMP.B       #CONST_IMMEDIATE_REG,CURRENT_REG          ; see if we are reading immediate data
00001C8C  6700 0018               1526                          BEQ         READ_IMMEDIATE_DATA
00001C90                          1527       
00001C90  4E75                    1528                          RTS
00001C92                          1529                          
00001C92                          1530  ; TODO: each of these SRs should increment A5 by the proper amount while also storing the correct data in CURRENT_DATA.
00001C92  4E75                    1531  READ_COUNTR_DISPLC_DATA RTS ; TODO: read data for counter w/ displacement (d16,PC)
00001C94                          1532  
00001C94  4E75                    1533  READ_COUNTR_INDEX_DATA  RTS ; TODO: read data for counter w/ index        (d16,PC,Xn)
00001C96                          1534  
00001C96                          1535  *-----------------------Read additional absolute word address---------------------------
00001C96  33DD 0000224A           1536  READ_ABS_SHORT_DATA     MOVE.W      (A5)+,CURRENT_DATA ; read data for absolute short address  (xxx).W
00001C9C  4E75                    1537                          RTS
00001C9E                          1538                          
00001C9E                          1539  *-----------------------Read additional absolute long address---------------------------
00001C9E  23DD 0000224A           1540  READ_ABS_LONG_DATA      MOVE.L      (A5)+,CURRENT_DATA ; read data for absolute long address   (xxx).L
00001CA4  4E75                    1541                          RTS 
00001CA6                          1542  
00001CA6                          1543  *-----------------------Read additional immediate data---------------------------
00001CA6  0C39 0000 00002232      1544  READ_IMMEDIATE_DATA     CMP.B       #BYTE_SIZE,CURRENT_OP_SIZE   ; see if we are reading immediate byte data
00001CAE  6700 001C               1545                          BEQ         READ_IMMEDIATE_DATA_W
00001CB2                          1546                          
00001CB2  0C39 0001 00002232      1547                          CMP.B       #WORD_SIZE,CURRENT_OP_SIZE   ; see if we are reading immediate word data
00001CBA  6700 0010               1548                          BEQ         READ_IMMEDIATE_DATA_W
00001CBE                          1549                          
00001CBE  0C39 0002 00002232      1550                          CMP.B       #LONG_SIZE,CURRENT_OP_SIZE   ; see if we are reading immediate long data
00001CC6  6700 0012               1551                          BEQ         READ_IMMEDIATE_DATA_L
00001CCA                          1552                          ;TODO: error case goes here
00001CCA  4E75                    1553                          RTS
00001CCC                          1554  
00001CCC  4279 0000224A           1555  READ_IMMEDIATE_DATA_W   CLR         CURRENT_DATA
00001CD2  33DD 0000224A           1556                          MOVE.W      (A5)+,CURRENT_DATA
00001CD8  4E75                    1557                          RTS
00001CDA                          1558                          
00001CDA  4279 0000224A           1559  READ_IMMEDIATE_DATA_L   CLR         CURRENT_DATA
00001CE0  23DD 0000224A           1560                          MOVE.L      (A5)+,CURRENT_DATA
00001CE6  4E75                    1561                          RTS
00001CE8                          1562                          
00001CE8                          1563  *----------------------Display the source for the current instruction.-----------------
00001CE8                          1564  *by this point, error checking should already be done and CURRENT_SRC_MD and CURRENT_SRC_REG should have the data we need.
00001CE8  4239 00002243           1565  DISPLAY_SOURCE          CLR.B       CURRENT_MD
00001CEE  4239 00002244           1566                          CLR.B       CURRENT_REG
00001CF4  42B9 0000224A           1567                          CLR.L       CURRENT_DATA
00001CFA                          1568                          
00001CFA  13F9 00002245 00002243  1569                          MOVE.B      CURRENT_SRC_MD,CURRENT_MD
00001D04  13F9 00002246 00002244  1570                          MOVE.B      CURRENT_SRC_REG,CURRENT_REG    
00001D0E  23F9 0000224E 0000224A  1571                          MOVE.L      CURRENT_SRC_DATA,CURRENT_DATA
00001D18  6100 00A6               1572                          BSR         CHECK_ADDRESSING_MODES   
00001D1C  4E75                    1573                          RTS  
00001D1E                          1574                          
00001D1E                          1575  *----------------------Display the destination for the current instruction.-----------------
00001D1E                          1576  *by this point, error checking should already be done and CURRENT_DEST_MD and CURRENT_DEST_REG should have the data we need.
00001D1E  4239 00002243           1577  DISPLAY_DEST            CLR.B       CURRENT_MD
00001D24  4239 00002244           1578                          CLR.B       CURRENT_REG
00001D2A  42B9 0000224A           1579                          CLR.L       CURRENT_DATA
00001D30                          1580                          
00001D30  13F9 00002247 00002243  1581                          MOVE.B      CURRENT_DEST_MD,CURRENT_MD
00001D3A  13F9 00002248 00002244  1582                          MOVE.B      CURRENT_DEST_REG,CURRENT_REG    
00001D44  23F9 00002252 0000224A  1583                          MOVE.L      CURRENT_DEST_DATA,CURRENT_DATA
00001D4E  6100 0070               1584                          BSR         CHECK_ADDRESSING_MODES     
00001D52  4E75                    1585                          RTS  
00001D54                          1586  
00001D54                          1587  *----------------------Display the left side of the current instruction.-----------------------                        
00001D54  4239 00002243           1588  DISPLAY_LEFT            CLR.B       CURRENT_MD
00001D5A  4239 00002244           1589                          CLR.B       CURRENT_REG
00001D60  42B9 0000224A           1590                          CLR.L       CURRENT_DATA
00001D66                          1591                          
00001D66  13F9 00002233 00002243  1592                          MOVE.B      CURRENT_L_MD,CURRENT_MD
00001D70  13F9 00002234 00002244  1593                          MOVE.B      CURRENT_L_REG,CURRENT_REG    
00001D7A  23F9 00002236 0000224A  1594                          MOVE.L      CURRENT_L_DATA,CURRENT_DATA
00001D84  6100 003A               1595                          BSR         CHECK_ADDRESSING_MODES   
00001D88  4E75                    1596                          RTS  
00001D8A                          1597                          
00001D8A                          1598  *----------------------Display the right side of the current instruction.-----------------------  
00001D8A  4239 00002243           1599  DISPLAY_RIGHT           CLR.B       CURRENT_MD
00001D90  4239 00002244           1600                          CLR.B       CURRENT_REG
00001D96  42B9 0000224A           1601                          CLR.L       CURRENT_DATA
00001D9C                          1602                          
00001D9C  13F9 0000223A 00002243  1603                          MOVE.B      CURRENT_R_MD,CURRENT_MD
00001DA6  13F9 0000223B 00002244  1604                          MOVE.B      CURRENT_R_REG,CURRENT_REG    
00001DB0  23F9 0000223C 0000224A  1605                          MOVE.L      CURRENT_R_DATA,CURRENT_DATA
00001DBA  6100 0004               1606                          BSR         CHECK_ADDRESSING_MODES   
00001DBE  4E75                    1607                          RTS  
00001DC0                          1608                          
00001DC0                          1609  *-----------------------Mode checks (for displaying)---------
00001DC0                          1610  *these do not care whether the mode is for source or destination.
00001DC0  0C39 0000 00002243      1611  CHECK_ADDRESSING_MODES  CMP.B       #CONST_DATA_REG_MD,CURRENT_MD   ; check for CURRENT_MD = ...0000
00001DC8  6700 0058               1612                          BEQ         DISPLAY_DATA_REG
00001DCC  0C39 0001 00002243      1613                          CMP.B       #CONST_ADDR_REG_MD,CURRENT_MD    ; check for CURRENT_MD = ...0001
00001DD4  6700 006C               1614                          BEQ         DISPLAY_ADDR_REG
00001DD8  0C39 0002 00002243      1615                          CMP.B       #CONST_ADDR_IND_MD,CURRENT_MD    ; check for CURRENT_MD = ...0010
00001DE0  6700 0080               1616                          BEQ         DISPLAY_ADDR_IND
00001DE4  0C39 0003 00002243      1617                          CMP.B       #CONST_ADDR_INCR_MD,CURRENT_MD   ; check for CURRENT_MD = ...0011
00001DEC  6700 00AC               1618                          BEQ         DISPLAY_ADDR_INCR
00001DF0  0C39 0004 00002243      1619                          CMP.B       #CONST_ADDR_DECR_MD,CURRENT_MD   ; check for CURRENT_MD = ...0100
00001DF8  6700 00E4               1620                          BEQ         DISPLAY_ADDR_DECR
00001DFC  0C39 0005 00002243      1621                          CMP.B       #CONST_ADDR_DISPLC_MD,CURRENT_MD ; check for CURRENT_MD = ...0101
00001E04  6700 011C               1622                          BEQ         DISPLAY_ADDR_DISPLC
00001E08  0C39 0006 00002243      1623                          CMP.B       #CONST_ADDR_INDEX_MD,CURRENT_MD  ; check for CURRENT_MD = ...0110
00001E10  6700 0112               1624                          BEQ         DISPLAY_ADDR_INDEX
00001E14  0C39 0007 00002243      1625                          CMP.B       #CONST_ADDR_MISC_MD,CURRENT_MD   ; check for CURRENT_MD = ...0111
00001E1C  6700 0108               1626                          BEQ         CHECK_MISC_ADDRESSINGS
00001E20                          1627                          ;TODO: error cases? 
00001E20  4E75                    1628                          RTS
00001E22                          1629  
00001E22                          1630  ; case for displaying data register.          
00001E22  43F9 00002208           1631  DISPLAY_DATA_REG        LEA         MSG_D,A1               ; print out 'D' (later, send this to dislpay buffer)
00001E28  103C 000E               1632                          MOVE.B      #14,D0
00001E2C  4E4F                    1633                          TRAP        #15
00001E2E                          1634                          
00001E2E  4241                    1635                          CLR         D1
00001E30  1239 00002244           1636                          MOVE.B      (CURRENT_REG),D1      ; print out the number of the data register.
00001E36  143C 0010               1637                          MOVE.B      #16,D2
00001E3A  103C 000F               1638                          MOVE.B      #15,D0
00001E3E  4E4F                    1639                          TRAP        #15
00001E40                          1640                          
00001E40  4E75                    1641                          RTS
00001E42                          1642  
00001E42                          1643  ; case for displaying address register. 
00001E42  43F9 0000220A           1644  DISPLAY_ADDR_REG        LEA         MSG_A,A1               ; print out 'A'
00001E48  103C 000E               1645                          MOVE.B      #14,D0
00001E4C  4E4F                    1646                          TRAP        #15
00001E4E                          1647                          
00001E4E  4241                    1648                          CLR         D1
00001E50  1239 00002244           1649                          MOVE.B      (CURRENT_REG),D1       ; print out the number of the data register.
00001E56  143C 0010               1650                          MOVE.B      #16,D2
00001E5A  103C 000F               1651                          MOVE.B      #15,D0
00001E5E  4E4F                    1652                          TRAP        #15
00001E60                          1653                          
00001E60  4E75                    1654                          RTS
00001E62                          1655  
00001E62                          1656  ; case for displaying address register indirect.                        
00001E62  43F9 00001FDD           1657  DISPLAY_ADDR_IND        LEA         OPEN_PARENS,A1         ; print out '(' (later, send this to dislpay buffer)
00001E68  103C 000E               1658                          MOVE.B      #14,D0
00001E6C  4E4F                    1659                          TRAP        #15
00001E6E                          1660                          
00001E6E  43F9 0000220A           1661                          LEA         MSG_A,A1               ; print out 'A'
00001E74  103C 000E               1662                          MOVE.B      #14,D0
00001E78  4E4F                    1663                          TRAP        #15
00001E7A                          1664                          
00001E7A  4241                    1665                          CLR         D1
00001E7C  1239 00002244           1666                          MOVE.B      (CURRENT_REG),D1      ; print out the number of the data register.
00001E82  143C 0010               1667                          MOVE.B      #16,D2
00001E86  103C 000F               1668                          MOVE.B      #15,D0
00001E8A  4E4F                    1669                          TRAP        #15
00001E8C                          1670                          
00001E8C  43F9 00001FDF           1671                          LEA         CLOSE_PARENS,A1       ; print out ')'
00001E92  103C 000E               1672                          MOVE.B      #14,D0
00001E96  4E4F                    1673                          TRAP        #15
00001E98                          1674                          
00001E98  4E75                    1675                          RTS
00001E9A                          1676  
00001E9A                          1677  ; case for displaying address indirect postincrement.
00001E9A  43F9 00001FDD           1678  DISPLAY_ADDR_INCR       LEA         OPEN_PARENS,A1        ; print out '(' (later, send this to dislpay buffer)
00001EA0  103C 000E               1679                          MOVE.B      #14,D0
00001EA4  4E4F                    1680                          TRAP        #15
00001EA6                          1681                          
00001EA6  43F9 0000220A           1682                          LEA         MSG_A,A1              ; print out 'A'
00001EAC  103C 000E               1683                          MOVE.B      #14,D0
00001EB0  4E4F                    1684                          TRAP        #15
00001EB2                          1685                          
00001EB2  4241                    1686                          CLR         D1
00001EB4  1239 00002244           1687                          MOVE.B      (CURRENT_REG),D1      ; print out the number of the data register.
00001EBA  143C 0010               1688                          MOVE.B      #16,D2
00001EBE  103C 000F               1689                          MOVE.B      #15,D0
00001EC2  4E4F                    1690                          TRAP        #15
00001EC4                          1691                          
00001EC4  43F9 00001FDF           1692                          LEA         CLOSE_PARENS,A1       ; print out ')'
00001ECA  103C 000E               1693                          MOVE.B      #14,D0
00001ECE  4E4F                    1694                          TRAP        #15
00001ED0                          1695                          
00001ED0  43F9 00001FE1           1696                          LEA         PLUS,A1               ; print out '+'
00001ED6  103C 000E               1697                          MOVE.B      #14,D0
00001EDA  4E4F                    1698                          TRAP        #15
00001EDC                          1699                          
00001EDC  4E75                    1700                          RTS
00001EDE                          1701                          
00001EDE                          1702  ; case for displaying address indirect preedecrement mode.
00001EDE  43F9 00001FE3           1703  DISPLAY_ADDR_DECR       LEA         MINUS,A1               ; print out '-'
00001EE4  103C 000E               1704                          MOVE.B      #14,D0
00001EE8  4E4F                    1705                          TRAP        #15                                           
00001EEA                          1706  
00001EEA  43F9 00001FDD           1707                          LEA         OPEN_PARENS,A1        ; print out '(' (later, send this to dislpay buffer)
00001EF0  103C 000E               1708                          MOVE.B      #14,D0
00001EF4  4E4F                    1709                          TRAP        #15
00001EF6                          1710                          
00001EF6  43F9 0000220A           1711                          LEA         MSG_A,A1              ; print out 'A'
00001EFC  103C 000E               1712                          MOVE.B      #14,D0
00001F00  4E4F                    1713                          TRAP        #15
00001F02                          1714                          
00001F02  4241                    1715                          CLR         D1
00001F04  1239 00002244           1716                          MOVE.B      (CURRENT_REG),D1      ; print out the number of the data register.
00001F0A  143C 0010               1717                          MOVE.B      #16,D2
00001F0E  103C 000F               1718                          MOVE.B      #15,D0
00001F12  4E4F                    1719                          TRAP        #15
00001F14                          1720                          
00001F14  43F9 00001FDF           1721                          LEA         CLOSE_PARENS,A1       ; print out ')'
00001F1A  103C 000E               1722                          MOVE.B      #14,D0
00001F1E  4E4F                    1723                          TRAP        #15
00001F20                          1724                          
00001F20  4E75                    1725                          RTS     
00001F22                          1726  
00001F22                          1727  DISPLAY_ADDR_DISPLC     ;TODO: case for source mode is address with displacement mode.
00001F22  4E75                    1728                          RTS    
00001F24                          1729  
00001F24                          1730  DISPLAY_ADDR_INDEX      ;TODO: case for source mode is address with index mode.
00001F24  4E75                    1731                          RTS 
00001F26                          1732  
00001F26                          1733  *-----------------------Register checks (for displaying only)---------
00001F26                          1734  *these do not care whether the register is for source or destination.
00001F26                          1735  *not for cases where reg is simply a number (like D5, A5, (A5), etc),
00001F26                          1736  *only for miscellaneous addressings where mode is 111.                        
00001F26  0C39 0002 00002244      1737  CHECK_MISC_ADDRESSINGS  CMP.B       #CONST_COUNTR_DISPLC_REG,CURRENT_REG
00001F2E  6700 0034               1738                          BEQ         DISPLAY_COUNTR_DISPLC
00001F32                          1739                          
00001F32  0C39 0003 00002244      1740                          CMP.B       #CONST_COUNTR_INDEX_REG,CURRENT_REG
00001F3A  6700 002A               1741                          BEQ         DISPLAY_COUNTR_INDEX
00001F3E                          1742                          
00001F3E  0C39 0000 00002244      1743                          CMP.B       #CONST_ABS_SHORT_REG,CURRENT_REG
00001F46  6700 0020               1744                          BEQ         DISPLAY_ABS_SHORT
00001F4A                          1745                          
00001F4A  0C39 0001 00002244      1746                          CMP.B       #CONST_ABS_LONG_REG,CURRENT_REG
00001F52  6700 0034               1747                          BEQ         DISPLAY_ABS_LONG
00001F56                          1748                          
00001F56  0C39 0004 00002244      1749                          CMP.B       #CONST_IMMEDIATE_REG,CURRENT_REG
00001F5E  6700 0048               1750                          BEQ         DISPLAY_IMMEDIATE
00001F62                          1751                          
00001F62                          1752                          ; TODO: error case?
00001F62                          1753                          
00001F62  4E75                    1754                          RTS
00001F64                          1755                          
00001F64  4E75                    1756  DISPLAY_COUNTR_DISPLC   RTS         ;TODO   
00001F66                          1757  
00001F66  4E75                    1758  DISPLAY_COUNTR_INDEX    RTS         ;TODO   
00001F68                          1759  
00001F68  43F9 00001FD7           1760  DISPLAY_ABS_SHORT       LEA         DOLLAR,A1             ; print out '$'. 
00001F6E  103C 000E               1761                          MOVE.B      #14,D0
00001F72  4E4F                    1762                          TRAP        #15
00001F74                          1763  
00001F74  4241                    1764                          CLR         D1
00001F76  3239 0000224A           1765                          MOVE.W      (CURRENT_DATA),D1     ; print out the absolute short address we are concerned with in hex. 
00001F7C  143C 0010               1766                          MOVE.B      #16,D2
00001F80  103C 000F               1767                          MOVE.B      #15,D0
00001F84  4E4F                    1768                          TRAP        #15
00001F86                          1769                          
00001F86  4E75                    1770                          RTS 
00001F88                          1771  
00001F88  43F9 00001FD7           1772  DISPLAY_ABS_LONG        LEA         DOLLAR,A1             ; print out '$'. 
00001F8E  103C 000E               1773                          MOVE.B      #14,D0
00001F92  4E4F                    1774                          TRAP        #15
00001F94                          1775  
00001F94  4241                    1776                          CLR         D1
00001F96  2239 0000224A           1777                          MOVE.L      (CURRENT_DATA),D1     ; print out the absolute long address we are concerned with in hex. 
00001F9C  143C 0010               1778                          MOVE.B      #16,D2
00001FA0  103C 000F               1779                          MOVE.B      #15,D0
00001FA4  4E4F                    1780                          TRAP        #15
00001FA6                          1781                          
00001FA6  4E75                    1782                          RTS 
00001FA8                          1783  
00001FA8  43F9 00001FDB           1784  DISPLAY_IMMEDIATE       LEA         HASH,A1               ; print out '#'. (NOTE: should send this to display buffer instead.)
00001FAE  103C 000E               1785                          MOVE.B      #14,D0
00001FB2  4E4F                    1786                          TRAP        #15
00001FB4                          1787                          
00001FB4  43F9 00001FD7           1788                          LEA         DOLLAR,A1             ; print out '$'. (this saves time since we can more easily find the hex value of the immediate data.)
00001FBA  103C 000E               1789                          MOVE.B      #14,D0
00001FBE  4E4F                    1790                          TRAP        #15
00001FC0                          1791                          
00001FC0  3239 0000224A           1792                          MOVE.W      (CURRENT_DATA),D1     ; print out the immediate data we are concerned with in hex. 
00001FC6  143C 0010               1793                          MOVE.B      #16,D2
00001FCA  103C 000F               1794                          MOVE.B      #15,D0
00001FCE  4E4F                    1795                          TRAP        #15
00001FD0                          1796                          
00001FD0  4E75                    1797                          RTS
00001FD2                          1798                          
00001FD2                          1799  *###################### END EA ##################################
00001FD2                          1800  *############# BEGIN VARIABLES/CONSTANTS #########################
00001FD2                          1801  *** Variables and Constants are kept here ***
00001FD2                          1802  
00001FD2                          1803  *output characters
00001FD2  =0000000D               1804  CR                      EQU         $0D
00001FD2  =0000000A               1805  LF                      EQU         $0A
00001FD2= 0D 0A 00                1806  RETURN                  DC.B        CR,LF,0
00001FD5= 20 00                   1807  SPACE                   DC.B        ' ',0
00001FD7= 24 00                   1808  DOLLAR                  DC.B        '$',0
00001FD9= 2C 00                   1809  COMMA                   DC.B        ',',0
00001FDB= 23 00                   1810  HASH                    DC.B        '#',0
00001FDD= 28 00                   1811  OPEN_PARENS             DC.B        '(',0
00001FDF= 29 00                   1812  CLOSE_PARENS            DC.B        ')',0
00001FE1= 2B 00                   1813  PLUS                    DC.B        '+',0
00001FE3= 2D 00                   1814  MINUS                   DC.B        '-',0
00001FE5= 2F 00                   1815  SLASH                   DC.B        '/',0
00001FE7                          1816  
00001FE7                          1817  *output messages
00001FE7                          1818      ;TODO: consider also giving the user the range of valid start/end addresses
00001FE7= 50 6C 65 61 73 65 ...   1819  START_ADDR_MSG          DC.B        'Please enter a starting hex address to read from.',CR,LF,0
0000201B= 50 6C 65 61 73 65 ...   1820  END_ADDR_MSG            DC.B        'Please enter an ending hex address to read from.',CR,LF,0
0000204E                          1821  
0000204E= 4E 6F 74 20 61 20 ...   1822  INVALID_LEN_MSG         DC.B        'Not a valid length for input address.',CR,LF
00002075= 50 6C 65 61 73 65 ...   1823                          DC.B        'Please enter a valid-length address.',CR,LF,0
0000209C= 4E 6F 74 20 61 20 ...   1824  INVALID_ADDR_MSG        DC.B        'Not a valid address.',CR,LF
000020B2= 50 6C 65 61 73 65 ...   1825                          DC.B        'Please enter a valid address.',CR,LF,0
000020D2= 4E 6F 74 20 61 20 ...   1826  INVALID_END_ADDR_MSG    DC.B        'Not a valid end address.',CR,LF
000020EC= 50 6C 65 61 73 65 ...   1827                          DC.B        'Please enter an end address after the start address.',CR,LF,0
00002123                          1828                        
00002123= 4E 6F 74 20 61 20 ...   1829  INVALID_ADDR_L_MSG      DC.B        'Not a valid address (too low).',CR,LF
00002143= 50 6C 65 61 73 65 ...   1830                          DC.B        'Please enter a valid address.',CR,LF,0
00002163                          1831                          
00002163= 4E 6F 74 20 61 20 ...   1832  INVALID_ADDR_H_MSG      DC.B        'Not a valid address (too high).',CR,LF
00002184= 50 6C 65 61 73 65 ...   1833                          DC.B        'Please enter a valid address.',CR,LF,0
000021A4                          1834                          
000021A4= 44 6F 6E 65 20 72 ...   1835  DONE_READING_MSG        DC.B        'Done reading the program.',CR,LF,0
000021C0                          1836  
000021C0                          1837  *output instruction names (OPcodes)
000021C0                          1838      ;sizes
000021C0= 2E 42 00                1839  BYTE_SIZE_MSG           DC.B        '.B',0
000021C3= 2E 57 00                1840  WORD_SIZE_MSG           DC.B        '.W',0
000021C6= 2E 4C 00                1841  LONG_SIZE_MSG           DC.B        '.L',0
000021C9                          1842  
000021C9                          1843      ;constants
000021C9= 52 45 53 45 54 00       1844  RESET_MSG               DC.B        'RESET',0
000021CF= 4E 4F 50 00             1845  NOP_MSG                 DC.B        'NOP',0
000021D3= 53 54 4F 50 00          1846  STOP_MSG                DC.B        'STOP',0
000021D8                          1847      ;moves
000021D8= 4D 4F 56 45 00          1848  MOVE_MSG                DC.B        'MOVE',0
000021DD= 4D 4F 56 45 2E 42 00    1849  MOVE_B_MSG              DC.B        'MOVE.B',0
000021E4= 4D 4F 56 45 2E 57 00    1850  MOVE_W_MSG              DC.B        'MOVE.W',0
000021EB= 4D 4F 56 45 2E 4C 00    1851  MOVE_L_MSG              DC.B        'MOVE.L',0
000021F2                          1852  
000021F2= 4D 4F 56 45 51 00       1853  MOVEQ_MSG               DC.B        'MOVEQ',0
000021F8                          1854  
000021F8= 4D 4F 56 45 4D 2E ...   1855  MOVEM_W_MSG             DC.B        'MOVEM.W',0
00002200= 4D 4F 56 45 4D 2E ...   1856  MOVEM_L_MSG             DC.B        'MOVEM.L',0
00002208                          1857  
00002208                          1858  *other output instruction message constants
00002208= 44 00                   1859  MSG_D                   DC.B        'D',0
0000220A= 41 00                   1860  MSG_A                   DC.B        'A',0
0000220C                          1861  
0000220C                          1862  *storage locations for input
0000220C                          1863  START_ADDR_IN           DS.B        20
00002220                          1864  
00002220                          1865  *other I/O-related variables/constants
00002220  =00000001               1866  INPUTTING_START         SET         1 ;if 1, we are inputting start address. If 0, we are inputting end address.
00002220                          1867  OPCODE_BUFFER           DS.L        1 ; can hold at most 4 characters
00002224                          1868  SIZE_BUFFER             DS.W        1 ;cand hold at most 2 characters
00002226                          1869  DISPLAY_BUFFER          DS.W        5
00002230                          1870  
00002230                          1871  *EA/OPcode parsed instruction variables/constants
00002230                          1872  
00002230                          1873  CURRENT_WORD            DS.W        1 ; current first 16 bits of an instruction.
00002232                          1874  CURRENT_OP_SIZE         DS.B        1 ; current operation size. Byte = 01, Word = 11, Long = 10
00002233                          1875  
00002233                          1876      *Direction-oriented variables
00002233                          1877          *left
00002233                          1878  CURRENT_L_MD            DS.B        1 ; current left mode (printing-wise) we are concerned with.
00002234                          1879  CURRENT_L_REG           DS.B        1 ; current left register (printing-wise) we are concerned with.
00002236                          1880  CURRENT_L_DATA          DS.L        1
0000223A                          1881          *right
0000223A                          1882  CURRENT_R_MD            DS.B        1 ; current right mode (printing-wise) we are concerned with.
0000223B                          1883  CURRENT_R_REG           DS.B        1 ; current right register (printing-wise) we are concerned with.
0000223C                          1884  CURRENT_R_DATA          DS.L        1
00002240                          1885  
00002240                          1886  
00002240                          1887      *Destination/source-oriented variables
00002240                          1888  CURRENT_EA_MD           DS.B        1 ; current EA mode we are concerned with.
00002241                          1889  CURRENT_EA_REG          DS.B        1 ; current EA register we are concerned with.
00002242                          1890  
00002242                          1891  CURRENT_DIRECTION       DS.B        1 ; current direction of an operation.
00002243                          1892  
00002243                          1893  CURRENT_MD              DS.B        1 ; current mode we are concerened with (ex: 000 for data register mode.)
00002244                          1894  CURRENT_REG             DS.B        1 ; current register number we are concerned with(address, data, etc) that we are looking at. Ex: D0,A5,etc
00002245                          1895  
00002245                          1896  CURRENT_SRC_MD          DS.B        1 ; current source mode
00002246                          1897  CURRENT_SRC_REG         DS.B        1 ; current source register
00002247                          1898  CURRENT_DEST_MD         DS.B        1 ; current desination mode
00002248                          1899  CURRENT_DEST_REG        DS.B        1 ; current desination register
00002249                          1900  
0000224A                          1901  CURRENT_DATA            DS.L        1 ; current addition data we are concerned with
0000224E                          1902  CURRENT_SRC_DATA        DS.L        1 ; current additional data for source (like absolute addresses, immediate data, etc)
00002252                          1903  CURRENT_DEST_DATA       DS.L        1 ; current additional data for destination (like absolute addresses, immediate data, etc) 
00002256                          1904  
00002256                          1905      *miscellaneous EA variables
00002256                          1906  CURRENT_MASK_FIELD      DS.W        1 ; right now, this is only used for MOVEM.
00002258                          1907  
00002258                          1908  *size constants
00002258  =00000000               1909  BYTE_SIZE               EQU         $00 ; 0000 0000
00002258  =00000001               1910  WORD_SIZE               EQU         $01 ; 0000 0001
00002258  =00000002               1911  LONG_SIZE               EQU         $02 ; 0000 0010
00002258                          1912  
00002258  =00000001               1913  BYTE_SIZE_M             EQU         $01 ; 0000 0001
00002258  =00000003               1914  WORD_SIZE_M             EQU         $03 ; 0000 0011
00002258  =00000002               1915  LONG_SIZE_M             EQU         $02 ; 0000 0010
00002258                          1916  
00002258  =00000000               1917  WORD_SIZE_MOVEM         EQU         $00 ; 0000 0000
00002258  =00000001               1918  LONG_SIZE_MOVEM         EQU         $01 ; 0000 0001
00002258                          1919  
00002258                          1920  *address constants
00002258  =00004000               1921  MIN_ADDRESS             EQU         $00004000
00002258  =0FFF0000               1922  MAX_ADDRESS             EQU         $0FFF0000
00002258                          1923  
00002258                          1924  *address variables
00002258  =00007000               1925  TEST_ORIGIN             SET         $00007000
00002258  =00007000               1926  NEXT_ADDR               SET         TEST_ORIGIN
00002258  =00009000               1927  END_ADDR                SET         $00009000
00002258                          1928  
00002258                          1929  *filters for isolating parts of a hexa instruction. X means 'unknown' and can be 0 or one after ANDI filter.
00002258                          1930  *To filter an instruction, ANDI it with the desired filter.
00002258                          1931  *note: I'm not sure if it matters much whether you have the 4 leading 0s in these filters, but I don't want to
00002258                          1932  *risk changing it. Therefore, some filters have leading 0s and some do not.
00002258                          1933      * general filters
00002258  =0000C000               1934  FILT_2BIT_1             EQU         $0000C000   ; first 2 bits:                         XX00 0000 0000 0000
00002258  =0000F000               1935  FILT_NIB_1              EQU         $0000F000   ; first nibble:                         XXXX 0000 0000 0000
00002258  =00000F00               1936  FILT_NIB_2              EQU         $00000F00   ; second nibble:                        0000 XXXX 0000 0000
00002258  =00000800               1937  FILT_BIT_5              EQU         $00000800   ; 5th bit:                              0000 X000 0000 0000
00002258  =00000100               1938  FILT_BIT_8              EQU         $00000100   ; 8th bit:                              0000 000X 0000 0000
00002258                          1939  
00002258                          1940      * source/destination filters (not applicable for bidirectional operations)
00002258  =00000E00               1941  FILT_DEST_REG           EQU         $00000E00   ; destination register:                 0000 XXX0 0000 0000
00002258  =000001C0               1942  FILT_DEST_MD            EQU         $000001C0   ; destination mode:                     0000 000X XX00 0000
00002258  =00000038               1943  FILT_SRC_MD             EQU         $00000038   ; source mode:                          0000 0000 00XX X000
00002258  =00000007               1944  FILT_SRC_REG            EQU         $00000007   ; source register:                      0000 0000 0000 0XXX
00002258                          1945  
00002258                          1946      * move filters
00002258  =00003000               1947  FILT_MOVE_SIZE          EQU         $00003000   ; Size of a move operation:             00XX 0000 0000 0000
00002258  =0000FB80               1948  FILT_MOVEM              EQU         $0000FB80   ; check for a MOVEM instruction:        XXXX X0XX X000 0000
00002258  =00000040               1949  FILT_MOVEM_SIZE         EQU         $00000040   ; Size of a MOVEM operation             0000 0000 0X00 0000
00002258  =00000400               1950  FILT_MOVEM_DIR          EQU         $00000400   ; direction of a MOVEM operation:       0000 0X00 0000 0000
00002258                          1951  
00002258                          1952      * filters for BRA, BSR, BCC, and MOVEQ (the same filter, but named differently for clarity.)
00002258  =000000FF               1953  FILT_DISPLACEMENT       EQU         $00FF       ; Displacment of branch instruction:    0000 0000 XXXX XXXX
00002258  =000000FF               1954  FILT_MOVEQ_DATA         EQU         $00FF       ; Data of MOVEQ instruction:            0000 0000 XXXX XXXX
00002258                          1955  
00002258                          1956      * ADD-type method filters
00002258  =00000130               1957  FILT_ADDX               EQU         $0130       ; filter what is normally dest. and md. 0000 000X 00XX 0000   
00002258  =000000C0               1958  FILT_ADDA               EQU         $00C0       ; filter what is normally the size.     0000 0000 XX00 0000
00002258                          1959  
00002258                          1960      * EXT filter
00002258  =0000FFB8               1961  FILT_EXT                EQU         $FFB8       ; check for an EXT instruction:         XXXX XXXX X0XX X000
00002258                          1962  
00002258                          1963  * constants for comparing with filtered instructions. X means 'don't care' (and will be set to 0 by previous filter)
00002258                          1964  *(These do not represent the complete insturctions.)
00002258                          1965  *(Also note that repetition is allowed for clarity's sake, so two constants can share a value.)
00002258                          1966  
00002258                          1967      * general filters
00002258  =00000000               1968  CONST_ALL_0             EQU         $0000    ; all 0s:                               0000 0000 0000 0000
00002258                          1969  
00002258                          1970      * Nibble 1 filters
00002258  =00004000               1971  CONST_NIB1_0100         EQU         $4000    ; first nibble is 0100                  0100 XXXX XXXX XXXX
00002258  =00005000               1972  CONST_NIB1_0101         EQU         $5000    ; first nibble is 0101                  0101 XXXX XXXX XXXX
00002258  =00006000               1973  CONST_NIB1_0110         EQU         $6000    ; first nibble is 0110                  0110 XXXX XXXX XXXX
00002258  =00008000               1974  CONST_NIB1_1000         EQU         $8000    ; first nibble is 1000                  1000 XXXX XXXX XXXX
00002258  =00009000               1975  CONST_NIB1_1001         EQU         $9000    ; first nibble is 1001                  1001 XXXX XXXX XXXX
00002258  =0000B000               1976  CONST_NIB1_1011         EQU         $B000    ; first nibble is 1011                  1011 XXXX XXXX XXXX
00002258  =0000C000               1977  CONST_NIB1_1100         EQU         $C000    ; first nibble is 1100                  1100 XXXX XXXX XXXX
00002258  =0000D000               1978  CONST_NIB1_1101         EQU         $D000    ; first nibble is 1101                  1101 XXXX XXXX XXXX
00002258  =0000E000               1979  CONST_NIB1_1110         EQU         $E000    ; first nibble is 1110                  1110 XXXX XXXX XXXX
00002258                          1980  
00002258                          1981      * Nibble 2 filters
00002258  =00000800               1982  CONST_NIB2_1000         EQU         $0800    ; second nibble is 1000                 XXXX 1000 XXXX XXXX
00002258  =00000A00               1983  CONST_NIB2_1010         EQU         $0A00    ; second nibble is 1010                 XXXX 1010 XXXX XXXX
00002258  =00000E00               1984  CONST_NIB2_1110         EQU         $0E00    ; second nibble is 1110                 XXXX 1110 XXXX XXXX
00002258                          1985  
00002258                          1986  * Immediate operation constants
00002258                          1987      * ANDI
00002258  =00000000               1988  CONST_ORI_DEST_REG      EQU         $0000    ; confirm ORI                           XXXX 000X XXXX XXXX
00002258                          1989      * ANDI
00002258  =00000200               1990  CONST_ANDI_DEST_REG     EQU         $0200    ; confirm ANDI                          XXXX 001X XXXX XXXX
00002258                          1991      * SUBI
00002258  =00000400               1992  CONST_SUBI_DEST_REG     EQU         $0400    ; confirm SUBI                          XXXX 010X XXXX XXXX
00002258                          1993      * ADDI
00002258  =00000600               1994  CONST_ADDI_DEST_REG     EQU         $0600    ; confirm ADDI                          XXXX 011X XXXX XXXX
00002258                          1995      * EORI
00002258  =00000A00               1996  CONST_EORI_DEST_REG     EQU         $0A00    ; confirm EORI                          XXXX 101X XXXX XXXX
00002258                          1997      * CMPI
00002258  =00000C00               1998  CONST_CMPI_DEST_REG     EQU         $0C00    ; confirm CMPI                          XXXX 110X XXXX XXXX
00002258                          1999  
00002258                          2000  * Constants for matching based on 2nd nibble
00002258                          2001      *NEGX
00002258  =00000000               2002  CONST_NEGX_OP           EQU         $0000    ; confirm NEGX                          XXXX 0000 XXXX XXXX
00002258                          2003      *CLR
00002258  =00000200               2004  CONST_CLR_OP            EQU         $0200    ; confirm CLR                           XXXX 0010 XXXX XXXX
00002258                          2005      *NEG
00002258  =00000400               2006  CONST_NEG_OP            EQU         $0400    ; confirm NEG                           XXXX 0100 XXXX XXXX
00002258                          2007      *NOT
00002258  =00000600               2008  CONST_NOT_OP            EQU         $0600    ; confirm NOT                           XXXX 0110 XXXX XXXX
00002258                          2009  
00002258                          2010  * EXT constant
00002258  =00004880               2011  CONST_EXT               EQU         $4880    ; confirm EXT                           0100 1000 1X00 0XXX
00002258                          2012  
00002258                          2013  * Other constants
00002258                          2014      * BTST,BCHG,BCLR,BSET
00002258  =00000800               2015  CONST_B_OP              EQU         $0800    ; BTST,BCHG,BCLR,BSET                   XXXX 100X XXXX XXXX
00002258                          2016  
00002258                          2017      * MOVE
00002258  =00001000               2018  CONST_MOVE_B            EQU         $1000    ; MOVE.B (use first nib)                0001 XXXX XXXX XXXX
00002258  =00003000               2019  CONST_MOVE_W            EQU         $3000    ; MOVE.W (use first nib)                0011 XXXX XXXX XXXX
00002258  =00002000               2020  CONST_MOVE_L            EQU         $2000    ; MOVE.L (use first nib)                0010 XXXX XXXX XXXX
00002258                          2021  
00002258                          2022      * MOVEQ
00002258  =00007000               2023  CONST_MOVEQ             EQU         $7000    ; MOVEQ.L (use first nib)               0111 XXXX XXXX XXXX    
00002258                          2024           
00002258                          2025      * MOVEM                      
00002258  =00004880               2026  CONST_MOVEM             EQU         $4880    ; confirm MOVEM (use FILT_MOVEM)        0100 1X00 1XXX XXXX        
00002258  =00000000               2027  CONST_MOVEM_DIR_0       EQU         $0000    ; MOVEM list to EA direction            XXXX XXXX XXXX XXX0
00002258  =00000001               2028  CONST_MOVEM_DIR_1       EQU         $0001    ; MOVEM EA to list direction            XXXX XXXX XXXX XXX1    
00002258                          2029  
00002258                          2030      * ADDX
00002258  =00000100               2031  CONST_ADDX              EQU         $0100    ; confirm ADDX                          XXXX XXX1 XX00 XXXX        
00002258                          2032          
00002258                          2033      * ADDA
00002258  =000000C0               2034  CONST_ADDA              EQU         $00C0    ; confirm ADDA                          XXXX XXXX 11XX XXXX
00002258                          2035   
00002258                          2036  * Mode/register constants
00002258                          2037  
00002258                          2038      * Mode values
00002258  =00000000               2039  CONST_DATA_REG_MD       EQU         $00      ; Data register mode:     Dn            XXXX X000
00002258  =00000001               2040  CONST_ADDR_REG_MD       EQU         $01      ; Address register mode:  An            XXXX X001
00002258  =00000002               2041  CONST_ADDR_IND_MD       EQU         $02      ; Address indirect mode:  (An)          XXXX X010
00002258  =00000003               2042  CONST_ADDR_INCR_MD      EQU         $03      ; Address postincr. mode: (An)+         XXXX X011
00002258  =00000004               2043  CONST_ADDR_DECR_MD      EQU         $04      ; Address predecr. mode:  -(An)         XXXX X100
00002258  =00000005               2044  CONST_ADDR_DISPLC_MD    EQU         $05      ; Address w/ displacement:(d16,An)      XXXX X101
00002258  =00000006               2045  CONST_ADDR_INDEX_MD     EQU         $06      ; Address w/ index:       (d8,PC,Xn)    XXXX X110
00002258  =00000007               2046  CONST_ADDR_MISC_MD      EQU         $07      ; Various other addressing modes        XXXX X111
00002258                          2047  
00002258                          2048      * Constant register values (should not be necessary for register numbers like D5 or A4)
00002258  =00000002               2049  CONST_COUNTR_DISPLC_REG EQU         $02      ; Counter w/ displacement:(d16,PC)      XXXX X010
00002258  =00000003               2050  CONST_COUNTR_INDEX_REG  EQU         $03      ; Counter w/ index:       (d16,PC,Xn)   XXXX X011
00002258  =00000000               2051  CONST_ABS_SHORT_REG     EQU         $00      ; Absolute word:          (xxx).W       XXXX X000
00002258  =00000001               2052  CONST_ABS_LONG_REG      EQU         $01      ; Absolute long:          (xxx).L       XXXX X001
00002258  =00000004               2053  CONST_IMMEDIATE_REG     EQU         $04      ; Immediate data:         #imm          XXXX X100
00002258                          2054  
00002258                          2055  *full OPcode contstants
00002258  =00004E70               2056  RESET_CODE              EQU         $4E70    ; RESET                                 0100 1110 0111 0001
00002258  =00004E71               2057  NOP_CODE                EQU         $4E71    ; NOP                                   0100 1110 0111 0001
00002258  =00004E72               2058  STOP_CODE               EQU         $4E72    ; STOP                                  0100 1110 0111 0010
00002258                          2059  
00002258                          2060    
00002258                          2061  *############# END VARIABLES/CONSTANTS #########################
00002258                          2062  
00002258                          2063      END START        ; last line of source, very end of the program

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDA_FOUND          1AF8
ADDI_FOUND          1ABC
ADDX_FOUND          1AF4
ADD_B_FOUND         1AE8
ADD_FOUND           1AD8
ADD_L_FOUND         1AF0
ADD_W_FOUND         1AEC
ANDI_FOUND          1AB4
ASCII_TO_HEX        10B4
BEGIN_READ          12E2
BYTE_SIZE           0
BYTE_SIZE_M         1
BYTE_SIZE_MSG       21C0
CHECK_ADDRESSING_MODES  1DC0
CHECK_ADDR_IN_LIST_FLAG  198C
CHECK_CONSTANTS     134A
CHECK_DONE_READING  1308
CHECK_EXT           1622
CHECK_MISC_ADDRESSINGS  1F26
CHECK_MOVE          15E6
CHECK_MOVEM         1638
CHECK_MOVEQ         160C
CHECK_NIB1_0000     13EE
CHECK_NIB1_0100     1404
CHECK_NIB1_0101     141A
CHECK_NIB1_0110     1430
CHECK_NIB1_1000     1446
CHECK_NIB1_1001     145A
CHECK_NIB1_1011     1470
CHECK_NIB1_1100     1486
CHECK_NIB1_1101     149C
CHECK_NIB1_1110     14B2
CHECK_NON_CONSTANTS  13B2
CHECK_SINGLE_A      195C
CHECK_SINGLE_D      1974
CLOSE_PARENS        1FDF
CLR_FOUND           1ACC
CMPI_FOUND          1AC4
COMMA               1FD9
CONFIRMED_NEXT_OP   12F6
CONFIRM_0000_XXX0   14E0
CONFIRM_0100_0XXX   153A
CONFIRM_0100_1000   1592
CONFIRM_0100_1010   1596
CONFIRM_0100_1110   159A
CONFIRM_0100_1XXX   156A
CONFIRM_NIB1_0000   14C8
CONFIRM_NIB1_0100   151E
CONFIRM_NIB1_0101   159E
CONFIRM_NIB1_0110   15A2
CONFIRM_NIB1_1000   15A6
CONFIRM_NIB1_1001   15AA
CONFIRM_NIB1_1011   15AE
CONFIRM_NIB1_1100   15B2
CONFIRM_NIB1_1101   15B6
CONFIRM_NIB1_1110   15E2
CONFIRM_READ_DATA   1C54
CONFIRM_READ_DEST_DATA  1BC0
CONFIRM_READ_LEFT_DATA  1BFA
CONFIRM_READ_RIGHT_DATA  1C34
CONFIRM_READ_SRC_DATA  1B86
CONST_ABS_LONG_REG  1
CONST_ABS_SHORT_REG  0
CONST_ADDA          C0
CONST_ADDI_DEST_REG  600
CONST_ADDR_DECR_MD  4
CONST_ADDR_DISPLC_MD  5
CONST_ADDR_INCR_MD  3
CONST_ADDR_INDEX_MD  6
CONST_ADDR_IND_MD   2
CONST_ADDR_MISC_MD  7
CONST_ADDR_REG_MD   1
CONST_ADDX          100
CONST_ALL_0         0
CONST_ANDI_DEST_REG  200
CONST_B_OP          800
CONST_CLR_OP        200
CONST_CMPI_DEST_REG  C00
CONST_COUNTR_DISPLC_REG  2
CONST_COUNTR_INDEX_REG  3
CONST_DATA_REG_MD   0
CONST_EORI_DEST_REG  A00
CONST_EXT           4880
CONST_IMMEDIATE_REG  4
CONST_MOVEM         4880
CONST_MOVEM_DIR_0   0
CONST_MOVEM_DIR_1   1
CONST_MOVEQ         7000
CONST_MOVE_B        1000
CONST_MOVE_L        2000
CONST_MOVE_W        3000
CONST_NEGX_OP       0
CONST_NEG_OP        400
CONST_NIB1_0100     4000
CONST_NIB1_0101     5000
CONST_NIB1_0110     6000
CONST_NIB1_1000     8000
CONST_NIB1_1001     9000
CONST_NIB1_1011     B000
CONST_NIB1_1100     C000
CONST_NIB1_1101     D000
CONST_NIB1_1110     E000
CONST_NIB2_1000     800
CONST_NIB2_1010     A00
CONST_NIB2_1110     E00
CONST_NOT_OP        600
CONST_ORI_DEST_REG  0
CONST_SUBI_DEST_REG  400
CONVERSION_DONE     12B0
COUNT_INPUT_DIGITS  1046
CR                  D
CURRENT_DATA        224A
CURRENT_DEST_DATA   2252
CURRENT_DEST_MD     2247
CURRENT_DEST_REG    2248
CURRENT_DIRECTION   2242
CURRENT_EA_MD       2240
CURRENT_EA_REG      2241
CURRENT_L_DATA      2236
CURRENT_L_MD        2233
CURRENT_L_REG       2234
CURRENT_MASK_FIELD  2256
CURRENT_MD          2243
CURRENT_OP_SIZE     2232
CURRENT_REG         2244
CURRENT_R_DATA      223C
CURRENT_R_MD        223A
CURRENT_R_REG       223B
CURRENT_SRC_DATA    224E
CURRENT_SRC_MD      2245
CURRENT_SRC_REG     2246
CURRENT_WORD        2230
DIG_CONV_DONE_1     10DE
DIG_CONV_DONE_2     1112
DIG_CONV_DONE_3     114A
DIG_CONV_DONE_4     1182
DIG_CONV_DONE_5     11BA
DIG_CONV_DONE_6     11F2
DIG_CONV_DONE_7     122A
DIG_CONV_DONE_8     1262
DISPLAY_ABS_LONG    1F88
DISPLAY_ABS_SHORT   1F68
DISPLAY_ADDR_DECR   1EDE
DISPLAY_ADDR_DISPLC  1F22
DISPLAY_ADDR_INCR   1E9A
DISPLAY_ADDR_IND    1E62
DISPLAY_ADDR_INDEX  1F24
DISPLAY_ADDR_REG    1E42
DISPLAY_BUFFER      2226
DISPLAY_COUNTR_DISPLC  1F64
DISPLAY_COUNTR_INDEX  1F66
DISPLAY_CURRENT_ADDRESS  1324
DISPLAY_DATA_REG    1E22
DISPLAY_DEST        1D1E
DISPLAY_IMMEDIATE   1FA8
DISPLAY_LEFT        1D54
DISPLAY_MOVEM_DATA  18B4
DISPLAY_MOVEM_DIR_0  18C4
DISPLAY_MOVEM_DIR_1  18E6
DISPLAY_MOVEM_LIST  1908
DISPLAY_MOVEM_LIST_FWD  1918
DISPLAY_MOVEM_LIST_REV  1922
DISPLAY_MOVEQ_DATA  176C
DISPLAY_MOVE_DATA   16F8
DISPLAY_RIGHT       1D8A
DISPLAY_SLASH       1A58
DISPLAY_SOURCE      1CE8
DISP_MM_END_A       1A28
DISP_MM_END_D       1A84
DISP_MM_START_A     1A06
DISP_MM_START_D     1A68
DOLLAR              1FD7
DONE_READING        1310
DONE_READING_MSG    21A4
END_ADDR            9000
END_ADDR_MSG        201B
EORI_FOUND          1AC0
EXT_FOUND           17A8
FILT_2BIT_1         C000
FILT_ADDA           C0
FILT_ADDX           130
FILT_BIT_5          800
FILT_BIT_8          100
FILT_DEST_MD        1C0
FILT_DEST_REG       E00
FILT_DISPLACEMENT   FF
FILT_EXT            FFB8
FILT_MOVEM          FB80
FILT_MOVEM_DIR      400
FILT_MOVEM_SIZE     40
FILT_MOVEQ_DATA     FF
FILT_MOVE_SIZE      3000
FILT_NIB_1          F000
FILT_NIB_2          F00
FILT_SRC_MD         38
FILT_SRC_REG        7
FIND_MM_END_A       19BA
FIND_MM_END_A_LOOP  19BE
FIND_MM_END_D       19F0
FIND_MM_END_D_LOOP  19F4
FIND_MM_START_A     1998
FIND_MM_START_A_LOOP  19A8
FIND_MM_START_D     19CE
FIND_MM_START_D_LOOP  19E0
GO_TO_NEXT_OP       12F2
HASH                1FDB
INPUTTING_START     1
INVALID_ADDR_HIGH   12A0
INVALID_ADDR_H_MSG  2163
INVALID_ADDR_INPUT  1270
INVALID_ADDR_LOW    1290
INVALID_ADDR_L_MSG  2123
INVALID_ADDR_MSG    209C
INVALID_END_ADDR    1280
INVALID_END_ADDR_MSG  20D2
INVALID_LEN_MSG     204E
LF                  A
LONG_SIZE           2
LONG_SIZE_M         2
LONG_SIZE_MOVEM     1
LONG_SIZE_MSG       21C6
MAX_ADDRESS         FFF0000
MINUS               1FE3
MIN_ADDRESS         4000
MOVEM_FOUND         17AC
MOVEM_LIST_DISPLAY_DONE  1AAE
MOVEM_L_FOUND       17F6
MOVEM_L_MSG         2200
MOVEM_W_FOUND       17CA
MOVEM_W_MSG         21F8
MOVEQ_FOUND         171A
MOVEQ_MSG           21F2
MOVE_B_FOUND        164E
MOVE_B_MSG          21DD
MOVE_L_FOUND        16AE
MOVE_L_MSG          21EB
MOVE_MSG            21D8
MOVE_W_FOUND        167E
MOVE_W_MSG          21E4
MSG_A               220A
MSG_D               2208
NEGX_FOUND          1AC8
NEG_FOUND           1AD0
NEXT_ADDR           7000
NOP_CODE            4E71
NOP_FOUND           1390
NOP_MSG             21CF
NOT_FOUND           1AD4
OPCODE_BUFFER       2220
OPEN_PARENS         1FDD
ORI_FOUND           1AB0
PARSE_MOVEM_DATA    1822
PARSE_MOVEM_DIR_0   186A
PARSE_MOVEM_DIR_1   1888
PARSE_MOVEM_MASK_FIELD  18A6
PARSE_MOVEQ_DATA    174A
PARSE_MOVE_DATA     16DE
PLUS                1FE1
PREPARE_DISPLAY     12EE
PROMPT_INPUT        1008
READ_ABS_LONG_DATA  1C9E
READ_ABS_SHORT_DATA  1C96
READ_COUNTR_DISPLC_DATA  1C92
READ_COUNTR_INDEX_DATA  1C94
READ_CURRENT_OP     1320
READ_DEST_DATA      1BA6
READ_DEST_MODE      1B1A
READ_DEST_REG       1AFC
READ_IMMEDIATE_DATA  1CA6
READ_IMMEDIATE_DATA_L  1CDA
READ_IMMEDIATE_DATA_W  1CCC
READ_LEFT_DATA      1BE0
READ_MOVEM_DIR      1852
READ_MOVEQ_DATA     178E
READ_RIGHT_DATA     1C1A
READ_SOURCE_DATA    1B6C
READ_SOURCE_MODE    1B36
READ_SOURCE_REG     1B52
RESET_CODE          4E70
RESET_FOUND         1372
RESET_MSG           21C9
RETURN              1FD2
REVERSE_MASK_FIELD  1930
REVERSE_MASK_FIELD_LOOP  194C
SET_END_ADDR        12D8
SET_START_ADDR      12D2
SIZE_BUFFER         2224
SLASH               1FE5
SPACE               1FD5
START               1000
START_ADDR_IN       220C
START_ADDR_MSG      1FE7
STOP                1004
STOP_CODE           4E72
STOP_FOUND          13AE
STOP_MSG            21D3
SUBI_FOUND          1AB8
TAKE_USER_INPUT     1034
TAKE_USER_IN_E      1020
TAKE_USER_IN_S      100C
TEST_ORIGIN         7000
VALID_ADDR          12C6
WORD_SIZE           1
WORD_SIZE_M         3
WORD_SIZE_MOVEM     0
WORD_SIZE_MSG       21C3
