00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.14.00
Created On: 2/21/2014 1:19:02 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Disassembler
00000000                             3  * Written by : Robert Brandenburg, Danielle Jenkins, Shahin Nahar
00000000                             4  * Date       : 2/13/14
00000000                             5  * Description: Disassemble hex machine code instructions into 68K instructions
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8  * TODO: write disassembler
00000000                             9  * TODO: more specific TODOs for our plan
00000000                            10  * TODO: comments saying who is working where
00000000                            11  
00000000                            12  
00000000                            13  * Commenting Key: 
00000000                            14  *    "----------"  <-- subroutine commenting
00000000                            15  *    "##########"  <-- section/role commenting
00000000                            16  
00000000                            17  * Notes on saving registers on run:
00000000                            18  *    MOVEM.L A0-A3/D0-D7, -(A7) * copies all working registers to stack
00000000                            19  *    MOVEM.L (A7)+, A0-A3/D0-D7 *Restore the registers
00000000                            20  
00000000                            21  * Notes on AND filters (bit masking):
00000000                            22  * Example:
00000000                            23  *       0001 000 001 111 100   (say you want "001")
00000000                            24  *   AND 0000 000 111 000 000   (0 <-- don't want, 1 <-- do want)
00000000                            25  *       --------------------
00000000                            26  *     = 0000 000 001 000 000
00000000                            27  *
00000000                            28  * Relevant wiki page:
00000000                            29  *   https://en.wikipedia.org/wiki/Mask_(computing)#Masking_bits_to_0
00000000                            30  *
00000000                            31  *################ TODO LIST ################################
00000000                            32  *----------------OPcode TODOS (ROBERT)-----------------------------
00000000                            33  *
00000000                            34  * Fix the current bugs with MOVEs performed on absolute addresses. Not sure why these errors occur.
00000000                            35  *   -consult the bug report before trying to debug.
00000000                            36  * Continue decoding OPcodes in the following order: (with sizes)
00000000                            37  *   NOTE: I will delete OPcodes from this list as I implement them.
00000000                            38  *   -MOVEQ  (?)
00000000                            39  *   -MOVEM  (W,L)
00000000                            40  *   -ADD    (B,W,L) (will need shahin's size filter for this and below)
00000000                            41  *   -ADDA   (W,L)
00000000                            42  *   -ADDI   (B,W,L)
00000000                            43  *   -SUB    (B,W,L)
00000000                            44  *   -SUBA   (W,L)
00000000                            45  *   -SUBQ   (B,W,L)
00000000                            46  *   -MULS   (W)     (not MULU?)
00000000                            47  *   -DIVU   (W      (not DIVU?)
00000000                            48  *   -LEA    (?)
00000000                            49  *   -CLR    (B,W,L)
00000000                            50  *   -AND    (B,W,L)
00000000                            51  *   -ANDI   (B,W,L)
00000000                            52  *   -EOR    (B,W,L)
00000000                            53  *   -EORI   (B,W,L)
00000000                            54  *   -ASR    (B,W,L) (no ASL?)
00000000                            55  *   -LSL    (B,W,L) (no LSR?)
00000000                            56  *   -ROL    (B,W,L)
00000000                            57  *   -ROR    (B,W,L)
00000000                            58  *   -BCHG   (?)
00000000                            59  *   -CMP    (B,W,L)
00000000                            60  *   -CMPA   (W,L)
00000000                            61  *   -CMPI   (B,W,L)
00000000                            62  *   -JSR    (N/A)
00000000                            63  *   (add others if we have time)
00000000                            64  *
00000000                            65  *----------------I/O TODOS (DANIELLE)-----------------------------
00000000                            66  * (TODOs for I/O go here.)
00000000                            67  *----------------EA TODOS  (SHAHIN)-----------------------------
00000000                            68  * (TODOs for EA go here.)
00000000                            69  *################ BEGIN MAIN ###############################
00000000                            70  *** All subroutine calls are made here ***
00001000                            71  START                   ORG        $1000       ; first instruction of program
00001000  6000 0006                 72                          BRA        PROMPT_INPUT            ; prompt the user for input
00001004                            73                   
00001004  4E72 2700                 74  STOP                    STOP       #$2700          ; halt simulator, end of main
00001008                            75  
00001008                            76  *################ END MAIN ###############################
00001008                            77  *################ BEGIN IO ###############################
00001008                            78  *** IO Subroutines are kept here ***
00001008                            79  
00001008                            80  *-------------------- Print ASCII logo ----------------------
00001008  6000 0002                 81  PROMPT_INPUT            BRA         TAKE_USER_IN_S ;TODO: change to welcome/ASCII logo
0000100C                            82  *------------------- Prompt user for input -------------------
0000100C                            83  
0000100C                            84                  
0000100C  163C 0001                 85  TAKE_USER_IN_S          MOVE.B      #1,D3
00001010  43F9 0000195D             86                          LEA         START_ADDR_MSG,A1  ; Prompt user for starting address
00001016  103C 000E                 87                          MOVE.B      #14,D0
0000101A  4E4F                      88                          TRAP        #15
0000101C                            89  
0000101C  6000 0016                 90                          BRA         TAKE_USER_INPUT
00001020                            91  
00001020  163C 0000                 92  TAKE_USER_IN_E          MOVE.B      #0,D3
00001024  43F9 00001991             93                          LEA         END_ADDR_MSG,A1  ; prompt user for ending address
0000102A  103C 000E                 94                          MOVE.B      #14,D0
0000102E  4E4F                      95                          TRAP        #15
00001030                            96                          
00001030  6000 0002                 97                          BRA         TAKE_USER_INPUT
00001034                            98                          
00001034  7200                      99  TAKE_USER_INPUT         MOVE.L      #$00000000,D1   ; need to clear out the data registers we are about to use to avoid junk data.   
00001036  7A00                     100                          MOVE.L      #$00000000,D5    
00001038  7C00                     101                          MOVE.L      #$00000000,D6
0000103A  7E00                     102                          MOVE.L      #$00000000,D7
0000103C                           103  
0000103C  103C 0002                104                          MOVE.B      #2,D0           ; Take user input for next address.
00001040  327C 2000                105                          MOVEA.W     #$2000,A1       ; Store the ascii input in A1,(note that we might not want to use 2000 here)
00001044  4E4F                     106                          TRAP        #15             ; and the length in D1.W.  
00001046                           107  
00001046  327C 2001                108  COUNT_INPUT_DIGITS      MOVEA.W     #$2001,A1
0000104A  B27C 0001                109                          CMP         #1,D1
0000104E  6700 0064                110                          BEQ         ASCII_TO_HEX  ;start converting if we have 1 digit.
00001052                           111            
00001052  327C 2002                112                          MOVEA.W     #$2002,A1
00001056  B27C 0002                113                          CMP         #2,D1
0000105A  6700 0058                114                          BEQ         ASCII_TO_HEX  ;start converting if we have 2 digits.
0000105E                           115            
0000105E  327C 2003                116                          MOVEA.W     #$2003,A1
00001062  B27C 0003                117                          CMP         #3,D1
00001066  6700 004C                118                          BEQ         ASCII_TO_HEX  ;start converting if we have 3 digits.
0000106A                           119            
0000106A  327C 2004                120                          MOVEA.W     #$2004,A1
0000106E  B27C 0004                121                          CMP         #4,D1
00001072  6700 0040                122                          BEQ         ASCII_TO_HEX  ;start converting if we have 4 digits.
00001076                           123            
00001076  327C 2005                124                          MOVEA.W     #$2005,A1
0000107A  B27C 0005                125                          CMP         #5,D1
0000107E  6700 0034                126                          BEQ         ASCII_TO_HEX  ;start converting if we have 5 digits.
00001082                           127            
00001082  327C 2006                128                          MOVEA.W     #$2006,A1
00001086  B27C 0006                129                          CMP         #6,D1
0000108A  6700 0028                130                          BEQ         ASCII_TO_HEX  ;start converting if we have 6 digits.
0000108E                           131            
0000108E  327C 2007                132                          MOVEA.W     #$2007,A1
00001092  B27C 0007                133                          CMP         #7,D1
00001096  6700 001C                134                          BEQ         ASCII_TO_HEX  ;start converting if we have 7 digits.
0000109A                           135            
0000109A  327C 2008                136                          MOVEA.W     #$2008,A1
0000109E  B27C 0008                137                          CMP         #8,D1
000010A2  6700 0010                138                          BEQ         ASCII_TO_HEX  ;start converting if we have 8 digits.
000010A6                           139            
000010A6  43F9 000019C4            140                          LEA         INVALID_LEN_MSG,A1         ; If we get an invalid length, give and error message and... branch back asking user for input again
000010AC  103C 000E                141                          MOVE.B      #14,D0
000010B0  4E4F                     142                          TRAP        #15
000010B2                           143  
000010B2  6780                     144                          BEQ         TAKE_USER_INPUT               
000010B4                           145  
000010B4                           146  
000010B4                           147  
000010B4                           148  *------------------- Convert to hex subroutine -------------------
000010B4                           149  
000010B4  7C00                     150  ASCII_TO_HEX            MOVE.L      #$00000000,D6      ; running total of converted hex number
000010B6                           151                  
000010B6                           152                          ;first digit
000010B6  1A21                     153                          MOVE.B      -(A1),D5  ; Move the raw ascii value of first digit into 3007.
000010B8  BA7C 0030                154                          CMP         #$30,D5
000010BC  6D00 01B2                155                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
000010C0  BA7C 0040                156                          CMP         #$40,D5
000010C4  6700 01AA                157                          BEQ         INVALID_ADDR_INPUT
000010C8  BA7C 0046                158                          CMP         #$46,D5
000010CC  6E00 01A2                159                          BGT         INVALID_ADDR_INPUT   
000010D0                           160                          ; Convert ascii to hex for that digit.
000010D0  0445 0030                161                          SUB         #$30,D5   ;
000010D4  BA7C 000A                162                          CMP         #$A,D5
000010D8  6D00 0004                163                          BLT         DIG_CONV_DONE_1 ; Necessary to convert some ASCII values.
000010DC  5F05                     164                          SUB.B       #7, D5                      ; TODO: errors for invalid ASCII values.
000010DE                           165                  
000010DE  DC45                     166  DIG_CONV_DONE_1         ADD.W       D5,D6
000010E0  B27C 0001                167                          CMP         #1,D1
000010E4  6700 01CA                168                          BEQ         CONVERSION_DONE
000010E8                           169                  
000010E8                           170                          ;second digit
000010E8  7A00                     171                          MOVE.L      #$00000000,D5
000010EA  1A21                     172                          MOVE.B      -(A1),D5
000010EC  BA7C 0030                173                          CMP         #$30,D5
000010F0  6D00 017E                174                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
000010F4  BA7C 0040                175                          CMP         #$40,D5
000010F8  6700 0176                176                          BEQ         INVALID_ADDR_INPUT
000010FC  BA7C 0046                177                          CMP         #$46,D5
00001100  6E00 016E                178                          BGT         INVALID_ADDR_INPUT   
00001104  0445 0030                179                          SUB         #$30,D5
00001108  BA7C 000A                180                          CMP         #$A,D5            
0000110C  6D00 0004                181                          BLT         DIG_CONV_DONE_2    ;digit conversion done 1
00001110  5F05                     182                          SUB.B       #7, D5             ; if we have A or greater, then we need to subtract 1.
00001112                           183               
00001112  CAFC 0010                184  DIG_CONV_DONE_2         MULU.W      #$00000010,D5  ; this part adds $10 * (2nd digit) to our running total.
00001116  DC45                     185                          ADD.W       D5,D6 
00001118                           186                    
00001118  B27C 0002                187                          CMP         #2,D1
0000111C  6700 0192                188                          BEQ         CONVERSION_DONE
00001120                           189                  
00001120                           190                          ;third digit
00001120  7A00                     191                          MOVE.L      #$00000000,D5
00001122  1A21                     192                          MOVE.B      -(A1),D5
00001124  BA7C 0030                193                          CMP         #$30,D5
00001128  6D00 0146                194                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
0000112C  BA7C 0040                195                          CMP         #$40,D5
00001130  6700 013E                196                          BEQ         INVALID_ADDR_INPUT
00001134  BA7C 0046                197                          CMP         #$46,D5
00001138  6E00 0136                198                          BGT         INVALID_ADDR_INPUT   
0000113C  0445 0030                199                          SUB         #$30,D5
00001140  BA7C 000A                200                          CMP         #$A,D5
00001144  6D00 0004                201                          BLT         DIG_CONV_DONE_3 
00001148  5F05                     202                          SUB.B       #7, D5
0000114A                           203                  
0000114A  CAFC 0100                204  DIG_CONV_DONE_3         MULU.W      #$00000100,D5
0000114E  DC45                     205                          ADD.W       D5,D6 
00001150                           206      
00001150  B27C 0003                207                          CMP         #3,D1
00001154  6700 015A                208                          BEQ         CONVERSION_DONE
00001158                           209                  
00001158                           210                          ;fourth digit
00001158  7A00                     211                          MOVE.L      #$00000000,D5
0000115A  1A21                     212                          MOVE.B      -(A1),D5
0000115C  BA7C 0030                213                          CMP         #$30,D5
00001160  6D00 010E                214                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
00001164  BA7C 0040                215                          CMP         #$40,D5
00001168  6700 0106                216                          BEQ         INVALID_ADDR_INPUT
0000116C  BA7C 0046                217                          CMP         #$46,D5
00001170  6E00 00FE                218                          BGT         INVALID_ADDR_INPUT   
00001174  0445 0030                219                          SUB         #$30,D5
00001178  BA7C 000A                220                          CMP         #$A,D5
0000117C  6D00 0004                221                          BLT         DIG_CONV_DONE_4
00001180  5F05                     222                          SUB.B       #7,D5
00001182                           223                  
00001182  CAFC 1000                224  DIG_CONV_DONE_4         MULU.W      #$00001000,D5
00001186  DC45                     225                          ADD.W       D5,D6 
00001188                           226      
00001188  B27C 0004                227                          CMP         #4,D1
0000118C  6700 0122                228                          BEQ         CONVERSION_DONE
00001190                           229                  
00001190                           230                          ;fifth digit
00001190  7A00                     231                          MOVE.L      #$00000000,D5
00001192  1A21                     232                          MOVE.B      -(A1),D5
00001194  BA7C 0030                233                          CMP         #$30,D5
00001198  6D00 00D6                234                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
0000119C  BA7C 0040                235                          CMP         #$40,D5
000011A0  6700 00CE                236                          BEQ         INVALID_ADDR_INPUT
000011A4  BA7C 0046                237                          CMP         #$46,D5
000011A8  6E00 00C6                238                          BGT         INVALID_ADDR_INPUT   
000011AC  0445 0030                239                          SUB         #$30,D5
000011B0  BA7C 000A                240                          CMP         #$A,D5
000011B4  6D00 0004                241                          BLT         DIG_CONV_DONE_5
000011B8  5F05                     242                          SUB.B       #$7, D5
000011BA                           243                  
000011BA  CAFC 0001                244  DIG_CONV_DONE_5         MULU.W      #$0001,D5
000011BE  DE45                     245                          ADD.W       D5,D7 
000011C0                           246  
000011C0  B27C 0005                247                          CMP         #5,D1
000011C4  6700 00EA                248                          BEQ         CONVERSION_DONE
000011C8                           249                  
000011C8                           250                          ;sixth digit
000011C8  7A00                     251                          MOVE.L      #$00000000,D5
000011CA  1A21                     252                          MOVE.B      -(A1),D5
000011CC  BA7C 0030                253                          CMP         #$30,D5
000011D0  6D00 009E                254                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
000011D4  BA7C 0040                255                          CMP         #$40,D5
000011D8  6700 0096                256                          BEQ         INVALID_ADDR_INPUT
000011DC  BA7C 0046                257                          CMP         #$46,D5
000011E0  6E00 008E                258                          BGT         INVALID_ADDR_INPUT   
000011E4  0445 0030                259                          SUB         #$30,D5
000011E8  BA7C 000A                260                          CMP         #$A,D5
000011EC  6D00 0004                261                          BLT         DIG_CONV_DONE_6
000011F0  5F05                     262                          SUB.B       #$7, D5
000011F2                           263                  
000011F2  CAFC 0010                264  DIG_CONV_DONE_6         MULU.W      #$0010,D5
000011F6  DE45                     265                          ADD.W       D5,D7
000011F8                           266      
000011F8  B27C 0006                267                          CMP         #6,D1
000011FC  6700 00B2                268                          BEQ         CONVERSION_DONE
00001200                           269                  
00001200                           270                          ;seventh digit
00001200  7A00                     271                          MOVE.L      #$00000000,D5
00001202  1A21                     272                          MOVE.B      -(A1),D5
00001204  BA7C 0030                273                          CMP         #$30,D5
00001208  6D00 0066                274                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
0000120C  BA7C 0040                275                          CMP         #$40,D5
00001210  6700 005E                276                          BEQ         INVALID_ADDR_INPUT
00001214  BA7C 0046                277                          CMP         #$46,D5
00001218  6E00 0056                278                          BGT         INVALID_ADDR_INPUT   
0000121C  0445 0030                279                          SUB         #$30,D5
00001220  BA7C 000A                280                          CMP         #$A,D5
00001224  6D00 0004                281                          BLT         DIG_CONV_DONE_7
00001228  5F05                     282                          SUB.B       #7, D5
0000122A                           283                  
0000122A  CAFC 0100                284  DIG_CONV_DONE_7         MULU.W      #$0100,D5
0000122E  DE45                     285                          ADD.W       D5,D7
00001230                           286      
00001230  B27C 0007                287                          CMP         #7,D1
00001234  6700 007A                288                          BEQ         CONVERSION_DONE
00001238                           289                  
00001238                           290                          ;eighth digit
00001238  7A00                     291                          MOVE.L      #$00000000,D5
0000123A  1A21                     292                          MOVE.B      -(A1),D5
0000123C  BA7C 0030                293                          CMP         #$30,D5
00001240  6D00 002E                294                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
00001244  BA7C 0040                295                          CMP         #$40,D5
00001248  6700 0026                296                          BEQ         INVALID_ADDR_INPUT
0000124C  BA7C 0046                297                          CMP         #$46,D5
00001250  6E00 001E                298                          BGT         INVALID_ADDR_INPUT   
00001254  0445 0030                299                          SUB         #$30,D5
00001258  BA7C 000A                300                          CMP         #$A,D5
0000125C  6D00 0004                301                          BLT         DIG_CONV_DONE_8
00001260  5F05                     302                          SUB.B       #7, D5
00001262                           303                  
00001262  CAFC 1000                304  DIG_CONV_DONE_8         MULU.W      #$1000,D5
00001266  DE45                     305                          ADD.W       D5,D7
00001268                           306      
00001268  B27C 0008                307                          CMP         #8,D1
0000126C  6700 0042                308                          BEQ         CONVERSION_DONE    ;the input was valid and we are done with the conversion
00001270                           309                  
00001270  43F9 00001A12            310  INVALID_ADDR_INPUT      LEA         INVALID_ADDR_MSG,A1    ;tell the user the address was invalid and prompt input again.
00001276  103C 000E                311                          MOVE.B      #14,D0
0000127A  4E4F                     312                          TRAP        #15
0000127C                           313                          
0000127C  6000 FDB6                314                          BRA         TAKE_USER_INPUT
00001280                           315                          
00001280  43F9 00001A48            316  INVALID_END_ADDR        LEA         INVALID_END_ADDR_MSG,A1
00001286  103C 000E                317                          MOVE.B      #14,D0
0000128A  4E4F                     318                          TRAP        #15
0000128C                           319                          
0000128C  6000 FDA6                320                          BRA         TAKE_USER_INPUT
00001290                           321                          
00001290  43F9 00001A99            322  INVALID_ADDR_LOW        LEA         INVALID_ADDR_L_MSG,A1    ;tell the user the address was invalid and prompt input again.
00001296  103C 000E                323                          MOVE.B      #14,D0
0000129A  4E4F                     324                          TRAP        #15
0000129C                           325                          
0000129C  6000 FD96                326                          BRA         TAKE_USER_INPUT
000012A0                           327  
000012A0  43F9 00001AD9            328  INVALID_ADDR_HIGH       LEA         INVALID_ADDR_H_MSG,A1    ;tell the user the address was invalid and prompt input again.
000012A6  103C 000E                329                          MOVE.B      #14,D0
000012AA  4E4F                     330                          TRAP        #15
000012AC                           331                          
000012AC  6000 FD86                332                          BRA         TAKE_USER_INPUT
000012B0                           333                 
000012B0  E18F                     334  CONVERSION_DONE         LSL.L       #8,D7   ; Prepare for concatenation
000012B2  E18F                     335                          LSL.L       #8,D7   ; Got to perform the same operation twice to get it all the way to the left
000012B4  DE46                     336                          ADD.W       D6,D7  ; concatenate the two data registers into one value
000012B6                           337                          
000012B6  BEBC 00003000            338                          CMP.L       #MIN_ADDRESS,D7
000012BC  6DD2                     339                          BLT         INVALID_ADDR_LOW ;Not a valid address-- too low.
000012BE                           340                          
000012BE  BEBC 0FFF0000            341                          CMP.L       #MAX_ADDRESS,D7
000012C4  6EDA                     342                          BGT         INVALID_ADDR_HIGH  ;Not a valid address-- too high.
000012C6                           343                          
000012C6  0C43 0001                344  VALID_ADDR              CMPI        #1,D3
000012CA                           345                          
000012CA  6700 0006                346                          BEQ         SET_START_ADDR
000012CE  6000 0008                347                          BRA         SET_END_ADDR              
000012D2                           348                                                 
000012D2  2A47                     349  SET_START_ADDR          MOVEA.L     D7,A5  ;when a valid start address is inputted, store and ask the user for an end address.
000012D4  6000 FD4A                350                          BRA         TAKE_USER_IN_E
000012D8                           351  
000012D8  BE8D                     352  SET_END_ADDR            CMP.L       A5,D7    ;if end address is lower than start address, we get an error.
000012DA  6DA4                     353                          BLT         INVALID_END_ADDR           
000012DC                           354                          
000012DC  2C47                     355                          MOVEA.L     D7,A6  ;when a valid start address is inputted, store and ask the user for an end address.
000012DE  6000 0002                356                          BRA         BEGIN_READ
000012E2                           357                          
000012E2  284D                     358  BEGIN_READ              MOVEA.L      A5,A4 ; keep track of address to print with A4. TODO: could also add this value to the display buffer.
000012E4  33DD 00001B96            359                          MOVE.W      (A5)+,CURRENT_WORD ;look at the first instruction word at the starting address.
000012EA  6000 0002                360                          BRA         PREPARE_DISPLAY
000012EE                           361  
000012EE                           362  *------------------- Add to display buffer -------------------
000012EE                           363  ;At this point A5 is a valid start address and A6 is a valid end address.
000012EE                           364  ;TODO: prepare the display buffer
000012EE  6000 0030                365  PREPARE_DISPLAY         BRA         READ_CURRENT_OP    ;TEMP (though we might still call this after the display buffer is prepared)                       
000012F2                           366                 
000012F2                           367  *------------------- Move address pointer for data reading -------------------
000012F2                           368  ; This method is specifically for reading the next OPword.
000012F2  6000 0014                369  GO_TO_NEXT_OP           BRA         CHECK_DONE_READING
000012F6                           370                           
000012F6  4279 00001B96            371  CONFIRMED_NEXT_OP       CLR         CURRENT_WORD
000012FC  284D                     372                          MOVEA.L      A5,A4 ; keep track of address to print with A4. 
000012FE  33DD 00001B96            373                          MOVE.W      (A5)+,CURRENT_WORD
00001304  6000 001A                374                          BRA         READ_CURRENT_OP
00001308                           375  *------------------- Print display buffer -------------------
00001308                           376  
00001308                           377  ;TODO
00001308                           378  
00001308                           379  *------------------- Check if end of data -------------------
00001308  BACE                     380  CHECK_DONE_READING      CMPA        A6,A5       ; TODO: this comparison is not sufficient, because it will say that $8000 is less than $7000 (since $8000 is negative.)
0000130A  6DEA                     381                          BLT         CONFIRMED_NEXT_OP
0000130C  6000 0002                382                          BRA         DONE_READING
00001310                           383  *------------------- Ask user for input -------------------
00001310  43F9 00001B1A            384  DONE_READING            LEA         DONE_READING_MSG,A1 ; when we reach the end address, say so and halt the program. TODO: ask user whether we want to read the data again.
00001316  103C 000E                385                          MOVE.B      #14,D0
0000131A  4E4F                     386                          TRAP        #15
0000131C  4EF8 1004                387                          JMP         STOP
00001320                           388  *################## END IO  #####################################
00001320                           389  *################## BEGIN OPCODE ##########################
00001320                           390  *** OPcode Subroutines are kept here ***
00001320                           391  
00001320                           392  ; planned process for reading hex instructions:
00001320                           393          ; NOTE: this process is tentative and subject to change as OPcode person implements. 
00001320                           394                  ;           1) Go to start of instruction reading loop, passing in the address of next instruction.
00001320                           395                  ;           2) Store a word (16 bits) from that address.
00001320                           396                  ;           3) Read the first 4 bits of the word using a filter.
00001320                           397                  ;           4) branch to one of the following paths based on these bits:
00001320                           398                  ;               a) 0000: Read the next 3 bits (i.e., the destination mode). Branch:
00001320                           399                  ;                   i.   000: Read the bits at 0000 0000 XXXX XXXX (may want to make this filter) Branch:
00001320                           400                  ;                       1) 00 111 100: ORI TO CCR (need to read data, I think)
00001320                           401                  ;                       2) 01 111 100: ORI TO SR (need to read data, I think)
00001320                           402                  ;                       3) (default) ORI. Now, read and store:
00001320                           403                  ;                           SIZE:       0000 0000 XX00 0000 (need to make this filter)
00001320                           404                  ;                           MODE:       0000 0000 00XX X000 (need to make this filter)
00001320                           405                  ;                           REGISTER:   0000 0000 0000 0XXX (need to make this filter)
00001320                           406                  ;                           only mandatory additional data is the immediate data.
00001320                           407                  ;                   ii.  001: Read the bits at 0000 0000 XXXX XXXX (may want to make this filter) Branch:
00001320                           408                  ;                       1) 00 111 100: ANDI TO CCR (need to read data, I think)
00001320                           409                  ;                       2) 01 111 100: ANDI TO SR (need to read data, I think)
00001320                           410                  ;                       3) (default) ANDI. Now, read and store:
00001320                           411                  ;                           SIZE:       0000 0000 XX00 0000 (need to make this filter)
00001320                           412                  ;                           MODE:       0000 0000 00XX X000 (need to make this filter)
00001320                           413                  ;                           REGISTER:   0000 0000 0000 0XXX (need to make this filter)
00001320                           414                  ;                           only mandatory additional data is the immediate data.
00001320                           415                  ;                   iii. 101: Read the bits at 0000 0000 XXXX XXXX (may want to make this filter) Branch:
00001320                           416                  ;                       1) 00 111 100: EORI TO CCR (need to read data, I think)
00001320                           417                  ;                       2) 01 111 100: EORI TO SR (need to read data, I think)
00001320                           418                  ;                       3) (default) EORI. Now, read and store:
00001320                           419                  ;                           SIZE:       0000 0000 XX00 0000 (need to make this filter)
00001320                           420                  ;                           MODE:       0000 0000 00XX X000 (FILT_SRC_MODE)
00001320                           421                  ;                           REGISTER:   0000 0000 0000 0XXX (FILT_SRC_REG)
00001320                           422                  ;                           only mandatory additional data is the immediate data.
00001320                           423                  ;                   iv.  011: ADDI. Now read and store:
00001320                           424                  ;                           SIZE:       0000 0000 XX00 0000 (need to make this filter)
00001320                           425                  ;                           MODE:       0000 0000 00XX X000 (FILT_SRC_MODE)
00001320                           426                  ;                           REGISTER:   0000 0000 0000 0XXX (FILT_SRC_REG)
00001320                           427                  ;                           only mandatory additional data is the immediate data.
00001320                           428                  ;                   v.   010: SUBI. Now read and store:
00001320                           429                  ;                           SIZE:       0000 0000 XX00 0000 (need to make this filter)
00001320                           430                  ;                           MODE:       0000 0000 00XX X000 (FILT_SRC_MODE)
00001320                           431                  ;                           REGISTER:   0000 0000 0000 0XXX (FILT_SRC_REG)
00001320                           432                  ;                           only mandatory additional data is the immediate data.
00001320                           433                  ;                   vi.  110: CMPI. Now read and store:
00001320                           434                  ;                           SIZE:       0000 0000 XX00 0000 (need to make this filter)
00001320                           435                  ;                           MODE:       0000 0000 00XX X000 (FILT_SRC_MODE)
00001320                           436                  ;                           REGISTER:   0000 0000 0000 0XXX (FILT_SRC_REG)
00001320                           437                  ;                           only mandatory additional data is the immediate data.
00001320                           438                  ;                   vii. 100: BTST, BCHG, BCLR, BSET (TODO: expand this section if we need these OPcodes)
00001320                           439                  ;                   viii.(default): BTST, BCHG, BCLR, BSET (with data register)(TODO: expand this section if we need these OPcodes)
00001320                           440                  ;               b) 0001: (MOVE.B). Now read and store:
00001320                           441                  ;                           DESTINATION REGISTER: 0000 XXX0 0000 0000 (FILT_DEST_REG)
00001320                           442                  ;                           DESTINATION MODE:     0000 000X XX00 0000 (FILT_DEST_MODE)
00001320                           443                  ;                           SOURCE MODE:          0000 0000 00XX X000 (FILT_SCR_MODE)
00001320                           444                  ;                           SOURCE REGISTER:      0000 0000 0000 0XXX (FILT_SRC_REG)
00001320                           445                  ;                           The modes (and maybe register) will tell us whether we need to read additional data for this MOVE.
00001320                           446                  ;               c) 0011: (MOVE.W). Now read and store:
00001320                           447                  ;                           DESTINATION REGISTER: 0000 XXX0 0000 0000 (FILT_DEST_REG)
00001320                           448                  ;                           DESTINATION MODE:     0000 000X XX00 0000 (FILT_DEST_MODE)
00001320                           449                  ;                           SOURCE MODE:          0000 0000 00XX X000 (FILT_SCR_MODE)
00001320                           450                  ;                           SOURCE REGISTER:      0000 0000 0000 0XXX (FILT_SRC_REG)
00001320                           451                  ;                           The modes (and maybe register) will tell us whether we need to read additional data for this MOVE.
00001320                           452                  ;               d) 0010: (MOVE.L). Now read and store:
00001320                           453                  ;                           DESTINATION REGISTER: 0000 XXX0 0000 0000 (FILT_DEST_REG)
00001320                           454                  ;                           DESTINATION MODE:     0000 000X XX00 0000 (FILT_DEST_MODE)
00001320                           455                  ;                           SOURCE MODE:          0000 0000 00XX X000 (FILT_SCR_MODE)
00001320                           456                  ;                           SOURCE REGISTER:      0000 0000 0000 0XXX (FILT_SRC_REG)
00001320                           457                  ;                           The modes (and maybe register) will tell us whether we need to read additional data for this MOVE.
00001320                           458                  ;               e) 0100: Read the bits at 0000 XXXX 0000 0000 (need filter) Branch:
00001320                           459                  ;                   i.      0000: Read the bits at 0000 0000 XX00 0000 (need filter) Branch:
00001320                           460                  ;                               1. 11: MOVE from SR. (TODO)
00001320                           461                  ;                               2. (DEFAULT) NEGX. (the two bits are size) (TODO)
00001320                           462                  ;                   ii.     0100: Read the bits at 0000 0000 XX00 0000 (need filter) Branch:
00001320                           463                  ;                               1. 11 MOVE to CCR. (TODO)
00001320                           464                  ;                               2. (DEFAULT) NEG. (the two bits are size) (TODO)
00001320                           465                  ;                   iii.    0110: Read the bits at 0000 0000 XX00 0000 (need filter) Branch:
00001320                           466                  ;                               1. 11 MOVE to SR. (TODO)
00001320                           467                  ;                               2. (DEFAULT) NOT. (the two bits are size) (TODO)
00001320                           468                  ;                   iv.     0010: CLR. (TODO)
00001320                           469                  ;                    v.     1000: (EXT, NBCD, SWAP, PEA, MOVEM (dir 0)) (TODO)
00001320                           470                  ;                   vi.     1010: Check the bits at 0000 XX00 0000 0000 (need filter) Branch:
00001320                           471                  ;                           1. 11: check the bits at 0000 00XX XXXX XXXX (need filter) Branch:
00001320                           472                  ;                               a. 11 1100: ILLEGAL (TODO)
00001320                           473                  ;                               b. (default) TAS (TODO)
00001320                           474                  ;                           2. (default) TST (TODO)
00001320                           475                  ;                  vii.     1110: (TRAP, LINK, UNLK, MOVE USP, RESET, NOP, STOP, RTE, RTS, TRAPV, RTR, JSR, JMP) (TODO)
00001320                           476                  ;                 viii.     (DEFAULT): (MOVEM, LEA, CHK,) (TODO)    
00001320                           477                  ;               f) 0101: (ADDQ, SUBQ, Scc, DBcc): Read the bits at 0000 0000 XX00 0000 (need filter) Branch:
00001320                           478                  ;                    i. 11: Read the bit at 0000 000X 0000 0000 (need filter) Branch:
00001320                           479                  ;                           1. 0: ADDQ (TODO)
00001320                           480                  ;                           2. 1: SUBQ (TODO)
00001320                           481                  ;                   ii. (default) (bits are size) read the bits at 0000 00XX X000 (FILT_SRC_MODE). Branch:
00001320                           482                  ;                           1. 001: DBCC (TODO)
00001320                           483                  ;                           2. (default): Scc (TODO)
00001320                           484                  ;               g) 0110: Read the bit at 0000 XXXX 0000 0000 (need filter) Branch:
00001320                           485                  ;                    i. 0000: BRA (TODO)
00001320                           486                  ;                   ii. 0001: BSR (TODO)
00001320                           487                  ;                  iii. (default) Bcc (TODO)
00001320                           488                  ;               h) 0111: MOVEQ (TODO)
00001320                           489                  ;               i) 1000: (DIVU, DIVS, SBCD, OR) (TODO)
00001320                           490                  ;               j) 1001: (SUB, SUBX, SUBA) (TODO)
00001320                           491                  ;               k) 1011: (EOR, CMPM, CMP, CMPA) (TODO)
00001320                           492                  ;               l) 1100: (MULU, MULS, ABCD, EXG, AND) (TODO)
00001320                           493                  ;               m) 1101: (ADD, ADDX, ADDA) (TODO)
00001320                           494                  ;               n) 1110: (ASd, LSd, ROXd, ROd, ASd, LSd, ROXd, ROd) (TODO)
00001320                           495                  ;               o) (default) The code is invalid. Not yet sure what we do in this case.
00001320                           496                  ;   
00001320                           497                  ;   
00001320                           498                  ;
00001320                           499                  
00001320                           500                  ;TODO: Use AND operations with filters to create values which can be
00001320                           501                  ;      checked against constants to narrow down OPcodes.
00001320                           502                  
00001320                           503                  ;TODO: Since it will take a while to decode every possible OPcode, we
00001320                           504                  ;      should first have a default "Error" subroutine which the program
00001320                           505                  ;      branches to once all other possibilities have been ruled out.
00001320                           506  
00001320                           507  *------------------- Read current OPcode -------------------
00001320                           508  ; By this point, CURRENT_WORD should store a potential beginning of an instruction, so we should not increment A5.
00001320  6000 0028                509  READ_CURRENT_OP         BRA         CHECK_CONSTANTS
00001324                           510                          
00001324                           511    
00001324                           512  *------------------- Display current address we are reading -------------------
00001324  43F9 0000194F            513  DISPLAY_CURRENT_ADDRESS LEA         DOLLAR,A1       ; '$'
0000132A  103C 000E                514                          MOVE.B      #14,D0
0000132E  4E4F                     515                          TRAP        #15
00001330                           516                  
00001330  220C                     517                          MOVE.L      A4,D1           ; display the address the instruction was found at
00001332  143C 0010                518                          MOVE.B      #16,D2
00001336  103C 000F                519                          MOVE.B      #15,D0
0000133A  4E4F                     520                          TRAP        #15
0000133C                           521  
0000133C  43F9 0000194D            522                          LEA         SPACE,A1        ; ' '
00001342  103C 000E                523                          MOVE.B      #14,D0      
00001346  4E4F                     524                          TRAP        #15     
00001348                           525                          
00001348  4E75                     526                          RTS
0000134A                           527   
0000134A                           528  *------------------ Check current word for constants---------
0000134A                           529  ; By this point, the current word should store a potential beginning of an instruction.                   
0000134A  0C79 4E70 00001B96       530  CHECK_CONSTANTS         CMP         #RESET_CODE,(CURRENT_WORD)
00001352  6700 001E                531                          BEQ         RESET_FOUND
00001356  0C79 4E71 00001B96       532                          CMP         #NOP_CODE,(CURRENT_WORD)
0000135E  6700 0030                533                          BEQ         NOP_FOUND
00001362  0C79 4E72 00001B96       534                          CMP         #STOP_CODE,(CURRENT_WORD)
0000136A  6700 0042                535                          BEQ         STOP_FOUND
0000136E  6000 0042                536                          BRA         CHECK_NON_CONSTANTS     ;Once we rule out all the constants we know of, we check for non-constants.
00001372                           537  
00001372                           538  ; TODO: change the structure of these subroutines to be like the nice structure used in EA SRs.
00001372                           539                         
00001372  61B0                     540  RESET_FOUND             BSR         DISPLAY_CURRENT_ADDRESS
00001374                           541  
00001374  43F9 00001B3F            542                          LEA         RESET_MSG,A1    ; 'RESET'
0000137A  103C 000E                543                          MOVE.B      #14,D0
0000137E  4E4F                     544                          TRAP        #15
00001380                           545                          
00001380  43F9 0000194A            546                          LEA         RETURN,A1       ; (return)
00001386  103C 000E                547                          MOVE.B      #14,D0
0000138A  4E4F                     548                          TRAP        #15
0000138C                           549                 
0000138C  6000 FF64                550                          BRA         GO_TO_NEXT_OP   
00001390                           551   
00001390                           552  ; NOTE: this SR is temporary. Once we have the display buffer, it will work differently.                 
00001390  6192                     553  NOP_FOUND               BSR         DISPLAY_CURRENT_ADDRESS
00001392                           554  
00001392  43F9 00001B45            555                          LEA         NOP_MSG,A1    ; 'NOP'
00001398  103C 000E                556                          MOVE.B      #14,D0
0000139C  4E4F                     557                          TRAP        #15
0000139E                           558                          
0000139E  43F9 0000194A            559                          LEA         RETURN,A1     ; (return)
000013A4  103C 000E                560                          MOVE.B      #14,D0
000013A8  4E4F                     561                          TRAP        #15
000013AA                           562                 
000013AA  6000 FF46                563                          BRA         GO_TO_NEXT_OP   ; when we are done parsing and displaying the NOP instruction, go to the next OPcode.
000013AE                           564  
000013AE  4EF8 1004                565  STOP_FOUND              JMP         STOP  ;TODO: case for stop found. (NOTE that STOP instructions have additional data.)               
000013B2                           566  
000013B2                           567  ;TODO: add cases for rest of valid constant OPcodes here
000013B2                           568  
000013B2                           569  *----------------- Check current word for non-constants---------
000013B2                           570  ;NOTE: we currently know that CURRENT_WORD is not a constant by the time we reach this SR.
000013B2                           571  
000013B2  6100 000A                572  CHECK_NON_CONSTANTS     BSR         CHECK_MOVE
000013B6  6100 002C                573                          BSR         CHECK_MOVEQ
000013BA                           574                          ;BSR        CHECK_MOVEM
000013BA                           575                          ;BSR        CHECK_ADD
000013BA                           576                          ;BSR        CHECK_ADDA
000013BA                           577                          ;etc
000013BA  4EF8 1004                578                          JMP         STOP
000013BE                           579                          ;TODO: check for other instructions instead of stopping if it's not one of these.
000013BE                           580                          
000013BE                           581  *-----------------------Check current word for MOVE------------------------------------
000013BE  4243                     582  CHECK_MOVE              CLR         D3
000013C0  3639 00001B96            583                          MOVE.W      CURRENT_WORD,D3
000013C6  0243 F000                584                          ANDI.W      #FILT_NIB_1,D3
000013CA  B67C 1000                585                          CMP         #CONST_MOVE_B,D3
000013CE  6700 002A                586                          BEQ         MOVE_B_FOUND
000013D2  B67C 3000                587                          CMP         #CONST_MOVE_W,D3
000013D6  6700 0052                588                          BEQ         MOVE_W_FOUND
000013DA  B67C 2000                589                          CMP         #CONST_MOVE_L,D3
000013DE  6700 007A                590                          BEQ         MOVE_L_FOUND
000013E2  4E75                     591                          RTS 
000013E4                           592                          
000013E4                           593  *-----------------------Check current word for MOVEQ------------------------------------
000013E4                           594  *unlike MOVE, MOVEQ can only be long-sized.                       
000013E4  4243                     595  CHECK_MOVEQ             CLR         D3
000013E6  3639 00001B96            596                          MOVE.W      CURRENT_WORD,D3
000013EC  0243 F000                597                          ANDI.W      #FILT_NIB_1,D3
000013F0  B67C 7000                598                          CMP         #CONST_MOVEQ,D3
000013F4  6700 00D0                599                          BEQ         MOVEQ_FOUND
000013F8  4E75                     600                          RTS 
000013FA                           601   
000013FA                           602  *-----------------------MOVE-related Subroutines------------------------------------
000013FA                           603  
000013FA                           604  *-----------------------Cases for finding different MOVE OPcodes------------------------------------
000013FA                           605  *MOVE.B
000013FA  13FC 0000 00001B98       606  MOVE_B_FOUND            MOVE.B      #BYTE_SIZE,CURRENT_OP_SIZE
00001402  6100 FF20                607                          BSR         DISPLAY_CURRENT_ADDRESS
00001406  6100 0082                608                          BSR         PARSE_MOVE_DATA                           
0000140A                           609                         
0000140A  43F9 00001B53            610                          LEA         MOVE_B_MSG,A1      ; 'MOVE.B'
00001410  103C 000E                611                          MOVE.B      #14,D0
00001414  4E4F                     612                          TRAP        #15
00001416                           613                          
00001416  43F9 0000194D            614                          LEA         SPACE,A1           ; ' '
0000141C  103C 000E                615                          MOVE.B      #14,D0      
00001420  4E4F                     616                          TRAP        #15
00001422                           617                          
00001422  6100 0080                618                          BSR         DISPLAY_MOVE_DATA
00001426  6000 FECA                619                          BRA         GO_TO_NEXT_OP
0000142A                           620  
0000142A                           621  *MOVE.W                        
0000142A  13FC 0001 00001B98       622  MOVE_W_FOUND            MOVE.B      #WORD_SIZE,CURRENT_OP_SIZE
00001432  6100 FEF0                623                          BSR         DISPLAY_CURRENT_ADDRESS
00001436  6100 0052                624                          BSR         PARSE_MOVE_DATA       
0000143A                           625                          
0000143A  43F9 00001B5A            626                          LEA         MOVE_W_MSG,A1      ; 'MOVE.W'
00001440  103C 000E                627                          MOVE.B      #14,D0
00001444  4E4F                     628                          TRAP        #15
00001446                           629                          
00001446  43F9 0000194D            630                          LEA         SPACE,A1           ; ' '
0000144C  103C 000E                631                          MOVE.B      #14,D0      
00001450  4E4F                     632                          TRAP        #15
00001452                           633                          
00001452  6100 0050                634                          BSR         DISPLAY_MOVE_DATA
00001456  6000 FE9A                635                          BRA         GO_TO_NEXT_OP  
0000145A                           636  
0000145A                           637  *MOVE.L                        
0000145A  13FC 0002 00001B98       638  MOVE_L_FOUND            MOVE.B      #LONG_SIZE,CURRENT_OP_SIZE
00001462  6100 FEC0                639                          BSR         DISPLAY_CURRENT_ADDRESS
00001466  6100 0022                640                          BSR         PARSE_MOVE_DATA       
0000146A                           641                          
0000146A  43F9 00001B61            642                          LEA         MOVE_L_MSG,A1      ; 'MOVE.L'
00001470  103C 000E                643                          MOVE.B      #14,D0
00001474  4E4F                     644                          TRAP        #15
00001476                           645                          
00001476  43F9 0000194D            646                          LEA         SPACE,A1           ; ' '
0000147C  103C 000E                647                          MOVE.B      #14,D0      
00001480  4E4F                     648                          TRAP        #15
00001482                           649                          
00001482  6100 0020                650                          BSR         DISPLAY_MOVE_DATA
00001486  6000 FE6A                651                          BRA         GO_TO_NEXT_OP 
0000148A                           652                         
0000148A                           653  *-----------------------Parse data for any-sized MOVE instruction---------------------
0000148A                           654  *Note that the size of the MOVE is stored in CURRENT_OP_SIZE.
0000148A                           655  PARSE_MOVE_DATA         ; TODO: error checking 
0000148A                           656                          ;(maybe after reading the first 4 instruction parts, but before reading additional data)
0000148A                           657                          ;IMPORTANT: remember that different MOVE error are specific to different MOVE sizes.
0000148A                           658                          ; example: MOVE.B  A0,D3 is invalid. However, MOVE.W  A0,D3 is valid.
0000148A                           659                          ;
0000148A                           660                          ; possible errors:
0000148A                           661                          ;       CURRENT_DEST_MD = CONST_IMMEDIATE_REG (immediate data cannot be a destination)
0000148A                           662                          ;       CURRENT_SRC_MD  = CONST_ADDR_REG_MD   (byte is not a valid size for this move)
0000148A                           663                          ;       CURRENT_DEST_MD = CONST_ADDR_REG_MD   (byte is not a valid size, although we should be using MOVEA at this point, not MOVE.)
0000148A                           664                          ;       TODO: figure out other possible errors.
0000148A                           665                          
0000148A                           666                          ; after we confirm that there are no errors, we know that we can safely check for additional data and display the instruction.
0000148A                           667                          
0000148A                           668                          
0000148A                           669                          ; at this point, need to read more information (parsed by EA, probably)
0000148A                           670                          ; now that we have a move instruction, we set our EA variables accordingly:
0000148A  6100 00C8                671                          BSR         READ_DEST_REG      ; EA will set CURRENT_DEST_REG.
0000148E  6100 00E2                672                          BSR         READ_DEST_MODE     ; EA will set CURRENT_DEST_MD.
00001492  6100 00FA                673                          BSR         READ_SOURCE_MODE   ; EA will set CURRENT_SRC_MD.
00001496  6100 0112                674                          BSR         READ_SOURCE_REG    ; EA will set CURRENT_SRC_REG.
0000149A                           675                          
0000149A                           676                          ; need to check whether we need to read additional data before we start displaying the
0000149A                           677                          ; instruction (for instance, this is necessary for MOVE.B #10,D0).
0000149A  6100 0128                678                          BSR         READ_SOURCE_DATA   ; EA will set CURRENT_SOURCE_DATA if necessary.
0000149E  6100 015E                679                          BSR         READ_DEST_DATA     ; EA will set CURRENT_DEST_DATA if necessary. 
000014A2  4E75                     680                          RTS         
000014A4                           681  
000014A4  6100 0226                682  DISPLAY_MOVE_DATA       BSR         DISPLAY_SOURCE     ; Tell EA to parse and display the source. EX: (A1)   D3    #10   $1000 etc
000014A8                           683                          
000014A8  43F9 00001951            684                          LEA         COMMA,A1           ; ','
000014AE  103C 000E                685                          MOVE.B      #14,D0      
000014B2  4E4F                     686                          TRAP        #15
000014B4                           687                          
000014B4  6100 024C                688                          BSR         DISPLAY_DEST       ; Tell EA to parse and display the destination.
000014B8                           689                          
000014B8  43F9 0000194A            690                          LEA         RETURN,A1          ; (return)
000014BE  103C 000E                691                          MOVE.B      #14,D0
000014C2  4E4F                     692                          TRAP        #15
000014C4                           693  
000014C4  4E75                     694                          RTS        
000014C6                           695                           
000014C6                           696  *-----------------------MOVEQ-related Subroutines------------------------------------
000014C6                           697  
000014C6                           698  *-----------------------Case for finding MOVEQ------------------------------------
000014C6  13FC 0002 00001B98       699  MOVEQ_FOUND             MOVE.B      #LONG_SIZE,CURRENT_OP_SIZE
000014CE  6100 FE54                700                          BSR         DISPLAY_CURRENT_ADDRESS
000014D2  6100 0022                701                          BSR         PARSE_MOVEQ_DATA       
000014D6                           702                          
000014D6  43F9 00001B68            703                          LEA         MOVEQ_MSG,A1      ; 'MOVEQ'
000014DC  103C 000E                704                          MOVE.B      #14,D0
000014E0  4E4F                     705                          TRAP        #15
000014E2                           706                          
000014E2  43F9 0000194D            707                          LEA         SPACE,A1           ; ' '
000014E8  103C 000E                708                          MOVE.B      #14,D0      
000014EC  4E4F                     709                          TRAP        #15
000014EE                           710                          
000014EE  6100 0028                711                          BSR         DISPLAY_MOVEQ_DATA
000014F2  6000 FDFE                712                          BRA         GO_TO_NEXT_OP  
000014F6                           713  
000014F6                           714  PARSE_MOVEQ_DATA        ;TODO: check that 0000 000X 0000 0000 equals zero. If not, error.
000014F6                           715                          
000014F6  6100 005C                716                          BSR         READ_DEST_REG                       ; EA will set CURRENT_DEST_REG.
000014FA  13FC 0000 00001B9D       717                          MOVE.B      #CONST_DATA_REG_MD,CURRENT_DEST_MD  ; data register is the only allowed destination for MOVEQ.
00001502  6100 0036                718                          BSR         READ_MOVEQ_DATA                     ; 0000 0000 XXXX XXXX will set CURRENT_SOURCE_DATA (I think.)
00001506                           719                          
00001506  13FC 0007 00001B9B       720                          MOVE.B      #CONST_ADDR_MISC_MD,CURRENT_SRC_MD
0000150E  13FC 0004 00001B9C       721                          MOVE.B      #CONST_IMMEDIATE_REG,CURRENT_SRC_REG
00001516                           722                          
00001516  4E75                     723                          RTS 
00001518                           724  
00001518  6100 01B2                725  DISPLAY_MOVEQ_DATA      BSR         DISPLAY_SOURCE     ; Tell EA to parse and display the source. 
0000151C                           726                          
0000151C  43F9 00001951            727                          LEA         COMMA,A1           ; ','
00001522  103C 000E                728                          MOVE.B      #14,D0      
00001526  4E4F                     729                          TRAP        #15
00001528                           730                          
00001528  6100 01D8                731                          BSR         DISPLAY_DEST       ; Tell EA to parse and display the destination.
0000152C                           732                          
0000152C  43F9 0000194A            733                          LEA         RETURN,A1          ; (return)
00001532  103C 000E                734                          MOVE.B      #14,D0
00001536  4E4F                     735                          TRAP        #15
00001538                           736  
00001538  4E75                     737                          RTS        
0000153A                           738  
0000153A                           739  ;NOTE: this SR is stored here and not in EA because it is specific to MOVEQ.
0000153A  4244                     740  READ_MOVEQ_DATA         CLR         D4
0000153C  4279 00001BA4            741                          CLR         CURRENT_SRC_DATA
00001542  3839 00001B96            742                          MOVE.W      CURRENT_WORD,D4
00001548  0244 00FF                743                          ANDI.W      #FILT_MOVEQ_DATA,D4        ; turn D4 into 0000 0000 XXXX XXXX (no shift necessary)
0000154C  33C4 00001BA4            744                          MOVE.W      D4,CURRENT_SRC_DATA
00001552  4E75                     745                          RTS
00001554                           746   
00001554                           747  *--------------------------ADD cases-------------------------------------------------------------                      
00001554                           748    ; TODO
00001554                           749    ; also TODO: SUB, MULU, MULS, DIVU, DIVS, OR, AND, EOR, NOT, CMP, BRA, JMP, BSR, LSd, ROd, etc.
00001554                           750    ; (see huge comment block at the top of OPcode section for tentative OPcode parsing implementation plan.)
00001554                           751   
00001554                           752  *###################### END OPCODE ##################################
00001554                           753  *###################### BEGIN EA ##################################
00001554                           754  *** EA Subroutines are kept here ***
00001554                           755  *----------------------Check the destination register of the current word.-------------
00001554  4244                     756  READ_DEST_REG           CLR         D4
00001556  4239 00001B9E            757                          CLR.B       CURRENT_DEST_REG
0000155C  3839 00001B96            758                          MOVE.W      CURRENT_WORD,D4
00001562  0244 0E00                759                          ANDI.W      #FILT_DEST_REG,D4       ; turn D4 into 0000 XXX0 0000 0000
00001566  E04C                     760                          LSR.W       #8,D4                   ; turn D4 into 0000 0000 0000 0XXX
00001568  E24C                     761                          LSR.W       #1,D4                   ; 9 would be invalid, so we shift 8, then 1
0000156A  13C4 00001B9E            762                          MOVE.B      D4,CURRENT_DEST_REG
00001570  4E75                     763                          RTS
00001572                           764  
00001572                           765  *----------------------Check the destination mode of the current word.-------------
00001572                           766  *(assuming the destination is where it would be in MOVE).
00001572  4244                     767  READ_DEST_MODE          CLR         D4
00001574  4239 00001B9D            768                          CLR.B       CURRENT_DEST_MD
0000157A  3839 00001B96            769                          MOVE.W      CURRENT_WORD,D4
00001580  0244 01C0                770                          ANDI.W      #FILT_DEST_MD,D4        ; turn D4 into 0000 000X XX00 0000
00001584  EC4C                     771                          LSR.W       #6,D4                   ; turn D4 into 0000 0000 0000 0XXX
00001586  13C4 00001B9D            772                          MOVE.B      D4,CURRENT_DEST_MD
0000158C  4E75                     773                          RTS
0000158E                           774  
0000158E                           775  ;By this point, CURRENT WORD holds the first 16 bits of an instruction we are looking at.
0000158E                           776  ;(we should already know the OPcode by this point, so this will be called by various OPcode subroutines.)
0000158E                           777  *---------------------- Check the source mode of the current word.--------------------
0000158E                           778  *(assuming the source is where it would be in MOVE).
0000158E  4244                     779  READ_SOURCE_MODE        CLR         D4
00001590  4239 00001B9B            780                          CLR.B       CURRENT_SRC_MD
00001596  3839 00001B96            781                          MOVE.W      CURRENT_WORD,D4
0000159C  0244 0038                782                          ANDI.W      #FILT_SRC_MD,D4                 ; turn source mode into 0000 0000 00XX X000
000015A0  E64C                     783                          LSR.W       #3,D4                           ; turn source mode into 0000 0000 0000 0XXX
000015A2  13C4 00001B9B            784                          MOVE.B      D4,CURRENT_SRC_MD
000015A8  4E75                     785                          RTS
000015AA                           786                          
000015AA                           787  *----------------------Check the source register of the current word.-----------------
000015AA  4244                     788  READ_SOURCE_REG         CLR         D4
000015AC  4239 00001B9C            789                          CLR.B       CURRENT_SRC_REG
000015B2  3839 00001B96            790                          MOVE.W      CURRENT_WORD,D4
000015B8  0244 0007                791                          ANDI.W      #FILT_SRC_REG,D4        ; turn D4 into 0000 0000 0000 0XXX. (no need for LSR in this case.)
000015BC  13C4 00001B9C            792                          MOVE.B      D4,CURRENT_SRC_REG
000015C2  4E75                     793                          RTS
000015C4                           794  *--------TODO: READ_OP_SIZE---------
000015C4                           795                         
000015C4                           796  *----------------------Read additional source data associated with the current word (if necessary).----------------- 
000015C4                           797  *This needs to postincrement A5 as necessary.
000015C4  4279 00001BA4            798  READ_SOURCE_DATA        CLR         CURRENT_SRC_DATA
000015CA  4279 00001BA0            799                          CLR         CURRENT_DATA
000015D0  0C39 0007 00001B9B       800                          CMP.B       #CONST_ADDR_MISC_MD,CURRENT_SRC_MD ; check the source mode
000015D8  6700 0004                801                          BEQ         CONFIRM_READ_SRC_DATA              ; see if we have a source mode that requires additional data.               
000015DC  4E75                     802                          RTS
000015DE                           803                          
000015DE  4239 00001B9A            804  CONFIRM_READ_SRC_DATA   CLR.B       CURRENT_REG
000015E4  13F9 00001B9C 00001B9A   805                          MOVE.B      CURRENT_SRC_REG,CURRENT_REG
000015EE  6100 0048                806                          BSR         CONFIRM_READ_DATA
000015F2  23F9 00001BA0 00001BA4   807                          MOVE.L      CURRENT_DATA,CURRENT_SRC_DATA
000015FC  4E75                     808                          RTS
000015FE                           809   
000015FE                           810  *----------------------Read additional destination data associated with the current word (if necessary).----------------- 
000015FE                           811  *This needs to postincrement A5 as necessary.                       
000015FE  4279 00001BA8            812  READ_DEST_DATA          CLR         CURRENT_DEST_DATA
00001604  4279 00001BA0            813                          CLR         CURRENT_DATA
0000160A  0C39 0007 00001B9D       814                          CMP.B       #CONST_ADDR_MISC_MD,CURRENT_DEST_MD  ; check the destination mode.
00001612  6700 0004                815                          BEQ         CONFIRM_READ_DEST_DATA               ; see if we have a destination mode that requires additional data.                  
00001616  4E75                     816                          RTS
00001618                           817                                              
00001618  4239 00001B9A            818  CONFIRM_READ_DEST_DATA  CLR.B       CURRENT_REG
0000161E  13F9 00001B9E 00001B9A   819                          MOVE.B      CURRENT_DEST_REG,CURRENT_REG
00001628  6100 000E                820                          BSR         CONFIRM_READ_DATA
0000162C  23F9 00001BA0 00001BA8   821                          MOVE.L      CURRENT_DATA,CURRENT_DEST_DATA
00001636  4E75                     822                          RTS
00001638                           823  
00001638                           824  *-----------------------Read some additional data.----------------------------------------------------------
00001638                           825        ; This same subroutine is used for reading source and destination data.
00001638                           826        ; By this point, CURRENT_REG holds whatever register we currently care about. (could also use CURRENT_REG)         
00001638  0C39 0002 00001B9A       827  CONFIRM_READ_DATA       CMP.B       #CONST_COUNTR_DISPLC_REG,CURRENT_REG      ; see if we are reading counter w/ displacement
00001640  6700 0034                828                          BEQ         READ_COUNTR_DISPLC_DATA
00001644                           829                     
00001644  0C39 0003 00001B9A       830                          CMP.B       #CONST_COUNTR_INDEX_REG,CURRENT_REG       ; see if we are reading counter w/ index
0000164C  6700 002A                831                          BEQ         READ_COUNTR_INDEX_DATA
00001650                           832                          
00001650  0C39 0000 00001B9A       833                          CMP.B       #CONST_ABS_SHORT_REG,CURRENT_REG          ; see if we are reading absolute short address
00001658  6700 0020                834                          BEQ         READ_ABS_SHORT_DATA
0000165C                           835                          
0000165C  0C39 0001 00001B9A       836                          CMP.B       #CONST_ABS_LONG_REG,CURRENT_REG           ; see if we are reading absolute long address
00001664  6700 001C                837                          BEQ         READ_ABS_LONG_DATA 
00001668                           838                          
00001668  0C39 0004 00001B9A       839                          CMP.B       #CONST_IMMEDIATE_REG,CURRENT_REG          ; see if we are reading immediate data
00001670  6700 0018                840                          BEQ         READ_IMMEDIATE_DATA
00001674                           841       
00001674  4E75                     842                          RTS
00001676                           843                          
00001676                           844  ; TODO: each of these SRs should increment A5 by the proper amount while also storing the correct data in CURRENT_DATA.
00001676  4E75                     845  READ_COUNTR_DISPLC_DATA RTS ; TODO: read data for counter w/ displacement (d16,PC)
00001678                           846  
00001678  4E75                     847  READ_COUNTR_INDEX_DATA  RTS ; TODO: read data for counter w/ index        (d16,PC,Xn)
0000167A                           848  
0000167A                           849  *-----------------------Read additional absolute word address---------------------------
0000167A  33DD 00001BA0            850  READ_ABS_SHORT_DATA     MOVE.W      (A5)+,CURRENT_DATA ; read data for absolute short address  (xxx).W
00001680  4E75                     851                          RTS
00001682                           852                          
00001682                           853  *-----------------------Read additional absolute long address---------------------------
00001682  23DD 00001BA0            854  READ_ABS_LONG_DATA      MOVE.L      (A5)+,CURRENT_DATA ; read data for absolute long address   (xxx).L
00001688  4E75                     855                          RTS 
0000168A                           856  
0000168A                           857  *-----------------------Read additional immediate data---------------------------
0000168A  0C39 0000 00001B98       858  READ_IMMEDIATE_DATA     CMP.B       #BYTE_SIZE,CURRENT_OP_SIZE   ; see if we are reading immediate byte data
00001692  6700 001C                859                          BEQ         READ_IMMEDIATE_DATA_W
00001696                           860                          
00001696  0C39 0001 00001B98       861                          CMP.B       #WORD_SIZE,CURRENT_OP_SIZE   ; see if we are reading immediate word data
0000169E  6700 0010                862                          BEQ         READ_IMMEDIATE_DATA_W
000016A2                           863                          
000016A2  0C39 0002 00001B98       864                          CMP.B       #LONG_SIZE,CURRENT_OP_SIZE   ; see if we are reading immediate long data
000016AA  6700 0012                865                          BEQ         READ_IMMEDIATE_DATA_L
000016AE                           866                          ;TODO: error case goes here
000016AE  4E75                     867                          RTS
000016B0                           868  
000016B0  4279 00001BA0            869  READ_IMMEDIATE_DATA_W   CLR         CURRENT_DATA
000016B6  33DD 00001BA0            870                          MOVE.W      (A5)+,CURRENT_DATA
000016BC  4E75                     871                          RTS
000016BE                           872                          
000016BE  4279 00001BA0            873  READ_IMMEDIATE_DATA_L   CLR         CURRENT_DATA
000016C4  23DD 00001BA0            874                          MOVE.L      (A5)+,CURRENT_DATA
000016CA  4E75                     875                          RTS
000016CC                           876                          
000016CC                           877  *----------------------Display the source for the current instruction.-----------------
000016CC                           878  *by this point, error checking should already be done and CURRENT_SRC_MD and CURRENT_SRC_REG should have the data we need.
000016CC  4239 00001B99            879  DISPLAY_SOURCE          CLR.B       CURRENT_MD
000016D2  4239 00001B9A            880                          CLR.B       CURRENT_REG
000016D8  42B9 00001BA0            881                          CLR.L       CURRENT_DATA
000016DE                           882                          
000016DE  13F9 00001B9B 00001B99   883                          MOVE.B      CURRENT_SRC_MD,CURRENT_MD
000016E8  13F9 00001B9C 00001B9A   884                          MOVE.B      CURRENT_SRC_REG,CURRENT_REG    
000016F2  23F9 00001BA4 00001BA0   885                          MOVE.L      CURRENT_SRC_DATA,CURRENT_DATA
000016FC  6100 003A                886                          BSR         CHECK_ADDRESSING_MODES   
00001700  4E75                     887                          RTS  
00001702                           888                          
00001702                           889  *----------------------Display the destination for the current instruction.-----------------
00001702                           890  *by this point, error checking should already be done and CURRENT_DEST_MD and CURRENT_DEST_REG should have the data we need.
00001702  4239 00001B99            891  DISPLAY_DEST            CLR.B       CURRENT_MD
00001708  4239 00001B9A            892                          CLR.B       CURRENT_REG
0000170E  42B9 00001BA0            893                          CLR.L       CURRENT_DATA
00001714                           894                          
00001714  13F9 00001B9D 00001B99   895                          MOVE.B      CURRENT_DEST_MD,CURRENT_MD
0000171E  13F9 00001B9E 00001B9A   896                          MOVE.B      CURRENT_DEST_REG,CURRENT_REG    
00001728  23F9 00001BA8 00001BA0   897                          MOVE.L      CURRENT_DEST_DATA,CURRENT_DATA
00001732  6100 0004                898                          BSR         CHECK_ADDRESSING_MODES     
00001736  4E75                     899                          RTS  
00001738                           900                          
00001738                           901  
00001738                           902                          
00001738                           903  *-----------------------Mode checks (for displaying)---------
00001738                           904  *these do not care whether the mode is for source or destination.
00001738  0C39 0000 00001B99       905  CHECK_ADDRESSING_MODES  CMP.B       #CONST_DATA_REG_MD,CURRENT_MD   ; check for CURRENT_MD = ...0000
00001740  6700 0058                906                          BEQ         DISPLAY_DATA_REG
00001744  0C39 0001 00001B99       907                          CMP.B       #CONST_ADDR_REG_MD,CURRENT_MD    ; check for CURRENT_MD = ...0001
0000174C  6700 006C                908                          BEQ         DISPLAY_ADDR_REG
00001750  0C39 0002 00001B99       909                          CMP.B       #CONST_ADDR_IND_MD,CURRENT_MD    ; check for CURRENT_MD = ...0010
00001758  6700 0080                910                          BEQ         DISPLAY_ADDR_IND
0000175C  0C39 0003 00001B99       911                          CMP.B       #CONST_ADDR_INCR_MD,CURRENT_MD   ; check for CURRENT_MD = ...0011
00001764  6700 00AC                912                          BEQ         DISPLAY_ADDR_INCR
00001768  0C39 0004 00001B99       913                          CMP.B       #CONST_ADDR_DECR_MD,CURRENT_MD   ; check for CURRENT_MD = ...0100
00001770  6700 00E4                914                          BEQ         DISPLAY_ADDR_DECR
00001774  0C39 0005 00001B99       915                          CMP.B       #CONST_ADDR_DISPLC_MD,CURRENT_MD ; check for CURRENT_MD = ...0101
0000177C  6700 011C                916                          BEQ         DISPLAY_ADDR_DISPLC
00001780  0C39 0006 00001B99       917                          CMP.B       #CONST_ADDR_INDEX_MD,CURRENT_MD  ; check for CURRENT_MD = ...0110
00001788  6700 0112                918                          BEQ         DISPLAY_ADDR_INDEX
0000178C  0C39 0007 00001B99       919                          CMP.B       #CONST_ADDR_MISC_MD,CURRENT_MD   ; check for CURRENT_MD = ...0111
00001794  6700 0108                920                          BEQ         CHECK_MISC_ADDRESSINGS
00001798                           921                          ;TODO: error cases? 
00001798  4E75                     922                          RTS
0000179A                           923  
0000179A                           924  ; case for displaying data register.          
0000179A  43F9 00001B6E            925  DISPLAY_DATA_REG        LEA         MSG_D,A1               ; print out 'D' (later, send this to dislpay buffer)
000017A0  103C 000E                926                          MOVE.B      #14,D0
000017A4  4E4F                     927                          TRAP        #15
000017A6                           928                          
000017A6  4241                     929                          CLR         D1
000017A8  1239 00001B9A            930                          MOVE.B      (CURRENT_REG),D1      ; print out the number of the data register.
000017AE  143C 0010                931                          MOVE.B      #16,D2
000017B2  103C 000F                932                          MOVE.B      #15,D0
000017B6  4E4F                     933                          TRAP        #15
000017B8                           934                          
000017B8  4E75                     935                          RTS
000017BA                           936  
000017BA                           937  ; case for displaying address register. 
000017BA  43F9 00001B70            938  DISPLAY_ADDR_REG        LEA         MSG_A,A1               ; print out 'A'
000017C0  103C 000E                939                          MOVE.B      #14,D0
000017C4  4E4F                     940                          TRAP        #15
000017C6                           941                          
000017C6  4241                     942                          CLR         D1
000017C8  1239 00001B9A            943                          MOVE.B      (CURRENT_REG),D1       ; print out the number of the data register.
000017CE  143C 0010                944                          MOVE.B      #16,D2
000017D2  103C 000F                945                          MOVE.B      #15,D0
000017D6  4E4F                     946                          TRAP        #15
000017D8                           947                          
000017D8  4E75                     948                          RTS
000017DA                           949  
000017DA                           950  ; case for displaying address register indirect.                        
000017DA  43F9 00001955            951  DISPLAY_ADDR_IND        LEA         OPEN_PARENS,A1         ; print out '(' (later, send this to dislpay buffer)
000017E0  103C 000E                952                          MOVE.B      #14,D0
000017E4  4E4F                     953                          TRAP        #15
000017E6                           954                          
000017E6  43F9 00001B70            955                          LEA         MSG_A,A1               ; print out 'A'
000017EC  103C 000E                956                          MOVE.B      #14,D0
000017F0  4E4F                     957                          TRAP        #15
000017F2                           958                          
000017F2  4241                     959                          CLR         D1
000017F4  1239 00001B9A            960                          MOVE.B      (CURRENT_REG),D1      ; print out the number of the data register.
000017FA  143C 0010                961                          MOVE.B      #16,D2
000017FE  103C 000F                962                          MOVE.B      #15,D0
00001802  4E4F                     963                          TRAP        #15
00001804                           964                          
00001804  43F9 00001957            965                          LEA         CLOSE_PARENS,A1       ; print out ')'
0000180A  103C 000E                966                          MOVE.B      #14,D0
0000180E  4E4F                     967                          TRAP        #15
00001810                           968                          
00001810  4E75                     969                          RTS
00001812                           970  
00001812                           971  ; case for displaying address indirect postincrement.
00001812  43F9 00001955            972  DISPLAY_ADDR_INCR       LEA         OPEN_PARENS,A1        ; print out '(' (later, send this to dislpay buffer)
00001818  103C 000E                973                          MOVE.B      #14,D0
0000181C  4E4F                     974                          TRAP        #15
0000181E                           975                          
0000181E  43F9 00001B70            976                          LEA         MSG_A,A1              ; print out 'A'
00001824  103C 000E                977                          MOVE.B      #14,D0
00001828  4E4F                     978                          TRAP        #15
0000182A                           979                          
0000182A  4241                     980                          CLR         D1
0000182C  1239 00001B9A            981                          MOVE.B      (CURRENT_REG),D1      ; print out the number of the data register.
00001832  143C 0010                982                          MOVE.B      #16,D2
00001836  103C 000F                983                          MOVE.B      #15,D0
0000183A  4E4F                     984                          TRAP        #15
0000183C                           985                          
0000183C  43F9 00001957            986                          LEA         CLOSE_PARENS,A1       ; print out ')'
00001842  103C 000E                987                          MOVE.B      #14,D0
00001846  4E4F                     988                          TRAP        #15
00001848                           989                          
00001848  43F9 00001959            990                          LEA         PLUS,A1               ; print out '+'
0000184E  103C 000E                991                          MOVE.B      #14,D0
00001852  4E4F                     992                          TRAP        #15
00001854                           993                          
00001854  4E75                     994                          RTS
00001856                           995                          
00001856                           996  ; case for displaying address indirect preedecrement mode.
00001856  43F9 0000195B            997  DISPLAY_ADDR_DECR       LEA         MINUS,A1               ; print out '-'
0000185C  103C 000E                998                          MOVE.B      #14,D0
00001860  4E4F                     999                          TRAP        #15                                           
00001862                          1000  
00001862  43F9 00001955           1001                          LEA         OPEN_PARENS,A1        ; print out '(' (later, send this to dislpay buffer)
00001868  103C 000E               1002                          MOVE.B      #14,D0
0000186C  4E4F                    1003                          TRAP        #15
0000186E                          1004                          
0000186E  43F9 00001B70           1005                          LEA         MSG_A,A1              ; print out 'A'
00001874  103C 000E               1006                          MOVE.B      #14,D0
00001878  4E4F                    1007                          TRAP        #15
0000187A                          1008                          
0000187A  4241                    1009                          CLR         D1
0000187C  1239 00001B9A           1010                          MOVE.B      (CURRENT_REG),D1      ; print out the number of the data register.
00001882  143C 0010               1011                          MOVE.B      #16,D2
00001886  103C 000F               1012                          MOVE.B      #15,D0
0000188A  4E4F                    1013                          TRAP        #15
0000188C                          1014                          
0000188C  43F9 00001957           1015                          LEA         CLOSE_PARENS,A1       ; print out ')'
00001892  103C 000E               1016                          MOVE.B      #14,D0
00001896  4E4F                    1017                          TRAP        #15
00001898                          1018                          
00001898  4E75                    1019                          RTS     
0000189A                          1020  
0000189A                          1021  DISPLAY_ADDR_DISPLC     ;TODO: case for source mode is address with displacement mode.
0000189A  4E75                    1022                          RTS    
0000189C                          1023  
0000189C                          1024  DISPLAY_ADDR_INDEX      ;TODO: case for source mode is address with index mode.
0000189C  4E75                    1025                          RTS 
0000189E                          1026  
0000189E                          1027  *-----------------------Register checks (for displaying only)---------
0000189E                          1028  *these do not care whether the register is for source or destination.
0000189E                          1029  *not for cases where reg is simply a number (like D5, A5, (A5), etc),
0000189E                          1030  *only for miscellaneous addressings where mode is 111.                        
0000189E  0C39 0002 00001B9A      1031  CHECK_MISC_ADDRESSINGS  CMP.B       #CONST_COUNTR_DISPLC_REG,CURRENT_REG
000018A6  6700 0034               1032                          BEQ         DISPLAY_COUNTR_DISPLC
000018AA                          1033                          
000018AA  0C39 0003 00001B9A      1034                          CMP.B       #CONST_COUNTR_INDEX_REG,CURRENT_REG
000018B2  6700 002A               1035                          BEQ         DISPLAY_COUNTR_INDEX
000018B6                          1036                          
000018B6  0C39 0000 00001B9A      1037                          CMP.B       #CONST_ABS_SHORT_REG,CURRENT_REG
000018BE  6700 0020               1038                          BEQ         DISPLAY_ABS_SHORT
000018C2                          1039                          
000018C2  0C39 0001 00001B9A      1040                          CMP.B       #CONST_ABS_LONG_REG,CURRENT_REG
000018CA  6700 0034               1041                          BEQ         DISPLAY_ABS_LONG
000018CE                          1042                          
000018CE  0C39 0004 00001B9A      1043                          CMP.B       #CONST_IMMEDIATE_REG,CURRENT_REG
000018D6  6700 0048               1044                          BEQ         DISPLAY_IMMEDIATE
000018DA                          1045                          
000018DA                          1046                          ; TODO: error case?
000018DA                          1047                          
000018DA  4E75                    1048                          RTS
000018DC                          1049                          
000018DC  4E75                    1050  DISPLAY_COUNTR_DISPLC   RTS         ;TODO   
000018DE                          1051  
000018DE  4E75                    1052  DISPLAY_COUNTR_INDEX    RTS         ;TODO   
000018E0                          1053  
000018E0  43F9 0000194F           1054  DISPLAY_ABS_SHORT       LEA         DOLLAR,A1             ; print out '$'. 
000018E6  103C 000E               1055                          MOVE.B      #14,D0
000018EA  4E4F                    1056                          TRAP        #15
000018EC                          1057  
000018EC  4241                    1058                          CLR         D1
000018EE  3239 00001BA0           1059                          MOVE.W      (CURRENT_DATA),D1     ; print out the absolute short address we are concerned with in hex. 
000018F4  143C 0010               1060                          MOVE.B      #16,D2
000018F8  103C 000F               1061                          MOVE.B      #15,D0
000018FC  4E4F                    1062                          TRAP        #15
000018FE                          1063                          
000018FE  4E75                    1064                          RTS 
00001900                          1065  
00001900  43F9 0000194F           1066  DISPLAY_ABS_LONG        LEA         DOLLAR,A1             ; print out '$'. 
00001906  103C 000E               1067                          MOVE.B      #14,D0
0000190A  4E4F                    1068                          TRAP        #15
0000190C                          1069  
0000190C  4241                    1070                          CLR         D1
0000190E  2239 00001BA0           1071                          MOVE.L      (CURRENT_DATA),D1     ; print out the absolute long address we are concerned with in hex. 
00001914  143C 0010               1072                          MOVE.B      #16,D2
00001918  103C 000F               1073                          MOVE.B      #15,D0
0000191C  4E4F                    1074                          TRAP        #15
0000191E                          1075                          
0000191E  4E75                    1076                          RTS 
00001920                          1077  
00001920  43F9 00001953           1078  DISPLAY_IMMEDIATE       LEA         HASH,A1               ; print out '#'. (NOTE: should send this to display buffer instead.)
00001926  103C 000E               1079                          MOVE.B      #14,D0
0000192A  4E4F                    1080                          TRAP        #15
0000192C                          1081                          
0000192C  43F9 0000194F           1082                          LEA         DOLLAR,A1             ; print out '$'. (this saves time since we can more easily find the hex value of the immediate data.)
00001932  103C 000E               1083                          MOVE.B      #14,D0
00001936  4E4F                    1084                          TRAP        #15
00001938                          1085                          
00001938  3239 00001BA0           1086                          MOVE.W      (CURRENT_DATA),D1     ; print out the immediate data we are concerned with in hex. 
0000193E  143C 0010               1087                          MOVE.B      #16,D2
00001942  103C 000F               1088                          MOVE.B      #15,D0
00001946  4E4F                    1089                          TRAP        #15
00001948                          1090                          
00001948  4E75                    1091                          RTS
0000194A                          1092                          
0000194A                          1093  *###################### END EA ##################################
0000194A                          1094  *############# BEGIN VARIABLES/CONSTANTS #########################
0000194A                          1095  *** Variables and Constants are kept here ***
0000194A                          1096  
0000194A                          1097  *output characters
0000194A  =0000000D               1098  CR                      EQU         $0D
0000194A  =0000000A               1099  LF                      EQU         $0A
0000194A= 0D 0A 00                1100  RETURN                  DC.B        CR,LF,0
0000194D= 20 00                   1101  SPACE                   DC.B        ' ',0
0000194F= 24 00                   1102  DOLLAR                  DC.B        '$',0
00001951= 2C 00                   1103  COMMA                   DC.B        ',',0
00001953= 23 00                   1104  HASH                    DC.B        '#',0
00001955= 28 00                   1105  OPEN_PARENS             DC.B        '(',0
00001957= 29 00                   1106  CLOSE_PARENS            DC.B        ')',0
00001959= 2B 00                   1107  PLUS                    DC.B        '+',0
0000195B= 2D 00                   1108  MINUS                   DC.B        '-',0
0000195D                          1109  
0000195D                          1110  *output messages
0000195D                          1111      ;TODO: consider also giving the user the range of valid start/end addresses
0000195D= 50 6C 65 61 73 65 ...   1112  START_ADDR_MSG          DC.B        'Please enter a starting hex address to read from.',CR,LF,0
00001991= 50 6C 65 61 73 65 ...   1113  END_ADDR_MSG            DC.B        'Please enter an ending hex address to read from.',CR,LF,0
000019C4                          1114  
000019C4= 4E 6F 74 20 61 20 ...   1115  INVALID_LEN_MSG         DC.B        'Not a valid length for input address.',CR,LF
000019EB= 50 6C 65 61 73 65 ...   1116                          DC.B        'Please enter a valid-length address.',CR,LF,0
00001A12= 4E 6F 74 20 61 20 ...   1117  INVALID_ADDR_MSG        DC.B        'Not a valid address.',CR,LF
00001A28= 50 6C 65 61 73 65 ...   1118                          DC.B        'Please enter a valid address.',CR,LF,0
00001A48= 4E 6F 74 20 61 20 ...   1119  INVALID_END_ADDR_MSG    DC.B        'Not a valid end address.',CR,LF
00001A62= 50 6C 65 61 73 65 ...   1120                          DC.B        'Please enter an end address after the start address.',CR,LF,0
00001A99                          1121                        
00001A99= 4E 6F 74 20 61 20 ...   1122  INVALID_ADDR_L_MSG      DC.B        'Not a valid address (too low).',CR,LF
00001AB9= 50 6C 65 61 73 65 ...   1123                          DC.B        'Please enter a valid address.',CR,LF,0
00001AD9                          1124                          
00001AD9= 4E 6F 74 20 61 20 ...   1125  INVALID_ADDR_H_MSG      DC.B        'Not a valid address (too high).',CR,LF
00001AFA= 50 6C 65 61 73 65 ...   1126                          DC.B        'Please enter a valid address.',CR,LF,0
00001B1A                          1127                          
00001B1A= 44 6F 6E 65 20 72 ...   1128  DONE_READING_MSG        DC.B        'Done reading the program.',CR,LF,0
00001B36                          1129  
00001B36                          1130  *output instruction names (OPcodes)
00001B36                          1131      ;sizes
00001B36= 2E 42 00                1132  BYTE_SIZE_MSG           DC.B        '.B',0
00001B39= 2E 57 00                1133  WORD_SIZE_MSG           DC.B        '.W',0
00001B3C= 2E 4C 00                1134  LONG_SIZE_MSG           DC.B        '.L',0
00001B3F                          1135  
00001B3F                          1136      ;constants
00001B3F= 52 45 53 45 54 00       1137  RESET_MSG               DC.B        'RESET',0
00001B45= 4E 4F 50 00             1138  NOP_MSG                 DC.B        'NOP',0
00001B49= 53 54 4F 50 00          1139  STOP_MSG                DC.B        'STOP',0
00001B4E                          1140      ;moves
00001B4E= 4D 4F 56 45 00          1141  MOVE_MSG                DC.B        'MOVE',0
00001B53= 4D 4F 56 45 2E 42 00    1142  MOVE_B_MSG              DC.B        'MOVE.B',0
00001B5A= 4D 4F 56 45 2E 57 00    1143  MOVE_W_MSG              DC.B        'MOVE.W',0
00001B61= 4D 4F 56 45 2E 4C 00    1144  MOVE_L_MSG              DC.B        'MOVE.L',0
00001B68                          1145  
00001B68= 4D 4F 56 45 51 00       1146  MOVEQ_MSG               DC.B        'MOVEQ',0
00001B6E                          1147  
00001B6E                          1148  *other output instruction message constants
00001B6E= 44 00                   1149  MSG_D                   DC.B        'D',0
00001B70= 41 00                   1150  MSG_A                   DC.B        'A',0
00001B72                          1151  
00001B72                          1152  *storage locations for input
00001B72                          1153  START_ADDR_IN           DS.B        20
00001B86                          1154  
00001B86                          1155  *other I/O-related variables/constants
00001B86  =00000001               1156  INPUTTING_START         SET         1 ;if 1, we are inputting start address. If 0, we are inputting end address.
00001B86                          1157  OPCODE_BUFFER           DS.L        1 ; can hold at most 4 characters
00001B8A                          1158  SIZE_BUFFER             DS.W        1 ;cand hold at most 2 characters
00001B8C                          1159  DISPLAY_BUFFER          DS.W        5
00001B96                          1160  
00001B96                          1161  *EA/OPcode parsed instruction variables/constants
00001B96                          1162  CURRENT_WORD            DS.W        1 ; current first 16 bits of an instruction.
00001B98                          1163  CURRENT_OP_SIZE         DS.B        1 ; current operation size. Byte = 01, Word = 11, Long = 10
00001B99                          1164  
00001B99                          1165  CURRENT_MD              DS.B        1 ; current mode we are concerened with (ex: 000 for data register mode.)
00001B9A                          1166  CURRENT_REG             DS.B        1 ; current register number we are concerned with(address, data, etc) that we are looking at. Ex: D0,A5,etc
00001B9B                          1167  
00001B9B                          1168  CURRENT_SRC_MD          DS.B        1 ; current source mode
00001B9C                          1169  CURRENT_SRC_REG         DS.B        1 ; current source register
00001B9D                          1170  CURRENT_DEST_MD         DS.B        1 ; current desination mode
00001B9E                          1171  CURRENT_DEST_REG        DS.B        1 ; current desination register
00001B9F                          1172  
00001BA0                          1173  CURRENT_DATA            DS.L        1 ; current addition data we are concerned with
00001BA4                          1174  CURRENT_SRC_DATA        DS.L        1 ; current additional data for source (like absolute addresses, immediate data, etc)
00001BA8                          1175  CURRENT_DEST_DATA       DS.L        1 ; current additional data for destination (like absolute addresses, immediate data, etc) 
00001BAC                          1176  
00001BAC                          1177  *size constants
00001BAC  =00000000               1178  BYTE_SIZE                EQU         $00 ; 0000 0000
00001BAC  =00000001               1179  WORD_SIZE                EQU         $01 ; 0000 0001
00001BAC  =00000002               1180  LONG_SIZE                EQU         $02 ; 0000 0010
00001BAC                          1181  
00001BAC  =00000001               1182  BYTE_SIZE_M              EQU         $01 ; 0000 0001
00001BAC  =00000003               1183  WORD_SIZE_M              EQU         $03 ; 0000 0011
00001BAC  =00000002               1184  LONG_SIZE_M              EQU         $02 ; 0000 0010
00001BAC                          1185  
00001BAC                          1186  *address constants
00001BAC  =00003000               1187  MIN_ADDRESS             EQU         $00003000
00001BAC  =0FFF0000               1188  MAX_ADDRESS             EQU         $0FFF0000
00001BAC                          1189  
00001BAC                          1190  *address variables
00001BAC  =00007000               1191  TEST_ORIGIN             SET         $00007000
00001BAC  =00007000               1192  NEXT_ADDR               SET         TEST_ORIGIN
00001BAC  =00009000               1193  END_ADDR                SET         $00009000
00001BAC                          1194  
00001BAC                          1195  *filters for isolating parts of a hexa instruction. X means 'unknown' and can be 0 or one after ANDI filter.
00001BAC                          1196  *To filter an instruction, ANDI it with the desired filter.
00001BAC                          1197  
00001BAC                          1198      * general filters
00001BAC  =0000C000               1199  FILT_2BIT_1             EQU         $0000C000   ;first 2 bits:                          XX00 0000 0000 0000
00001BAC  =0000F000               1200  FILT_NIB_1              EQU         $0000F000   ;first nibble:                          XXXX 0000 0000 0000
00001BAC                          1201  
00001BAC                          1202      * source/destination filters (not for bidirectional operations)
00001BAC  =00000E00               1203  FILT_DEST_REG           EQU         $00000E00   ;destination register:                  0000 XXX0 0000 0000
00001BAC  =000001C0               1204  FILT_DEST_MD            EQU         $000001C0   ;destination mode:                      0000 000X XX00 0000
00001BAC  =00000038               1205  FILT_SRC_MD             EQU         $00000038   ;source mode:                           0000 0000 00XX X000
00001BAC  =00000007               1206  FILT_SRC_REG            EQU         $00000007   ;source register:                       0000 0000 0000 0XXX
00001BAC                          1207  
00001BAC                          1208      * move filters
00001BAC  =00003000               1209  FILT_MOVE_SIZE          EQU         $00003000   ;Size of a move operation:              00XX 0000 0000 0000
00001BAC                          1210  
00001BAC                          1211      * filters for BRA, BSR, BCC, and MOVEQ (the same filter, but named differently for clarity.)
00001BAC  =000000FF               1212  FILT_DISPLACEMENT       EQU         $00FF       ;Displacment of branch instruction:     0000 0000 XXXX XXXX
00001BAC  =000000FF               1213  FILT_MOVEQ_DATA         EQU         $00FF       ;Data of MOVEQ instruction:             0000 0000 XXXX XXXX
00001BAC                          1214  
00001BAC                          1215  * constants for comparing with filtered instructions. X means 'don't care' (and will be set to 0 by previous filter)
00001BAC                          1216  *(These do not represent the complete insturctions.)
00001BAC                          1217  *(Also note that repetition is allowed for clarity's sake, so two constants can share a value.)
00001BAC  =00000000               1218  CONST_ALL_0             EQU         $0000    ; all 0s:                               0000 0000 0000 0000
00001BAC                          1219      * MOVE
00001BAC  =00001000               1220  CONST_MOVE_B            EQU         $1000    ; MOVE.B (use first nib)                0001 XXXX XXXX XXXX
00001BAC  =00003000               1221  CONST_MOVE_W            EQU         $3000    ; MOVE.W (use first nib)                0011 XXXX XXXX XXXX
00001BAC  =00002000               1222  CONST_MOVE_L            EQU         $2000    ; MOVE.L (use first nib)                0010 XXXX XXXX XXXX
00001BAC                          1223      * MOVEQ
00001BAC  =00007000               1224  CONST_MOVEQ             EQU         $7000    ; MOVEQ.L (use first nib)               0111 XXXX XXXX XXXX             
00001BAC                          1225  * Mode/register constants
00001BAC                          1226      * Mode values
00001BAC  =00000000               1227  CONST_DATA_REG_MD       EQU         $00      ; Data register mode:     Dn            XXXX X000
00001BAC  =00000001               1228  CONST_ADDR_REG_MD       EQU         $01      ; Address register mode:  An            XXXX X001
00001BAC  =00000002               1229  CONST_ADDR_IND_MD       EQU         $02      ; Address indirect mode:  (An)          XXXX X010
00001BAC  =00000003               1230  CONST_ADDR_INCR_MD      EQU         $03      ; Address postincr. mode: (An)+         XXXX X011
00001BAC  =00000004               1231  CONST_ADDR_DECR_MD      EQU         $04      ; Address predecr. mode:  -(An)         XXXX X100
00001BAC  =00000005               1232  CONST_ADDR_DISPLC_MD    EQU         $05      ; Address w/ displacement:(d16,An)      XXXX X101
00001BAC  =00000006               1233  CONST_ADDR_INDEX_MD     EQU         $06      ; Address w/ index:       (d8,PC,Xn)    XXXX X110
00001BAC  =00000007               1234  CONST_ADDR_MISC_MD      EQU         $07      ; Various other addressing modes        XXXX X111
00001BAC                          1235      * Constant register values (should not be necessary for register numbers like D5)
00001BAC  =00000002               1236  CONST_COUNTR_DISPLC_REG EQU         $02      ; Counter w/ displacement:(d16,PC)      XXXX X010
00001BAC  =00000003               1237  CONST_COUNTR_INDEX_REG  EQU         $03      ; Counter w/ index:       (d16,PC,Xn)   XXXX X011
00001BAC  =00000000               1238  CONST_ABS_SHORT_REG     EQU         $00      ; Absolute word:          (xxx).W       XXXX X000
00001BAC  =00000001               1239  CONST_ABS_LONG_REG      EQU         $01      ; Absolute long:          (xxx).L       XXXX X001
00001BAC  =00000004               1240  CONST_IMMEDIATE_REG     EQU         $04      ; Immediate data:         #imm          XXXX X100
00001BAC                          1241  
00001BAC                          1242  *full OPcode contstants
00001BAC  =00004E70               1243  RESET_CODE              EQU         $4E70   ; RESET                                 0100 1110 0111 0001
00001BAC  =00004E71               1244  NOP_CODE                EQU         $4E71   ; NOP                                   0100 1110 0111 0001
00001BAC  =00004E72               1245  STOP_CODE               EQU         $4E72   ; STOP                                  0100 1110 0111 0010
00001BAC                          1246  
00001BAC                          1247    
00001BAC                          1248  *############# END VARIABLES/CONSTANTS #########################
00001BAC                          1249  
00001BAC                          1250      END START        ; last line of source, very end of the program

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ASCII_TO_HEX        10B4
BEGIN_READ          12E2
BYTE_SIZE           0
BYTE_SIZE_M         1
BYTE_SIZE_MSG       1B36
CHECK_ADDRESSING_MODES  1738
CHECK_CONSTANTS     134A
CHECK_DONE_READING  1308
CHECK_MISC_ADDRESSINGS  189E
CHECK_MOVE          13BE
CHECK_MOVEQ         13E4
CHECK_NON_CONSTANTS  13B2
CLOSE_PARENS        1957
COMMA               1951
CONFIRMED_NEXT_OP   12F6
CONFIRM_READ_DATA   1638
CONFIRM_READ_DEST_DATA  1618
CONFIRM_READ_SRC_DATA  15DE
CONST_ABS_LONG_REG  1
CONST_ABS_SHORT_REG  0
CONST_ADDR_DECR_MD  4
CONST_ADDR_DISPLC_MD  5
CONST_ADDR_INCR_MD  3
CONST_ADDR_INDEX_MD  6
CONST_ADDR_IND_MD   2
CONST_ADDR_MISC_MD  7
CONST_ADDR_REG_MD   1
CONST_ALL_0         0
CONST_COUNTR_DISPLC_REG  2
CONST_COUNTR_INDEX_REG  3
CONST_DATA_REG_MD   0
CONST_IMMEDIATE_REG  4
CONST_MOVEQ         7000
CONST_MOVE_B        1000
CONST_MOVE_L        2000
CONST_MOVE_W        3000
CONVERSION_DONE     12B0
COUNT_INPUT_DIGITS  1046
CR                  D
CURRENT_DATA        1BA0
CURRENT_DEST_DATA   1BA8
CURRENT_DEST_MD     1B9D
CURRENT_DEST_REG    1B9E
CURRENT_MD          1B99
CURRENT_OP_SIZE     1B98
CURRENT_REG         1B9A
CURRENT_SRC_DATA    1BA4
CURRENT_SRC_MD      1B9B
CURRENT_SRC_REG     1B9C
CURRENT_WORD        1B96
DIG_CONV_DONE_1     10DE
DIG_CONV_DONE_2     1112
DIG_CONV_DONE_3     114A
DIG_CONV_DONE_4     1182
DIG_CONV_DONE_5     11BA
DIG_CONV_DONE_6     11F2
DIG_CONV_DONE_7     122A
DIG_CONV_DONE_8     1262
DISPLAY_ABS_LONG    1900
DISPLAY_ABS_SHORT   18E0
DISPLAY_ADDR_DECR   1856
DISPLAY_ADDR_DISPLC  189A
DISPLAY_ADDR_INCR   1812
DISPLAY_ADDR_IND    17DA
DISPLAY_ADDR_INDEX  189C
DISPLAY_ADDR_REG    17BA
DISPLAY_BUFFER      1B8C
DISPLAY_COUNTR_DISPLC  18DC
DISPLAY_COUNTR_INDEX  18DE
DISPLAY_CURRENT_ADDRESS  1324
DISPLAY_DATA_REG    179A
DISPLAY_DEST        1702
DISPLAY_IMMEDIATE   1920
DISPLAY_MOVEQ_DATA  1518
DISPLAY_MOVE_DATA   14A4
DISPLAY_SOURCE      16CC
DOLLAR              194F
DONE_READING        1310
DONE_READING_MSG    1B1A
END_ADDR            9000
END_ADDR_MSG        1991
FILT_2BIT_1         C000
FILT_DEST_MD        1C0
FILT_DEST_REG       E00
FILT_DISPLACEMENT   FF
FILT_MOVEQ_DATA     FF
FILT_MOVE_SIZE      3000
FILT_NIB_1          F000
FILT_SRC_MD         38
FILT_SRC_REG        7
GO_TO_NEXT_OP       12F2
HASH                1953
INPUTTING_START     1
INVALID_ADDR_HIGH   12A0
INVALID_ADDR_H_MSG  1AD9
INVALID_ADDR_INPUT  1270
INVALID_ADDR_LOW    1290
INVALID_ADDR_L_MSG  1A99
INVALID_ADDR_MSG    1A12
INVALID_END_ADDR    1280
INVALID_END_ADDR_MSG  1A48
INVALID_LEN_MSG     19C4
LF                  A
LONG_SIZE           2
LONG_SIZE_M         2
LONG_SIZE_MSG       1B3C
MAX_ADDRESS         FFF0000
MINUS               195B
MIN_ADDRESS         3000
MOVEQ_FOUND         14C6
MOVEQ_MSG           1B68
MOVE_B_FOUND        13FA
MOVE_B_MSG          1B53
MOVE_L_FOUND        145A
MOVE_L_MSG          1B61
MOVE_MSG            1B4E
MOVE_W_FOUND        142A
MOVE_W_MSG          1B5A
MSG_A               1B70
MSG_D               1B6E
NEXT_ADDR           7000
NOP_CODE            4E71
NOP_FOUND           1390
NOP_MSG             1B45
OPCODE_BUFFER       1B86
OPEN_PARENS         1955
PARSE_MOVEQ_DATA    14F6
PARSE_MOVE_DATA     148A
PLUS                1959
PREPARE_DISPLAY     12EE
PROMPT_INPUT        1008
READ_ABS_LONG_DATA  1682
READ_ABS_SHORT_DATA  167A
READ_COUNTR_DISPLC_DATA  1676
READ_COUNTR_INDEX_DATA  1678
READ_CURRENT_OP     1320
READ_DEST_DATA      15FE
READ_DEST_MODE      1572
READ_DEST_REG       1554
READ_IMMEDIATE_DATA  168A
READ_IMMEDIATE_DATA_L  16BE
READ_IMMEDIATE_DATA_W  16B0
READ_MOVEQ_DATA     153A
READ_SOURCE_DATA    15C4
READ_SOURCE_MODE    158E
READ_SOURCE_REG     15AA
RESET_CODE          4E70
RESET_FOUND         1372
RESET_MSG           1B3F
RETURN              194A
SET_END_ADDR        12D8
SET_START_ADDR      12D2
SIZE_BUFFER         1B8A
SPACE               194D
START               1000
START_ADDR_IN       1B72
START_ADDR_MSG      195D
STOP                1004
STOP_CODE           4E72
STOP_FOUND          13AE
STOP_MSG            1B49
TAKE_USER_INPUT     1034
TAKE_USER_IN_E      1020
TAKE_USER_IN_S      100C
TEST_ORIGIN         7000
VALID_ADDR          12C6
WORD_SIZE           1
WORD_SIZE_M         3
WORD_SIZE_MSG       1B39
