00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.14.00
Created On: 2/22/2014 1:59:52 AM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Disassembler
00000000                             3  * Written by : Robert Brandenburg, Danielle Jenkins, Shahin Nahar
00000000                             4  * Date       : 2/13/14
00000000                             5  * Description: Disassemble hex machine code instructions into 68K instructions
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8  * TODO: write disassembler
00000000                             9  * TODO: more specific TODOs for our plan
00000000                            10  * TODO: comments saying who is working where
00000000                            11  
00000000                            12  
00000000                            13  * Commenting Key: 
00000000                            14  *    "----------"  <-- subroutine commenting
00000000                            15  *    "##########"  <-- section/role commenting
00000000                            16  
00000000                            17  * Notes on saving registers on run:
00000000                            18  *    MOVEM.L A0-A3/D0-D7, -(A7) * copies all working registers to stack
00000000                            19  *    MOVEM.L (A7)+, A0-A3/D0-D7 *Restore the registers
00000000                            20  
00000000                            21  * Notes on AND filters (bit masking):
00000000                            22  * Example:
00000000                            23  *       0001 000 001 111 100   (say you want "001")
00000000                            24  *   AND 0000 000 111 000 000   (0 <-- don't want, 1 <-- do want)
00000000                            25  *       --------------------
00000000                            26  *     = 0000 000 001 000 000
00000000                            27  *
00000000                            28  * Relevant wiki page:
00000000                            29  *   https://en.wikipedia.org/wiki/Mask_(computing)#Masking_bits_to_0
00000000                            30  *
00000000                            31  *################ TODO LIST ################################
00000000                            32  *----------------OPcode TODOS (ROBERT)-----------------------------
00000000                            33  *
00000000                            34  * Fix the current bugs with MOVEs performed on absolute addresses. Not sure why these errors occur.
00000000                            35  *   -consult the bug report before trying to debug.
00000000                            36  * Continue decoding OPcodes in the following order: (with sizes)
00000000                            37  *   NOTE: I will delete OPcodes from this list as I implement them.
00000000                            38  
00000000                            39  *   -MOVEM  (W,L)
00000000                            40  *   -ADD    (B,W,L) (will need shahin's size filter for this and below)
00000000                            41  *   -ADDA   (W,L)
00000000                            42  *   -ADDI   (B,W,L)
00000000                            43  *   -SUB    (B,W,L)
00000000                            44  *   -SUBA   (W,L)
00000000                            45  *   -SUBQ   (B,W,L)
00000000                            46  *   -MULS   (W)     (not MULU?)
00000000                            47  *   -DIVU   (W      (not DIVU?)
00000000                            48  *   -LEA    (?)
00000000                            49  *   -CLR    (B,W,L)
00000000                            50  *   -AND    (B,W,L)
00000000                            51  *   -ANDI   (B,W,L)
00000000                            52  *   -EOR    (B,W,L)
00000000                            53  *   -EORI   (B,W,L)
00000000                            54  *   -ASR    (B,W,L) (no ASL?)
00000000                            55  *   -LSL    (B,W,L) (no LSR?)
00000000                            56  *   -ROL    (B,W,L)
00000000                            57  *   -ROR    (B,W,L)
00000000                            58  *   -BCHG   (?)
00000000                            59  *   -CMP    (B,W,L)
00000000                            60  *   -CMPA   (W,L)
00000000                            61  *   -CMPI   (B,W,L)
00000000                            62  *   -JSR    (N/A)
00000000                            63  *   (add others if we have time)
00000000                            64  *
00000000                            65  *----------------I/O TODOS (DANIELLE)-----------------------------
00000000                            66  * (TODOs for I/O go here.)
00000000                            67  *   - Complete display buffer
00000000                            68  *   - Print only a screenful at a time
00000000                            69  *   - At the end ask the user if they want to restart
00000000                            70  *   - Drop dollar sign if it appears in input
00000000                            71  *   - Hex to ASCII converter
00000000                            72  *
00000000                            73  *----------------EA TODOS  (SHAHIN)-----------------------------
00000000                            74  * (TODOs for EA go here.)
00000000                            75  *################ BEGIN MAIN ###############################
00000000                            76  *** All subroutine calls are made here ***
00001000                            77  START                   ORG        $1000       ; first instruction of program
00001000  6000 0006                 78                          BRA        PROMPT_INPUT            ; prompt the user for input
00001004                            79                   
00001004  4E72 2700                 80  STOP                    STOP       #$2700          ; halt simulator, end of main
00001008                            81  
00001008                            82  *################ END MAIN ###############################
00001008                            83  *################ BEGIN IO ###############################
00001008                            84  *** IO Subroutines are kept here ***
00001008                            85  
00001008                            86  *-------------------- Print ASCII logo ----------------------
00001008  7000                      87  PROMPT_INPUT            MOVE.L      #$00000000,D0           ;clear the registers so they're clean upon restart
0000100A  7200                      88                          MOVE.L      #$00000000,D1
0000100C  7400                      89                          MOVE.L      #$00000000,D2
0000100E  7600                      90                          MOVE.L      #$00000000,D3
00001010  7800                      91                          MOVE.L      #$00000000,D4
00001012  7A00                      92                          MOVE.L      #$00000000,D5
00001014  7C00                      93                          MOVE.L      #$00000000,D6
00001016  7E00                      94                          MOVE.L      #$00000000,D7
00001018  227C 00000000             95                          MOVE.L      #$00000000,A1
0000101E  247C 00000000             96                          MOVE.L      #$00000000,A2
00001024  267C 00000000             97                          MOVE.L      #$00000000,A3
0000102A  287C 00000000             98                          MOVE.L      #$00000000,A4
00001030  2A7C 00000000             99                          MOVE.L      #$00000000,A5
00001036  2C7C 00000000            100                          MOVE.L      #$00000000,A6
0000103C                           101  
0000103C  5202                     102  BLANK_THE_SCREEN        ADD.B       #1,D2         ; loop counter
0000103E                           103  
0000103E  43F9 00001DB5            104                          LEA         NEWLINE,A1    ; Print a bunch of newlines to blank the screen
00001044  103C 000E                105                          MOVE.B      #14,D0
00001048  4E4F                     106                          TRAP        #15
0000104A                           107  
0000104A  0C02 000F                108                          CMPI.B      #$F,D2            ; if the loop counter is less than 15
0000104E  6DEC                     109                          BLT         BLANK_THE_SCREEN  ; loop some more printing more newlines
00001050  7400                     110                          MOVE.L      #$00000000,D2     ; otherwise clear the data register so others can use it
00001052                           111  
00001052  6000 0002                112                          BRA         TAKE_USER_IN_S ;TODO: change to welcome/ASCII logo
00001056                           113  *------------------- Prompt user for input -------------------
00001056                           114  
00001056                           115                  
00001056  163C 0001                116  TAKE_USER_IN_S          MOVE.B      #1,D3
0000105A  43F9 00001B4D            117                          LEA         START_ADDR_MSG,A1  ; Prompt user for starting address
00001060  103C 000E                118                          MOVE.B      #14,D0
00001064  4E4F                     119                          TRAP        #15
00001066                           120  
00001066  6000 0016                121                          BRA         TAKE_USER_INPUT
0000106A                           122  
0000106A  163C 0000                123  TAKE_USER_IN_E          MOVE.B      #0,D3
0000106E  43F9 00001B81            124                          LEA         END_ADDR_MSG,A1  ; prompt user for ending address
00001074  103C 000E                125                          MOVE.B      #14,D0
00001078  4E4F                     126                          TRAP        #15
0000107A                           127                          
0000107A  6000 0002                128                          BRA         TAKE_USER_INPUT
0000107E                           129                          
0000107E  7200                     130  TAKE_USER_INPUT         MOVE.L      #$00000000,D1   ; need to clear out the data registers we are about to use to avoid junk data.   
00001080  7A00                     131                          MOVE.L      #$00000000,D5    
00001082  7C00                     132                          MOVE.L      #$00000000,D6
00001084  7E00                     133                          MOVE.L      #$00000000,D7
00001086                           134  
00001086  103C 0002                135                          MOVE.B      #2,D0           ; Take user input for next address.
0000108A  327C 2000                136                          MOVEA.W     #$2000,A1       ; Store the ascii input in A1,(note that we might not want to use 2000 here)
0000108E  4E4F                     137                          TRAP        #15             ; and the length in D1.W.  
00001090                           138  
00001090  327C 2001                139  COUNT_INPUT_DIGITS      MOVEA.W     #$2001,A1
00001094  B27C 0001                140                          CMP         #1,D1
00001098  6700 0064                141                          BEQ         ASCII_TO_HEX  ;start converting if we have 1 digit.
0000109C                           142            
0000109C  327C 2002                143                          MOVEA.W     #$2002,A1
000010A0  B27C 0002                144                          CMP         #2,D1
000010A4  6700 0058                145                          BEQ         ASCII_TO_HEX  ;start converting if we have 2 digits.
000010A8                           146            
000010A8  327C 2003                147                          MOVEA.W     #$2003,A1
000010AC  B27C 0003                148                          CMP         #3,D1
000010B0  6700 004C                149                          BEQ         ASCII_TO_HEX  ;start converting if we have 3 digits.
000010B4                           150            
000010B4  327C 2004                151                          MOVEA.W     #$2004,A1
000010B8  B27C 0004                152                          CMP         #4,D1
000010BC  6700 0040                153                          BEQ         ASCII_TO_HEX  ;start converting if we have 4 digits.
000010C0                           154            
000010C0  327C 2005                155                          MOVEA.W     #$2005,A1
000010C4  B27C 0005                156                          CMP         #5,D1
000010C8  6700 0034                157                          BEQ         ASCII_TO_HEX  ;start converting if we have 5 digits.
000010CC                           158            
000010CC  327C 2006                159                          MOVEA.W     #$2006,A1
000010D0  B27C 0006                160                          CMP         #6,D1
000010D4  6700 0028                161                          BEQ         ASCII_TO_HEX  ;start converting if we have 6 digits.
000010D8                           162            
000010D8  327C 2007                163                          MOVEA.W     #$2007,A1
000010DC  B27C 0007                164                          CMP         #7,D1
000010E0  6700 001C                165                          BEQ         ASCII_TO_HEX  ;start converting if we have 7 digits.
000010E4                           166            
000010E4  327C 2008                167                          MOVEA.W     #$2008,A1
000010E8  B27C 0008                168                          CMP         #8,D1
000010EC  6700 0010                169                          BEQ         ASCII_TO_HEX  ;start converting if we have 8 digits.
000010F0                           170            
000010F0  43F9 00001BB4            171                          LEA         INVALID_LEN_MSG,A1         ; If we get an invalid length, give and error message and... branch back asking user for input again
000010F6  103C 000E                172                          MOVE.B      #14,D0
000010FA  4E4F                     173                          TRAP        #15
000010FC                           174  
000010FC  6780                     175                          BEQ         TAKE_USER_INPUT               
000010FE                           176  
000010FE                           177  
000010FE                           178  
000010FE                           179  *------------------- Convert to hex subroutine -------------------
000010FE                           180  
000010FE  7C00                     181  ASCII_TO_HEX            MOVE.L      #$00000000,D6      ; running total of converted hex number
00001100                           182                  
00001100                           183                          ;first digit
00001100  1A21                     184                          MOVE.B      -(A1),D5  ; Move the raw ascii value of first digit into 3007.
00001102  BA7C 0030                185                          CMP         #$30,D5
00001106  6D00 01B2                186                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
0000110A  BA7C 0040                187                          CMP         #$40,D5
0000110E  6700 01AA                188                          BEQ         INVALID_ADDR_INPUT
00001112  BA7C 0046                189                          CMP         #$46,D5
00001116  6E00 01A2                190                          BGT         INVALID_ADDR_INPUT   
0000111A                           191                          ; Convert ascii to hex for that digit.
0000111A  0445 0030                192                          SUB         #$30,D5   ;
0000111E  BA7C 000A                193                          CMP         #$A,D5
00001122  6D00 0004                194                          BLT         DIG_CONV_DONE_1 ; Necessary to convert some ASCII values.
00001126  5F05                     195                          SUB.B       #7, D5                      ; TODO: errors for invalid ASCII values.
00001128                           196                  
00001128  DC45                     197  DIG_CONV_DONE_1         ADD.W       D5,D6
0000112A  B27C 0001                198                          CMP         #1,D1
0000112E  6700 01CA                199                          BEQ         CONVERSION_DONE
00001132                           200                  
00001132                           201                          ;second digit
00001132  7A00                     202                          MOVE.L      #$00000000,D5
00001134  1A21                     203                          MOVE.B      -(A1),D5
00001136  BA7C 0030                204                          CMP         #$30,D5
0000113A  6D00 017E                205                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
0000113E  BA7C 0040                206                          CMP         #$40,D5
00001142  6700 0176                207                          BEQ         INVALID_ADDR_INPUT
00001146  BA7C 0046                208                          CMP         #$46,D5
0000114A  6E00 016E                209                          BGT         INVALID_ADDR_INPUT   
0000114E  0445 0030                210                          SUB         #$30,D5
00001152  BA7C 000A                211                          CMP         #$A,D5            
00001156  6D00 0004                212                          BLT         DIG_CONV_DONE_2    ;digit conversion done 1
0000115A  5F05                     213                          SUB.B       #7, D5             ; if we have A or greater, then we need to subtract 1.
0000115C                           214               
0000115C  CAFC 0010                215  DIG_CONV_DONE_2         MULU.W      #$00000010,D5  ; this part adds $10 * (2nd digit) to our running total.
00001160  DC45                     216                          ADD.W       D5,D6 
00001162                           217                    
00001162  B27C 0002                218                          CMP         #2,D1
00001166  6700 0192                219                          BEQ         CONVERSION_DONE
0000116A                           220                  
0000116A                           221                          ;third digit
0000116A  7A00                     222                          MOVE.L      #$00000000,D5
0000116C  1A21                     223                          MOVE.B      -(A1),D5
0000116E  BA7C 0030                224                          CMP         #$30,D5
00001172  6D00 0146                225                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
00001176  BA7C 0040                226                          CMP         #$40,D5
0000117A  6700 013E                227                          BEQ         INVALID_ADDR_INPUT
0000117E  BA7C 0046                228                          CMP         #$46,D5
00001182  6E00 0136                229                          BGT         INVALID_ADDR_INPUT   
00001186  0445 0030                230                          SUB         #$30,D5
0000118A  BA7C 000A                231                          CMP         #$A,D5
0000118E  6D00 0004                232                          BLT         DIG_CONV_DONE_3 
00001192  5F05                     233                          SUB.B       #7, D5
00001194                           234                  
00001194  CAFC 0100                235  DIG_CONV_DONE_3         MULU.W      #$00000100,D5
00001198  DC45                     236                          ADD.W       D5,D6 
0000119A                           237      
0000119A  B27C 0003                238                          CMP         #3,D1
0000119E  6700 015A                239                          BEQ         CONVERSION_DONE
000011A2                           240                  
000011A2                           241                          ;fourth digit
000011A2  7A00                     242                          MOVE.L      #$00000000,D5
000011A4  1A21                     243                          MOVE.B      -(A1),D5
000011A6  BA7C 0030                244                          CMP         #$30,D5
000011AA  6D00 010E                245                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
000011AE  BA7C 0040                246                          CMP         #$40,D5
000011B2  6700 0106                247                          BEQ         INVALID_ADDR_INPUT
000011B6  BA7C 0046                248                          CMP         #$46,D5
000011BA  6E00 00FE                249                          BGT         INVALID_ADDR_INPUT   
000011BE  0445 0030                250                          SUB         #$30,D5
000011C2  BA7C 000A                251                          CMP         #$A,D5
000011C6  6D00 0004                252                          BLT         DIG_CONV_DONE_4
000011CA  5F05                     253                          SUB.B       #7,D5
000011CC                           254                  
000011CC  CAFC 1000                255  DIG_CONV_DONE_4         MULU.W      #$00001000,D5
000011D0  DC45                     256                          ADD.W       D5,D6 
000011D2                           257      
000011D2  B27C 0004                258                          CMP         #4,D1
000011D6  6700 0122                259                          BEQ         CONVERSION_DONE
000011DA                           260                  
000011DA                           261                          ;fifth digit
000011DA  7A00                     262                          MOVE.L      #$00000000,D5
000011DC  1A21                     263                          MOVE.B      -(A1),D5
000011DE  BA7C 0030                264                          CMP         #$30,D5
000011E2  6D00 00D6                265                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
000011E6  BA7C 0040                266                          CMP         #$40,D5
000011EA  6700 00CE                267                          BEQ         INVALID_ADDR_INPUT
000011EE  BA7C 0046                268                          CMP         #$46,D5
000011F2  6E00 00C6                269                          BGT         INVALID_ADDR_INPUT   
000011F6  0445 0030                270                          SUB         #$30,D5
000011FA  BA7C 000A                271                          CMP         #$A,D5
000011FE  6D00 0004                272                          BLT         DIG_CONV_DONE_5
00001202  5F05                     273                          SUB.B       #$7, D5
00001204                           274                  
00001204  CAFC 0001                275  DIG_CONV_DONE_5         MULU.W      #$0001,D5
00001208  DE45                     276                          ADD.W       D5,D7 
0000120A                           277  
0000120A  B27C 0005                278                          CMP         #5,D1
0000120E  6700 00EA                279                          BEQ         CONVERSION_DONE
00001212                           280                  
00001212                           281                          ;sixth digit
00001212  7A00                     282                          MOVE.L      #$00000000,D5
00001214  1A21                     283                          MOVE.B      -(A1),D5
00001216  BA7C 0030                284                          CMP         #$30,D5
0000121A  6D00 009E                285                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
0000121E  BA7C 0040                286                          CMP         #$40,D5
00001222  6700 0096                287                          BEQ         INVALID_ADDR_INPUT
00001226  BA7C 0046                288                          CMP         #$46,D5
0000122A  6E00 008E                289                          BGT         INVALID_ADDR_INPUT   
0000122E  0445 0030                290                          SUB         #$30,D5
00001232  BA7C 000A                291                          CMP         #$A,D5
00001236  6D00 0004                292                          BLT         DIG_CONV_DONE_6
0000123A  5F05                     293                          SUB.B       #$7, D5
0000123C                           294                  
0000123C  CAFC 0010                295  DIG_CONV_DONE_6         MULU.W      #$0010,D5
00001240  DE45                     296                          ADD.W       D5,D7
00001242                           297      
00001242  B27C 0006                298                          CMP         #6,D1
00001246  6700 00B2                299                          BEQ         CONVERSION_DONE
0000124A                           300                  
0000124A                           301                          ;seventh digit
0000124A  7A00                     302                          MOVE.L      #$00000000,D5
0000124C  1A21                     303                          MOVE.B      -(A1),D5
0000124E  BA7C 0030                304                          CMP         #$30,D5
00001252  6D00 0066                305                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
00001256  BA7C 0040                306                          CMP         #$40,D5
0000125A  6700 005E                307                          BEQ         INVALID_ADDR_INPUT
0000125E  BA7C 0046                308                          CMP         #$46,D5
00001262  6E00 0056                309                          BGT         INVALID_ADDR_INPUT   
00001266  0445 0030                310                          SUB         #$30,D5
0000126A  BA7C 000A                311                          CMP         #$A,D5
0000126E  6D00 0004                312                          BLT         DIG_CONV_DONE_7
00001272  5F05                     313                          SUB.B       #7, D5
00001274                           314                  
00001274  CAFC 0100                315  DIG_CONV_DONE_7         MULU.W      #$0100,D5
00001278  DE45                     316                          ADD.W       D5,D7
0000127A                           317      
0000127A  B27C 0007                318                          CMP         #7,D1
0000127E  6700 007A                319                          BEQ         CONVERSION_DONE
00001282                           320                  
00001282                           321                          ;eighth digit
00001282  7A00                     322                          MOVE.L      #$00000000,D5
00001284  1A21                     323                          MOVE.B      -(A1),D5
00001286  BA7C 0030                324                          CMP         #$30,D5
0000128A  6D00 002E                325                          BLT         INVALID_ADDR_INPUT ;comes  from inputting invalid characters
0000128E  BA7C 0040                326                          CMP         #$40,D5
00001292  6700 0026                327                          BEQ         INVALID_ADDR_INPUT
00001296  BA7C 0046                328                          CMP         #$46,D5
0000129A  6E00 001E                329                          BGT         INVALID_ADDR_INPUT   
0000129E  0445 0030                330                          SUB         #$30,D5
000012A2  BA7C 000A                331                          CMP         #$A,D5
000012A6  6D00 0004                332                          BLT         DIG_CONV_DONE_8
000012AA  5F05                     333                          SUB.B       #7, D5
000012AC                           334                  
000012AC  CAFC 1000                335  DIG_CONV_DONE_8         MULU.W      #$1000,D5
000012B0  DE45                     336                          ADD.W       D5,D7
000012B2                           337      
000012B2  B27C 0008                338                          CMP         #8,D1
000012B6  6700 0042                339                          BEQ         CONVERSION_DONE    ;the input was valid and we are done with the conversion
000012BA                           340                  
000012BA  43F9 00001C02            341  INVALID_ADDR_INPUT      LEA         INVALID_ADDR_MSG,A1    ;tell the user the address was invalid and prompt input again.
000012C0  103C 000E                342                          MOVE.B      #14,D0
000012C4  4E4F                     343                          TRAP        #15
000012C6                           344                          
000012C6  6000 FDB6                345                          BRA         TAKE_USER_INPUT
000012CA                           346                          
000012CA  43F9 00001C38            347  INVALID_END_ADDR        LEA         INVALID_END_ADDR_MSG,A1
000012D0  103C 000E                348                          MOVE.B      #14,D0
000012D4  4E4F                     349                          TRAP        #15
000012D6                           350                          
000012D6  6000 FDA6                351                          BRA         TAKE_USER_INPUT
000012DA                           352                          
000012DA  43F9 00001C89            353  INVALID_ADDR_LOW        LEA         INVALID_ADDR_L_MSG,A1    ;tell the user the address was invalid and prompt input again.
000012E0  103C 000E                354                          MOVE.B      #14,D0
000012E4  4E4F                     355                          TRAP        #15
000012E6                           356                          
000012E6  6000 FD96                357                          BRA         TAKE_USER_INPUT
000012EA                           358  
000012EA  43F9 00001CC9            359  INVALID_ADDR_HIGH       LEA         INVALID_ADDR_H_MSG,A1    ;tell the user the address was invalid and prompt input again.
000012F0  103C 000E                360                          MOVE.B      #14,D0
000012F4  4E4F                     361                          TRAP        #15
000012F6                           362                          
000012F6  6000 FD86                363                          BRA         TAKE_USER_INPUT
000012FA                           364                 
000012FA  E18F                     365  CONVERSION_DONE         LSL.L       #8,D7   ; Prepare for concatenation
000012FC  E18F                     366                          LSL.L       #8,D7   ; Got to perform the same operation twice to get it all the way to the left
000012FE  DE46                     367                          ADD.W       D6,D7  ; concatenate the two data registers into one value
00001300                           368                          
00001300  BEBC 00003000            369                          CMP.L       #MIN_ADDRESS,D7
00001306  6DD2                     370                          BLT         INVALID_ADDR_LOW ;Not a valid address-- too low.
00001308                           371                          
00001308  BEBC 0FFF0000            372                          CMP.L       #MAX_ADDRESS,D7
0000130E  6EDA                     373                          BGT         INVALID_ADDR_HIGH  ;Not a valid address-- too high.
00001310                           374                          
00001310  0C43 0001                375  VALID_ADDR              CMPI        #1,D3
00001314                           376                          
00001314  6700 0006                377                          BEQ         SET_START_ADDR
00001318  6000 0008                378                          BRA         SET_END_ADDR              
0000131C                           379                                                 
0000131C  2A47                     380  SET_START_ADDR          MOVEA.L     D7,A5  ;when a valid start address is inputted, store and ask the user for an end address.
0000131E  6000 FD4A                381                          BRA         TAKE_USER_IN_E
00001322                           382  
00001322  BE8D                     383  SET_END_ADDR            CMP.L       A5,D7    ;if end address is lower than start address, we get an error.
00001324  6DA4                     384                          BLT         INVALID_END_ADDR           
00001326                           385                          
00001326  2C47                     386                          MOVEA.L     D7,A6  ;when a valid start address is inputted, store and ask the user for an end address.
00001328  6000 0002                387                          BRA         BEGIN_READ
0000132C                           388                          
0000132C  284D                     389  BEGIN_READ              MOVEA.L      A5,A4 ; keep track of address to print with A4. TODO: could also add this value to the display buffer.
0000132E  33DD 00001DB8            390                          MOVE.W      (A5)+,CURRENT_WORD ;look at the first instruction word at the starting address.
00001334  6000 0002                391                          BRA         PREPARE_DISPLAY
00001338                           392  
00001338                           393  *------------------- Add to display buffer -------------------
00001338                           394  ;At this point A5 is a valid start address and A6 is a valid end address.
00001338                           395  ;TODO: prepare the display buffer
00001338  6000 0068                396  PREPARE_DISPLAY         BRA         READ_CURRENT_OP    ;TEMP (though we might still call this after the display buffer is prepared)                       
0000133C                           397                 
0000133C                           398  *------------------- Move address pointer for data reading -------------------
0000133C                           399  ; This method is specifically for reading the next OPword.
0000133C  6000 0014                400  GO_TO_NEXT_OP           BRA         CHECK_DONE_READING
00001340                           401                           
00001340  4279 00001DB8            402  CONFIRMED_NEXT_OP       CLR         CURRENT_WORD
00001346  284D                     403                          MOVEA.L      A5,A4 ; keep track of address to print with A4. 
00001348  33DD 00001DB8            404                          MOVE.W      (A5)+,CURRENT_WORD
0000134E  6000 0052                405                          BRA         READ_CURRENT_OP
00001352                           406                          
00001352                           407  *------------------- Print display buffer -------------------
00001352                           408  
00001352                           409  ;TODO
00001352                           410  
00001352                           411  *------------------- Check if end of data -------------------
00001352  BACE                     412  CHECK_DONE_READING      CMPA        A6,A5       ; TODO: this comparison is not sufficient, because it will say that $8000 is less than $7000 (since $8000 is negative.)
00001354  6DEA                     413                          BLT         CONFIRMED_NEXT_OP
00001356  6000 0002                414                          BRA         CONFIRM_DONE
0000135A                           415                          
0000135A                           416  *------------------- Confirm end of data -------------------
0000135A                           417  *** Confirm with user whether to end the program or restart
0000135A  43F9 00001D86            418  CONFIRM_DONE            LEA         RESTART_PROMPT_MSG,A1  ; Prompt user for restart
00001360  103C 000E                419                          MOVE.B      #14,D0
00001364  4E4F                     420                          TRAP        #15
00001366                           421  
00001366  103C 0002                422                          MOVE.B      #2,D0                    ; Take user input for next address.
0000136A  327C 2200                423                          MOVEA.W     #$2200,A1       ; Store the ascii input in A1,(note that we might not want to use 2200 here)
0000136E  4E4F                     424                          TRAP        #15                      ; and the length in D1.W.  
00001370                           425  
00001370  0C11 0079                426                          CMPI.B      #$79,(A1)                           ; if inputs 'y' 
00001374  6700 FC8A                427                          BEQ         START                       ; jump to beginning of program
00001378                           428  
00001378  0C11 006E                429                          CMPI.B      #$6E,(A1)                               ; if inputs 'n' 
0000137C  6700 0014                430                          BEQ         DONE_READING                        ; branch to DONE_READING subroutine
00001380                           431  
00001380  6000 0002                432                          BRA         USER_RESTART_IN_ERR                         ; otherwise, print error message and goto DONE_READING 
00001384                           433  
00001384                           434  *------------------- Error Restart ------------------- 
00001384  43F9 00001D95            435  USER_RESTART_IN_ERR     LEA         RESTART_ERROR_STR,A1 ; Print out error message          
0000138A  103C 000E                436                          MOVE.B      #14,D0
0000138E  4E4F                     437                          TRAP        #15
00001390                           438  
00001390  60C8                     439                          BRA         CONFIRM_DONE     ; reconfirm whether to restart again
00001392                           440  
00001392                           441  *------------------- Print done -------------------                       
00001392  43F9 00001D0A            442  DONE_READING            LEA         DONE_READING_MSG,A1 ; when we reach the end address, say so and halt the program. TODO: ask user whether we want to read the data again.
00001398  103C 000E                443                          MOVE.B      #14,D0
0000139C  4E4F                     444                          TRAP        #15
0000139E  4EF8 1004                445                          JMP         STOP
000013A2                           446                          
000013A2                           447  *################## END IO  #####################################
000013A2                           448  *################## BEGIN OPCODE ##########################
000013A2                           449  *** OPcode Subroutines are kept here ***
000013A2                           450  
000013A2                           451  ; planned process for reading hex instructions:
000013A2                           452          ; NOTE: this process is tentative and subject to change as OPcode person implements. 
000013A2                           453                  ;           1) Go to start of instruction reading loop, passing in the address of next instruction.
000013A2                           454                  ;           2) Store a word (16 bits) from that address.
000013A2                           455                  ;           3) Read the first 4 bits of the word using a filter.
000013A2                           456                  ;           4) branch to one of the following paths based on these bits:
000013A2                           457                  ;               a) 0000: Read the next 3 bits (i.e., the destination mode). Branch:
000013A2                           458                  ;                   i.   000: Read the bits at 0000 0000 XXXX XXXX (may want to make this filter) Branch:
000013A2                           459                  ;                       1) 00 111 100: ORI TO CCR (need to read data, I think)
000013A2                           460                  ;                       2) 01 111 100: ORI TO SR (need to read data, I think)
000013A2                           461                  ;                       3) (default) ORI. Now, read and store:
000013A2                           462                  ;                           SIZE:       0000 0000 XX00 0000 (need to make this filter)
000013A2                           463                  ;                           MODE:       0000 0000 00XX X000 (need to make this filter)
000013A2                           464                  ;                           REGISTER:   0000 0000 0000 0XXX (need to make this filter)
000013A2                           465                  ;                           only mandatory additional data is the immediate data.
000013A2                           466                  ;                   ii.  001: Read the bits at 0000 0000 XXXX XXXX (may want to make this filter) Branch:
000013A2                           467                  ;                       1) 00 111 100: ANDI TO CCR (need to read data, I think)
000013A2                           468                  ;                       2) 01 111 100: ANDI TO SR (need to read data, I think)
000013A2                           469                  ;                       3) (default) ANDI. Now, read and store:
000013A2                           470                  ;                           SIZE:       0000 0000 XX00 0000 (need to make this filter)
000013A2                           471                  ;                           MODE:       0000 0000 00XX X000 (need to make this filter)
000013A2                           472                  ;                           REGISTER:   0000 0000 0000 0XXX (need to make this filter)
000013A2                           473                  ;                           only mandatory additional data is the immediate data.
000013A2                           474                  ;                   iii. 101: Read the bits at 0000 0000 XXXX XXXX (may want to make this filter) Branch:
000013A2                           475                  ;                       1) 00 111 100: EORI TO CCR (need to read data, I think)
000013A2                           476                  ;                       2) 01 111 100: EORI TO SR (need to read data, I think)
000013A2                           477                  ;                       3) (default) EORI. Now, read and store:
000013A2                           478                  ;                           SIZE:       0000 0000 XX00 0000 (need to make this filter)
000013A2                           479                  ;                           MODE:       0000 0000 00XX X000 (FILT_SRC_MODE)
000013A2                           480                  ;                           REGISTER:   0000 0000 0000 0XXX (FILT_SRC_REG)
000013A2                           481                  ;                           only mandatory additional data is the immediate data.
000013A2                           482                  ;                   iv.  011: ADDI. Now read and store:
000013A2                           483                  ;                           SIZE:       0000 0000 XX00 0000 (need to make this filter)
000013A2                           484                  ;                           MODE:       0000 0000 00XX X000 (FILT_SRC_MODE)
000013A2                           485                  ;                           REGISTER:   0000 0000 0000 0XXX (FILT_SRC_REG)
000013A2                           486                  ;                           only mandatory additional data is the immediate data.
000013A2                           487                  ;                   v.   010: SUBI. Now read and store:
000013A2                           488                  ;                           SIZE:       0000 0000 XX00 0000 (need to make this filter)
000013A2                           489                  ;                           MODE:       0000 0000 00XX X000 (FILT_SRC_MODE)
000013A2                           490                  ;                           REGISTER:   0000 0000 0000 0XXX (FILT_SRC_REG)
000013A2                           491                  ;                           only mandatory additional data is the immediate data.
000013A2                           492                  ;                   vi.  110: CMPI. Now read and store:
000013A2                           493                  ;                           SIZE:       0000 0000 XX00 0000 (need to make this filter)
000013A2                           494                  ;                           MODE:       0000 0000 00XX X000 (FILT_SRC_MODE)
000013A2                           495                  ;                           REGISTER:   0000 0000 0000 0XXX (FILT_SRC_REG)
000013A2                           496                  ;                           only mandatory additional data is the immediate data.
000013A2                           497                  ;                   vii. 100: BTST, BCHG, BCLR, BSET (TODO: expand this section if we need these OPcodes)
000013A2                           498                  ;                   viii.(default): BTST, BCHG, BCLR, BSET (with data register)(TODO: expand this section if we need these OPcodes)
000013A2                           499                  ;               b) 0001: (MOVE.B). Now read and store:
000013A2                           500                  ;                           DESTINATION REGISTER: 0000 XXX0 0000 0000 (FILT_DEST_REG)
000013A2                           501                  ;                           DESTINATION MODE:     0000 000X XX00 0000 (FILT_DEST_MODE)
000013A2                           502                  ;                           SOURCE MODE:          0000 0000 00XX X000 (FILT_SCR_MODE)
000013A2                           503                  ;                           SOURCE REGISTER:      0000 0000 0000 0XXX (FILT_SRC_REG)
000013A2                           504                  ;                           The modes (and maybe register) will tell us whether we need to read additional data for this MOVE.
000013A2                           505                  ;               c) 0011: (MOVE.W). Now read and store:
000013A2                           506                  ;                           DESTINATION REGISTER: 0000 XXX0 0000 0000 (FILT_DEST_REG)
000013A2                           507                  ;                           DESTINATION MODE:     0000 000X XX00 0000 (FILT_DEST_MODE)
000013A2                           508                  ;                           SOURCE MODE:          0000 0000 00XX X000 (FILT_SCR_MODE)
000013A2                           509                  ;                           SOURCE REGISTER:      0000 0000 0000 0XXX (FILT_SRC_REG)
000013A2                           510                  ;                           The modes (and maybe register) will tell us whether we need to read additional data for this MOVE.
000013A2                           511                  ;               d) 0010: (MOVE.L). Now read and store:
000013A2                           512                  ;                           DESTINATION REGISTER: 0000 XXX0 0000 0000 (FILT_DEST_REG)
000013A2                           513                  ;                           DESTINATION MODE:     0000 000X XX00 0000 (FILT_DEST_MODE)
000013A2                           514                  ;                           SOURCE MODE:          0000 0000 00XX X000 (FILT_SCR_MODE)
000013A2                           515                  ;                           SOURCE REGISTER:      0000 0000 0000 0XXX (FILT_SRC_REG)
000013A2                           516                  ;                           The modes (and maybe register) will tell us whether we need to read additional data for this MOVE.
000013A2                           517                  ;               e) 0100: Read the bits at 0000 XXXX 0000 0000 (need filter) Branch:
000013A2                           518                  ;                   i.      0000: Read the bits at 0000 0000 XX00 0000 (need filter) Branch:
000013A2                           519                  ;                               1. 11: MOVE from SR. (TODO)
000013A2                           520                  ;                               2. (DEFAULT) NEGX. (the two bits are size) (TODO)
000013A2                           521                  ;                   ii.     0100: Read the bits at 0000 0000 XX00 0000 (need filter) Branch:
000013A2                           522                  ;                               1. 11 MOVE to CCR. (TODO)
000013A2                           523                  ;                               2. (DEFAULT) NEG. (the two bits are size) (TODO)
000013A2                           524                  ;                   iii.    0110: Read the bits at 0000 0000 XX00 0000 (need filter) Branch:
000013A2                           525                  ;                               1. 11 MOVE to SR. (TODO)
000013A2                           526                  ;                               2. (DEFAULT) NOT. (the two bits are size) (TODO)
000013A2                           527                  ;                   iv.     0010: CLR. (TODO)
000013A2                           528                  ;                    v.     1000: (EXT, NBCD, SWAP, PEA, MOVEM (dir 0)) (TODO)
000013A2                           529                  ;                   vi.     1010: Check the bits at 0000 XX00 0000 0000 (need filter) Branch:
000013A2                           530                  ;                           1. 11: check the bits at 0000 00XX XXXX XXXX (need filter) Branch:
000013A2                           531                  ;                               a. 11 1100: ILLEGAL (TODO)
000013A2                           532                  ;                               b. (default) TAS (TODO)
000013A2                           533                  ;                           2. (default) TST (TODO)
000013A2                           534                  ;                  vii.     1110: (TRAP, LINK, UNLK, MOVE USP, RESET, NOP, STOP, RTE, RTS, TRAPV, RTR, JSR, JMP) (TODO)
000013A2                           535                  ;                 viii.     (DEFAULT): (MOVEM, LEA, CHK,) (TODO)    
000013A2                           536                  ;               f) 0101: (ADDQ, SUBQ, Scc, DBcc): Read the bits at 0000 0000 XX00 0000 (need filter) Branch:
000013A2                           537                  ;                    i. 11: Read the bit at 0000 000X 0000 0000 (need filter) Branch:
000013A2                           538                  ;                           1. 0: ADDQ (TODO)
000013A2                           539                  ;                           2. 1: SUBQ (TODO)
000013A2                           540                  ;                   ii. (default) (bits are size) read the bits at 0000 00XX X000 (FILT_SRC_MODE). Branch:
000013A2                           541                  ;                           1. 001: DBCC (TODO)
000013A2                           542                  ;                           2. (default): Scc (TODO)
000013A2                           543                  ;               g) 0110: Read the bit at 0000 XXXX 0000 0000 (need filter) Branch:
000013A2                           544                  ;                    i. 0000: BRA (TODO)
000013A2                           545                  ;                   ii. 0001: BSR (TODO)
000013A2                           546                  ;                  iii. (default) Bcc (TODO)
000013A2                           547                  ;               h) 0111: MOVEQ (TODO)
000013A2                           548                  ;               i) 1000: (DIVU, DIVS, SBCD, OR) (TODO)
000013A2                           549                  ;               j) 1001: (SUB, SUBX, SUBA) (TODO)
000013A2                           550                  ;               k) 1011: (EOR, CMPM, CMP, CMPA) (TODO)
000013A2                           551                  ;               l) 1100: (MULU, MULS, ABCD, EXG, AND) (TODO)
000013A2                           552                  ;               m) 1101: (ADD, ADDX, ADDA) (TODO)
000013A2                           553                  ;               n) 1110: (ASd, LSd, ROXd, ROd, ASd, LSd, ROXd, ROd) (TODO)
000013A2                           554                  ;               o) (default) The code is invalid. Not yet sure what we do in this case.
000013A2                           555                  ;   
000013A2                           556                  ;   
000013A2                           557                  ;
000013A2                           558                  
000013A2                           559                  ;TODO: Use AND operations with filters to create values which can be
000013A2                           560                  ;      checked against constants to narrow down OPcodes.
000013A2                           561                  
000013A2                           562                  ;TODO: Since it will take a while to decode every possible OPcode, we
000013A2                           563                  ;      should first have a default "Error" subroutine which the program
000013A2                           564                  ;      branches to once all other possibilities have been ruled out.
000013A2                           565  
000013A2                           566  *------------------- Read current OPcode -------------------
000013A2                           567  ; By this point, CURRENT_WORD should store a potential beginning of an instruction, so we should not increment A5.
000013A2  6000 0028                568  READ_CURRENT_OP         BRA         CHECK_CONSTANTS
000013A6                           569                          
000013A6                           570    
000013A6                           571  *------------------- Display current address we are reading -------------------
000013A6  43F9 00001B3F            572  DISPLAY_CURRENT_ADDRESS LEA         DOLLAR,A1       ; '$'
000013AC  103C 000E                573                          MOVE.B      #14,D0
000013B0  4E4F                     574                          TRAP        #15
000013B2                           575                  
000013B2  220C                     576                          MOVE.L      A4,D1           ; display the address the instruction was found at
000013B4  143C 0010                577                          MOVE.B      #16,D2
000013B8  103C 000F                578                          MOVE.B      #15,D0
000013BC  4E4F                     579                          TRAP        #15
000013BE                           580  
000013BE  43F9 00001B3D            581                          LEA         SPACE,A1        ; ' '
000013C4  103C 000E                582                          MOVE.B      #14,D0      
000013C8  4E4F                     583                          TRAP        #15     
000013CA                           584                          
000013CA  4E75                     585                          RTS
000013CC                           586   
000013CC                           587  *------------------ Check current word for constants---------
000013CC                           588  ; By this point, the current word should store a potential beginning of an instruction.                   
000013CC  0C79 4E70 00001DB8       589  CHECK_CONSTANTS         CMP         #RESET_CODE,(CURRENT_WORD)
000013D4  6700 001E                590                          BEQ         RESET_FOUND
000013D8  0C79 4E71 00001DB8       591                          CMP         #NOP_CODE,(CURRENT_WORD)
000013E0  6700 0030                592                          BEQ         NOP_FOUND
000013E4  0C79 4E72 00001DB8       593                          CMP         #STOP_CODE,(CURRENT_WORD)
000013EC  6700 0042                594                          BEQ         STOP_FOUND
000013F0  6000 0042                595                          BRA         CHECK_NON_CONSTANTS     ;Once we rule out all the constants we know of, we check for non-constants.
000013F4                           596  
000013F4                           597  ; TODO: change the structure of these subroutines to be like the nice structure used in EA SRs.
000013F4                           598                         
000013F4  61B0                     599  RESET_FOUND             BSR         DISPLAY_CURRENT_ADDRESS
000013F6                           600  
000013F6  43F9 00001D2F            601                          LEA         RESET_MSG,A1    ; 'RESET'
000013FC  103C 000E                602                          MOVE.B      #14,D0
00001400  4E4F                     603                          TRAP        #15
00001402                           604                          
00001402  43F9 00001B3A            605                          LEA         RETURN,A1       ; (return)
00001408  103C 000E                606                          MOVE.B      #14,D0
0000140C  4E4F                     607                          TRAP        #15
0000140E                           608                 
0000140E  6000 FF2C                609                          BRA         GO_TO_NEXT_OP   
00001412                           610   
00001412                           611  ; NOTE: this SR is temporary. Once we have the display buffer, it will work differently.                 
00001412  6192                     612  NOP_FOUND               BSR         DISPLAY_CURRENT_ADDRESS
00001414                           613  
00001414  43F9 00001D35            614                          LEA         NOP_MSG,A1    ; 'NOP'
0000141A  103C 000E                615                          MOVE.B      #14,D0
0000141E  4E4F                     616                          TRAP        #15
00001420                           617                          
00001420  43F9 00001B3A            618                          LEA         RETURN,A1     ; (return)
00001426  103C 000E                619                          MOVE.B      #14,D0
0000142A  4E4F                     620                          TRAP        #15
0000142C                           621                 
0000142C  6000 FF0E                622                          BRA         GO_TO_NEXT_OP   ; when we are done parsing and displaying the NOP instruction, go to the next OPcode.
00001430                           623  
00001430  4EF8 1004                624  STOP_FOUND              JMP         STOP  ;TODO: case for stop found. (NOTE that STOP instructions have additional data.)               
00001434                           625  
00001434                           626  ;TODO: add cases for rest of valid constant OPcodes here
00001434                           627  
00001434                           628  *----------------- Check current word for non-constants---------
00001434                           629  ;NOTE: we currently know that CURRENT_WORD is not a constant by the time we reach this SR.
00001434                           630  
00001434  6100 011C                631  CHECK_NON_CONSTANTS     BSR         CHECK_MOVE        ; MOVE is a special case because of how its first nibble is structured.     
00001438  6100 013E                632                          BSR         CHECK_MOVEQ       ; MOVEQ is also a special case.
0000143C  6100 0150                633                          BSR         CHECK_EXT         ; need to rule out EXT before checking MOVEM, because they have very similar OPcodes.
00001440  6100 0162                634                          BSR         CHECK_MOVEM      
00001444  6100 000A                635                          BSR         CHECK_NIB1_0000 
00001448  6100 001C                636                          BSR         CHECK_NIB1_0100 
0000144C                           637                          
0000144C                           638                          ; TODO: BSR to checks for other special cases, along with nibbles.
0000144C                           639                          
0000144C                           640                          ;NOTE: we do not check for most specific instructions here.
0000144C                           641  
0000144C                           642                          ; TODO: go into the subroutines below and *fully* implement the followings:
0000144C                           643                          *   -MOVEM  (W,L)
0000144C                           644                          *   -ADD    (B,W,L) (will need shahin's size filter for this and below)
0000144C                           645                          *   -ADDA   (W,L)
0000144C                           646                          *   -ADDI   (B,W,L)
0000144C                           647                          *   -SUB    (B,W,L)
0000144C                           648                          ;etc
0000144C  4EF8 1004                649                          JMP         STOP
00001450                           650                          ;TODO: check for other instructions instead of stopping if it's not one of these.
00001450                           651    
00001450                           652  *-----------------------First 4bit checks go here-----------------------------------
00001450                           653    
00001450                           654  *-----------------------Check if the current word starts with 0000--------------------
00001450  4243                     655  CHECK_NIB1_0000         CLR         D3
00001452  3639 00001DB8            656                          MOVE.W      CURRENT_WORD,D3
00001458  0243 F000                657                          ANDI.W      #FILT_NIB_1,D3  ; filter out the first 4 bits of the word
0000145C  B67C 0000                658                          CMP         #CONST_ALL_0,D3 ; see if they are all 0
00001460  6700 001A                659                          BEQ         CONFIRM_NIB1_0000
00001464  4E75                     660                          RTS 
00001466                           661                          
00001466  4243                     662  CHECK_NIB1_0100         CLR         D3 
00001468  3639 00001DB8            663                          MOVE.W      CURRENT_WORD,D3
0000146E  0243 F000                664                          ANDI.W      #FILT_NIB_1,D3      ; filter out the first 4 bits of the word
00001472  B67C 4000                665                          CMP         #CONST_NIB1_0100,D3 ; see if they are 0100
00001476  6700 005A                666                          BEQ         CONFIRM_NIB1_0100
0000147A  4E75                     667                          RTS                        
0000147C                           668                          
0000147C                           669  *-----------------------First 4bit confirms go here--------------------------------------
0000147C                           670  
0000147C                           671  *-----------------------Cases where the current word starts with 0000--------------------                       
0000147C  4243                     672  CONFIRM_NIB1_0000       CLR         D3
0000147E  3639 00001DB8            673                          MOVE.W      CURRENT_WORD,D3
00001484  0243 0100                674                          ANDI.W      #FILT_BIT_8,D3  ; turn word into 0000 000X 0000 0000
00001488  E04B                     675                          LSR.W       #8,D3           ; turn word into 0000 0000 0000 000X
0000148A  B67C 0000                676                          CMP         #CONST_ALL_0,D3 ; see if the word is still 0.
0000148E  6700 0004                677                          BEQ         CONFIRM_0000_XXX0
00001492                           678                          ; if we get to here, then the word must be BCHG, BCLR, BSET, or MOVEP.
00001492                           679                          ; BCHG is required
00001492                           680                          ; if our disassembler doesn't consider any of those valid, there should be an error message here.
00001492  4E75                     681                          RTS 
00001494                           682                          
00001494                           683  ; at this point, the word is of the form 0000 XXX0...
00001494  4243                     684  CONFIRM_0000_XXX0       CLR         D3
00001496  3639 00001DB8            685                          MOVE.W      CURRENT_WORD,D3
0000149C  0243 0E00                686                          ANDI.W      #FILT_DEST_REG,D3  ; turn word into 0000 XXX0 0000 0000          
000014A0                           687                          
000014A0                           688                          ; now figure out which operation we have: (note that constants have been ruled out by this point)
000014A0                           689                          
000014A0  B67C 0000                690                          CMP         #CONST_ORI_DEST_REG,D3  ; ORI 
000014A4  6700 0276                691                          BEQ         ORI_FOUND           
000014A8                           692                          
000014A8  B67C 0200                693                          CMP         #CONST_ANDI_DEST_REG,D3 ; ANDI 
000014AC  6700 0272                694                          BEQ         ANDI_FOUND
000014B0                           695                          
000014B0  B67C 0400                696                          CMP         #CONST_SUBI_DEST_REG,D3 ; SUBI
000014B4  6700 026E                697                          BEQ         SUBI_FOUND
000014B8                           698                          ;
000014B8  B67C 0600                699                          CMP         #CONST_ADDI_DEST_REG,D3 ; ADDI
000014BC  6700 026A                700                          BEQ         ADDI_FOUND
000014C0                           701                          
000014C0  B67C 0A00                702                          CMP         #CONST_EORI_DEST_REG,D3 ; EORI
000014C4  6700 0266                703                          BEQ         EORI_FOUND
000014C8                           704                          
000014C8  B67C 0C00                705                          CMP         #CONST_CMPI_DEST_REG,D3 ; CMPI
000014CC  6700 0262                706                          BEQ         CMPI_FOUND
000014D0                           707                          
000014D0                           708                          ;TODO: remaining: BTST, BCHG, BCLR, or BSET. 
000014D0                           709                          ;      if none of them, an error case should occur here.
000014D0                           710                          ;     (note that BCHG is required, though we don't know which version.)
000014D0                           711                          
000014D0  4E75                     712                          RTS     ;change RTS to whatever branch instruction is appropriate here.
000014D2                           713                          
000014D2                           714  *-----------------------Cases where the current word starts with 0100-----------------
000014D2                           715  
000014D2                           716      ; if we were doing every OPcode, would start by checking for MOVE from SR, MOVE to CCR, and MOVE to SR at the top of this SR.
000014D2                           717      ; instead, we start with NEGX.
000014D2  4243                     718  CONFIRM_NIB1_0100       CLR         D3              
000014D4  3639 00001DB8            719                          MOVE.W      CURRENT_WORD,D3
000014DA  0243 0800                720                          ANDI.W      #FILT_BIT_5,D3  ; turn word into 0000 X000 0000 0000
000014DE  E04B                     721                          LSR.W       #8,D3           ; turn word into 0000 0000 0000 000X
000014E0  E64B                     722                          LSR.W       #3,D3
000014E2  B67C 0000                723                          CMP         #CONST_ALL_0,D3 ; see if the word is still 0.
000014E6  6700 0006                724                          BEQ         CONFIRM_0100_0XXX   ; branch based on the 5th bit.
000014EA  6000 0032                725                          BRA         CONFIRM_0100_1XXX
000014EE                           726                          
000014EE  4243                     727  CONFIRM_0100_0XXX       CLR         D3              
000014F0  3639 00001DB8            728                          MOVE.W      CURRENT_WORD,D3
000014F6  0243 0F00                729                          ANDI.W      #FILT_NIB_2,D3  ; turn word into 0000 XXXX 0000 0000
000014FA                           730                          
000014FA                           731                          ; now figure out which operation we have:
000014FA                           732                          
000014FA  B67C 0000                733                          CMP         #CONST_NEGX_OP,D3
000014FE  6700 0234                734                          BEQ         NEGX_FOUND
00001502                           735                          
00001502  B67C 0200                736                          CMP         #CONST_CLR_OP,D3
00001506  6700 0230                737                          BEQ         CLR_FOUND
0000150A                           738                          
0000150A  B67C 0400                739                          CMP         #CONST_NEG_OP,D3
0000150E  6700 022C                740                          BEQ         NEG_FOUND
00001512                           741                          
00001512  B67C 0600                742                          CMP         #CONST_NOT_OP,D3
00001516  6700 0228                743                          BEQ         NOT_FOUND         ; note that we could likely make a conflicting SR name with one.
0000151A                           744                          
0000151A                           745                          ; TODO: we definitely have an error at this point.
0000151A                           746                          
0000151A  4EF8 1004                747                          JMP         STOP     ;change STOP to whatever we want based on error. (probably some error case which will then branch to reading next OPcode.)
0000151E                           748                          
0000151E  4243                     749  CONFIRM_0100_1XXX       CLR         D3
00001520  3639 00001DB8            750                          MOVE.W      CURRENT_WORD,D3
00001526  0243 0F00                751                          ANDI.W      #FILT_NIB_2,D3  ; turn word into 0000 XXXX 0000 0000
0000152A                           752                          
0000152A  B67C 0800                753                          CMP         #CONST_NIB2_1000,D3
0000152E  6700 0016                754                          BEQ         CONFIRM_0100_1000
00001532                           755  
00001532  B67C 0A00                756                          CMP         #CONST_NIB2_1010,D3
00001536  6700 0012                757                          BEQ         CONFIRM_0100_1010 
0000153A                           758  
0000153A  B67C 0E00                759                          CMP         #CONST_NIB2_1110,D3
0000153E  6700 000E                760                          BEQ         CONFIRM_0100_1110 
00001542                           761                          ; TODO: make MOVEM a special case since it has an unusual OPcode.
00001542                           762                          ; TODO: remaining possibilities are MOVEM, LEA, or CHK. (the first two are required.)
00001542                           763  
00001542  4EF8 1004                764                          JMP         STOP                      
00001546                           765                     
00001546  4EF8 1004                766  CONFIRM_0100_1000       JMP         STOP                       
0000154A                           767  ; TODO: check for EXT, NBCD, SWAP, or PEA.               
0000154A                           768   
0000154A  4EF8 1004                769  CONFIRM_0100_1010       JMP         STOP  
0000154E                           770  ; TODO: check for TAS or TST. (ILLEGAL is already ruled out.)         
0000154E                           771         
0000154E  4EF8 1004                772  CONFIRM_0100_1110       JMP         STOP       
00001552                           773  ; TODO: check for TRAP, LINK, UNLK, MOVE USP, JSR, or JMP. (some of these are required.)
00001552                           774  
00001552                           775  *-----------------------Cases where the current word starts with 0101-----------------
00001552                           776      ;TODO: ADDQ, SUBQ, Scc, DBcc (some of these are required)
00001552                           777   
00001552                           778  *-----------------------Cases where the current word starts with 0110-----------------
00001552                           779      ;TODO: BRA, BSR, Bcc (some of these are required)   
00001552                           780      
00001552                           781  *-----------------------Cases where the current word starts with 1000-----------------
00001552                           782      ;TODO: DIVU, DIVS, SBCD, OR (some of these are required)   
00001552                           783      
00001552                           784  *-----------------------Cases where the current word starts with 1001-----------------
00001552                           785      ;TODO: SUB, SUBX, SUBA (some of these are required) 
00001552                           786   
00001552                           787  *-----------------------Cases where the current word starts with 1011-----------------
00001552                           788      ;TODO: EOR, CMPM, CMP, CMPA (some of these are required)  
00001552                           789      
00001552                           790  *-----------------------Cases where the current word starts with 1100-----------------
00001552                           791      ;TODO: MULU, MULS, ABCD, EXG, AND (some of these are required) 
00001552                           792      
00001552                           793  *-----------------------Cases where the current word starts with 1101-----------------
00001552                           794      ;TODO: ADD, ADDX, ADDA (some of these are required) 
00001552                           795      
00001552                           796  *-----------------------Cases where the current word starts with 1110-----------------
00001552                           797      ;TODO: ASR, ASL, LSR, LSL, ROXR, ROXL, ROR, ROL (these are all repeated twice on the sheet for some reason) 
00001552                           798                                                      ;(some of these are required) 
00001552                           799   
00001552                           800  *-----------------------Special OPcode (but not constants) have checks here------------
00001552                           801  * includes MOVE, MOVEQ, etc
00001552                           802                                  
00001552                           803  *-----------------------Check current word for MOVE------------------------------------
00001552                           804  *MOVE can be B,W, or L.
00001552  4243                     805  CHECK_MOVE              CLR         D3
00001554  3639 00001DB8            806                          MOVE.W      CURRENT_WORD,D3
0000155A  0243 F000                807                          ANDI.W      #FILT_NIB_1,D3
0000155E  B67C 1000                808                          CMP         #CONST_MOVE_B,D3
00001562  6700 0056                809                          BEQ         MOVE_B_FOUND
00001566  B67C 3000                810                          CMP         #CONST_MOVE_W,D3
0000156A  6700 007E                811                          BEQ         MOVE_W_FOUND
0000156E  B67C 2000                812                          CMP         #CONST_MOVE_L,D3
00001572  6700 00A6                813                          BEQ         MOVE_L_FOUND
00001576  4E75                     814                          RTS 
00001578                           815                          
00001578                           816  *-----------------------Check current word for MOVEQ------------------------------------
00001578                           817  *MOVEQ can only be L.                       
00001578  4243                     818  CHECK_MOVEQ             CLR         D3
0000157A  3639 00001DB8            819                          MOVE.W      CURRENT_WORD,D3
00001580  0243 F000                820                          ANDI.W      #FILT_NIB_1,D3
00001584  B67C 7000                821                          CMP         #CONST_MOVEQ,D3
00001588  6700 00FC                822                          BEQ         MOVEQ_FOUND
0000158C  4E75                     823                          RTS 
0000158E                           824                          
0000158E                           825  
0000158E                           826  *-----------------------Check current word for EXT------------------------------------  
0000158E                           827  *check EXT before MOVEM, since they can be easily confused.
0000158E                           828  *EXT can be W or L.                  
0000158E  4243                     829  CHECK_EXT               CLR         D3                  
00001590  3639 00001DB8            830                          MOVE.W      CURRENT_WORD,D3
00001596  0243 FFB8                831                          ANDI.W      #FILT_EXT,D3
0000159A  B67C 4880                832                          CMP         #CONST_EXT,D3
0000159E  6700 0174                833                          BEQ         EXT_FOUND
000015A2  4E75                     834                          RTS 
000015A4                           835                          
000015A4                           836  *-----------------------Check current word for MOVEM------------------------------------  
000015A4                           837  *MOVEM can be W or L.                  
000015A4  4243                     838  CHECK_MOVEM             CLR         D3
000015A6  3639 00001DB8            839                          MOVE.W      CURRENT_WORD,D3
000015AC  0243 FB80                840                          ANDI.W      #FILT_MOVEM,D3
000015B0  B67C 8880                841                          CMP         #CONST_MOVEM,D3
000015B4  6700 0162                842                          BEQ         MOVEM_FOUND
000015B8  4E75                     843                          RTS 
000015BA                           844                          
000015BA                           845  *---------------------- END OPWORD CHECKS -----------------------------------------
000015BA                           846  
000015BA                           847  *---------------------- BEGIN CASES FOR FOUND OPCODES------------------------------
000015BA                           848  
000015BA                           849  *-----------------------MOVE-related Subroutines------------------------------------
000015BA                           850  
000015BA                           851  *-----------------------Cases for finding different MOVE OPcodes------------------------------------
000015BA                           852  *MOVE.B
000015BA  13FC 0000 00001DBA       853  MOVE_B_FOUND            MOVE.B      #BYTE_SIZE,CURRENT_OP_SIZE
000015C2  6100 FDE2                854                          BSR         DISPLAY_CURRENT_ADDRESS
000015C6  6100 0082                855                          BSR         PARSE_MOVE_DATA                           
000015CA                           856                         
000015CA  43F9 00001D43            857                          LEA         MOVE_B_MSG,A1      ; 'MOVE.B'
000015D0  103C 000E                858                          MOVE.B      #14,D0
000015D4  4E4F                     859                          TRAP        #15
000015D6                           860                          
000015D6  43F9 00001B3D            861                          LEA         SPACE,A1           ; ' '
000015DC  103C 000E                862                          MOVE.B      #14,D0      
000015E0  4E4F                     863                          TRAP        #15
000015E2                           864                          
000015E2  6100 0080                865                          BSR         DISPLAY_MOVE_DATA
000015E6  6000 FD54                866                          BRA         GO_TO_NEXT_OP
000015EA                           867  
000015EA                           868  *MOVE.W                        
000015EA  13FC 0001 00001DBA       869  MOVE_W_FOUND            MOVE.B      #WORD_SIZE,CURRENT_OP_SIZE
000015F2  6100 FDB2                870                          BSR         DISPLAY_CURRENT_ADDRESS
000015F6  6100 0052                871                          BSR         PARSE_MOVE_DATA       
000015FA                           872                          
000015FA  43F9 00001D4A            873                          LEA         MOVE_W_MSG,A1      ; 'MOVE.W'
00001600  103C 000E                874                          MOVE.B      #14,D0
00001604  4E4F                     875                          TRAP        #15
00001606                           876                          
00001606  43F9 00001B3D            877                          LEA         SPACE,A1           ; ' '
0000160C  103C 000E                878                          MOVE.B      #14,D0      
00001610  4E4F                     879                          TRAP        #15
00001612                           880                          
00001612  6100 0050                881                          BSR         DISPLAY_MOVE_DATA
00001616  6000 FD24                882                          BRA         GO_TO_NEXT_OP  
0000161A                           883  
0000161A                           884  *MOVE.L                        
0000161A  13FC 0002 00001DBA       885  MOVE_L_FOUND            MOVE.B      #LONG_SIZE,CURRENT_OP_SIZE
00001622  6100 FD82                886                          BSR         DISPLAY_CURRENT_ADDRESS
00001626  6100 0022                887                          BSR         PARSE_MOVE_DATA       
0000162A                           888                          
0000162A  43F9 00001D51            889                          LEA         MOVE_L_MSG,A1      ; 'MOVE.L'
00001630  103C 000E                890                          MOVE.B      #14,D0
00001634  4E4F                     891                          TRAP        #15
00001636                           892                          
00001636  43F9 00001B3D            893                          LEA         SPACE,A1           ; ' '
0000163C  103C 000E                894                          MOVE.B      #14,D0      
00001640  4E4F                     895                          TRAP        #15
00001642                           896                          
00001642  6100 0020                897                          BSR         DISPLAY_MOVE_DATA
00001646  6000 FCF4                898                          BRA         GO_TO_NEXT_OP 
0000164A                           899                         
0000164A                           900  *-----------------------Parse data for any-sized MOVE instruction---------------------
0000164A                           901  *Note that the size of the MOVE is stored in CURRENT_OP_SIZE.
0000164A                           902  PARSE_MOVE_DATA         ; TODO: error checking 
0000164A                           903                          ;(maybe after reading the first 4 instruction parts, but before reading additional data)
0000164A                           904                          ;IMPORTANT: remember that different MOVE error are specific to different MOVE sizes.
0000164A                           905                          ; example: MOVE.B  A0,D3 is invalid. However, MOVE.W  A0,D3 is valid.
0000164A                           906                          ;
0000164A                           907                          ; possible errors:
0000164A                           908                          ;       CURRENT_DEST_MD = CONST_IMMEDIATE_REG (immediate data cannot be a destination)
0000164A                           909                          ;       CURRENT_SRC_MD  = CONST_ADDR_REG_MD   (byte is not a valid size for this move)
0000164A                           910                          ;       CURRENT_DEST_MD = CONST_ADDR_REG_MD   (byte is not a valid size, although we should be using MOVEA at this point, not MOVE.)
0000164A                           911                          ;       TODO: figure out other possible errors.
0000164A                           912                          
0000164A                           913                          ; after we confirm that there are no errors, we know that we can safely check for additional data and display the instruction.
0000164A                           914                          
0000164A                           915                          
0000164A                           916                          ; at this point, need to read more information (parsed by EA, probably)
0000164A                           917                          ; now that we have a move instruction, we set our EA variables accordingly:
0000164A  6100 00F8                918                          BSR         READ_DEST_REG      ; EA will set CURRENT_DEST_REG.
0000164E  6100 0112                919                          BSR         READ_DEST_MODE     ; EA will set CURRENT_DEST_MD.
00001652  6100 012A                920                          BSR         READ_SOURCE_MODE   ; EA will set CURRENT_SRC_MD.
00001656  6100 0142                921                          BSR         READ_SOURCE_REG    ; EA will set CURRENT_SRC_REG.
0000165A                           922                          
0000165A                           923                          ; need to check whether we need to read additional data before we start displaying the
0000165A                           924                          ; instruction (for instance, this is necessary for MOVE.B #10,D0).
0000165A  6100 0158                925                          BSR         READ_SOURCE_DATA   ; EA will set CURRENT_SOURCE_DATA if necessary.
0000165E  6100 018E                926                          BSR         READ_DEST_DATA     ; EA will set CURRENT_DEST_DATA if necessary. 
00001662  4E75                     927                          RTS         
00001664                           928  
00001664  6100 0256                929  DISPLAY_MOVE_DATA       BSR         DISPLAY_SOURCE     ; Tell EA to parse and display the source. EX: (A1)   D3    #10   $1000 etc
00001668                           930                          
00001668  43F9 00001B41            931                          LEA         COMMA,A1           ; ','
0000166E  103C 000E                932                          MOVE.B      #14,D0      
00001672  4E4F                     933                          TRAP        #15
00001674                           934                          
00001674  6100 027C                935                          BSR         DISPLAY_DEST       ; Tell EA to parse and display the destination.
00001678                           936                          
00001678  43F9 00001B3A            937                          LEA         RETURN,A1          ; (return)
0000167E  103C 000E                938                          MOVE.B      #14,D0
00001682  4E4F                     939                          TRAP        #15
00001684                           940  
00001684  4E75                     941                          RTS        
00001686                           942                           
00001686                           943  *-----------------------MOVEQ-related Subroutines------------------------------------
00001686                           944  
00001686                           945  *-----------------------Case for finding MOVEQ------------------------------------
00001686  13FC 0002 00001DBA       946  MOVEQ_FOUND             MOVE.B      #LONG_SIZE,CURRENT_OP_SIZE
0000168E  6100 FD16                947                          BSR         DISPLAY_CURRENT_ADDRESS
00001692  6100 0022                948                          BSR         PARSE_MOVEQ_DATA       
00001696                           949                          
00001696  43F9 00001D58            950                          LEA         MOVEQ_MSG,A1      ; 'MOVEQ'
0000169C  103C 000E                951                          MOVE.B      #14,D0
000016A0  4E4F                     952                          TRAP        #15
000016A2                           953                          
000016A2  43F9 00001B3D            954                          LEA         SPACE,A1           ; ' '
000016A8  103C 000E                955                          MOVE.B      #14,D0      
000016AC  4E4F                     956                          TRAP        #15
000016AE                           957                          
000016AE  6100 0028                958                          BSR         DISPLAY_MOVEQ_DATA
000016B2  6000 FC88                959                          BRA         GO_TO_NEXT_OP  
000016B6                           960  
000016B6                           961  PARSE_MOVEQ_DATA        ;TODO: check that 0000 000X 0000 0000 equals zero. If not, error.
000016B6                           962                          
000016B6  6100 008C                963                          BSR         READ_DEST_REG                       ; EA will set CURRENT_DEST_REG.
000016BA  13FC 0000 00001DBF       964                          MOVE.B      #CONST_DATA_REG_MD,CURRENT_DEST_MD  ; data register is the only allowed destination for MOVEQ.
000016C2  6100 0036                965                          BSR         READ_MOVEQ_DATA                     ; 0000 0000 XXXX XXXX will set CURRENT_SOURCE_DATA (I think.)
000016C6                           966                          
000016C6  13FC 0007 00001DBD       967                          MOVE.B      #CONST_ADDR_MISC_MD,CURRENT_SRC_MD
000016CE  13FC 0004 00001DBE       968                          MOVE.B      #CONST_IMMEDIATE_REG,CURRENT_SRC_REG
000016D6                           969                          
000016D6  4E75                     970                          RTS 
000016D8                           971  
000016D8  6100 01E2                972  DISPLAY_MOVEQ_DATA      BSR         DISPLAY_SOURCE     ; Tell EA to parse and display the source. 
000016DC                           973                          
000016DC  43F9 00001B41            974                          LEA         COMMA,A1           ; ','
000016E2  103C 000E                975                          MOVE.B      #14,D0      
000016E6  4E4F                     976                          TRAP        #15
000016E8                           977                          
000016E8  6100 0208                978                          BSR         DISPLAY_DEST       ; Tell EA to parse and display the destination.
000016EC                           979                          
000016EC  43F9 00001B3A            980                          LEA         RETURN,A1          ; (return)
000016F2  103C 000E                981                          MOVE.B      #14,D0
000016F6  4E4F                     982                          TRAP        #15
000016F8                           983  
000016F8  4E75                     984                          RTS        
000016FA                           985  
000016FA                           986  ;NOTE: this SR is stored here and not in EA because it is specific to MOVEQ.
000016FA  4244                     987  READ_MOVEQ_DATA         CLR         D4
000016FC  4279 00001DC6            988                          CLR         CURRENT_SRC_DATA
00001702  3839 00001DB8            989                          MOVE.W      CURRENT_WORD,D4
00001708  0244 00FF                990                          ANDI.W      #FILT_MOVEQ_DATA,D4        ; turn D4 into 0000 0000 XXXX XXXX (no shift necessary)
0000170C  33C4 00001DC6            991                          MOVE.W      D4,CURRENT_SRC_DATA
00001712  4E75                     992                          RTS
00001714                           993                      
00001714                           994    ; TODO: (in order)
00001714                           995      *   -MOVEM  (W,L)
00001714                           996      *   -ADD    (B,W,L) (will need shahin's size filter for this and below)
00001714                           997      *   -ADDA   (W,L)
00001714                           998      *   -ADDI   (B,W,L)
00001714                           999      *   -SUB    (B,W,L)
00001714                          1000    ; see comment block at the top of the program for the full list of codes.
00001714                          1001    ; see huge comment block at the top of OPcode section for tentative OPcode parsing implementation plan.
00001714                          1002   
00001714                          1003  *-----------------------EXT-related Subroutines------------------------------------
00001714  4EF8 1004               1004  EXT_FOUND               JMP         STOP ;TODO: case for EXT found
00001718                          1005  
00001718                          1006  *-----------------------MOVEM-related Subroutines------------------------------------
00001718  4EF8 1004               1007  MOVEM_FOUND             JMP         STOP ;TODO: case for MOVEM found (currently the next goal)      
0000171C                          1008    
0000171C                          1009  *-----------------------ORI-related Subroutines------------------------------------
0000171C  4EF8 1004               1010  ORI_FOUND               JMP         STOP ;TODO: case for ORI found
00001720                          1011  
00001720                          1012   *----------------------ANDI-related Subroutines------------------------------------
00001720  4EF8 1004               1013  ANDI_FOUND              JMP         STOP ;TODO: case for ANDI found
00001724                          1014  
00001724                          1015   *----------------------SUBI-related Subroutines------------------------------------
00001724  4EF8 1004               1016  SUBI_FOUND              JMP         STOP ;TODO: case for SUBI found
00001728                          1017  
00001728                          1018   *----------------------ADDI-related Subroutines------------------------------------
00001728  4EF8 1004               1019  ADDI_FOUND              JMP         STOP ;TODO: case for ADDI found
0000172C                          1020   
0000172C                          1021  *-----------------------EORI-related Subroutines------------------------------------
0000172C  4EF8 1004               1022  EORI_FOUND              JMP         STOP ;TODO: case for EORI found
00001730                          1023   
00001730                          1024  *-----------------------CMPI-related Subroutines------------------------------------
00001730  4EF8 1004               1025  CMPI_FOUND              JMP         STOP ;TODO: case for CMPI found
00001734                          1026  
00001734                          1027  *-----------------------NEGX-related Subroutines------------------------------------
00001734  4EF8 1004               1028  NEGX_FOUND              JMP         STOP ;TODO: case for NEGX found 
00001738                          1029  
00001738                          1030  *-----------------------CLR-related Subroutines------------------------------------
00001738  4EF8 1004               1031  CLR_FOUND               JMP         STOP ;TODO: case for CLR found 
0000173C                          1032  
0000173C                          1033  *-----------------------NEG-related Subroutines------------------------------------
0000173C  4EF8 1004               1034  NEG_FOUND               JMP         STOP ;TODO: case for NEG found 
00001740                          1035  
00001740                          1036  *-----------------------NOT-related Subroutines------------------------------------
00001740  4EF8 1004               1037  NOT_FOUND               JMP         STOP ;TODO: case for NOT found 
00001744                          1038                      
00001744                          1039  *###################### END OPCODE ##################################
00001744                          1040  *###################### BEGIN EA ##################################
00001744                          1041  *** EA Subroutines are kept here ***
00001744                          1042  *----------------------Check the destination register of the current word.-------------
00001744  4244                    1043  READ_DEST_REG           CLR         D4
00001746  4239 00001DC0           1044                          CLR.B       CURRENT_DEST_REG
0000174C  3839 00001DB8           1045                          MOVE.W      CURRENT_WORD,D4
00001752  0244 0E00               1046                          ANDI.W      #FILT_DEST_REG,D4       ; turn D4 into 0000 XXX0 0000 0000
00001756  E04C                    1047                          LSR.W       #8,D4                   ; turn D4 into 0000 0000 0000 0XXX
00001758  E24C                    1048                          LSR.W       #1,D4                   ; 9 would be invalid, so we shift 8, then 1
0000175A  13C4 00001DC0           1049                          MOVE.B      D4,CURRENT_DEST_REG
00001760  4E75                    1050                          RTS
00001762                          1051  
00001762                          1052  *----------------------Check the destination mode of the current word.-------------
00001762                          1053  *(assuming the destination is where it would be in MOVE).
00001762  4244                    1054  READ_DEST_MODE          CLR         D4
00001764  4239 00001DBF           1055                          CLR.B       CURRENT_DEST_MD
0000176A  3839 00001DB8           1056                          MOVE.W      CURRENT_WORD,D4
00001770  0244 01C0               1057                          ANDI.W      #FILT_DEST_MD,D4        ; turn D4 into 0000 000X XX00 0000
00001774  EC4C                    1058                          LSR.W       #6,D4                   ; turn D4 into 0000 0000 0000 0XXX
00001776  13C4 00001DBF           1059                          MOVE.B      D4,CURRENT_DEST_MD
0000177C  4E75                    1060                          RTS
0000177E                          1061  
0000177E                          1062  ;By this point, CURRENT WORD holds the first 16 bits of an instruction we are looking at.
0000177E                          1063  ;(we should already know the OPcode by this point, so this will be called by various OPcode subroutines.)
0000177E                          1064  *---------------------- Check the source mode of the current word.--------------------
0000177E                          1065  *(assuming the source is where it would be in MOVE).
0000177E  4244                    1066  READ_SOURCE_MODE        CLR         D4
00001780  4239 00001DBD           1067                          CLR.B       CURRENT_SRC_MD
00001786  3839 00001DB8           1068                          MOVE.W      CURRENT_WORD,D4
0000178C  0244 0038               1069                          ANDI.W      #FILT_SRC_MD,D4                 ; turn source mode into 0000 0000 00XX X000
00001790  E64C                    1070                          LSR.W       #3,D4                           ; turn source mode into 0000 0000 0000 0XXX
00001792  13C4 00001DBD           1071                          MOVE.B      D4,CURRENT_SRC_MD
00001798  4E75                    1072                          RTS
0000179A                          1073                          
0000179A                          1074  *----------------------Check the source register of the current word.-----------------
0000179A  4244                    1075  READ_SOURCE_REG         CLR         D4
0000179C  4239 00001DBE           1076                          CLR.B       CURRENT_SRC_REG
000017A2  3839 00001DB8           1077                          MOVE.W      CURRENT_WORD,D4
000017A8  0244 0007               1078                          ANDI.W      #FILT_SRC_REG,D4        ; turn D4 into 0000 0000 0000 0XXX. (no need for LSR in this case.)
000017AC  13C4 00001DBE           1079                          MOVE.B      D4,CURRENT_SRC_REG
000017B2  4E75                    1080                          RTS
000017B4                          1081  *--------TODO: READ_OP_SIZE---------
000017B4                          1082                         
000017B4                          1083  *----------------------Read additional source data associated with the current word (if necessary).----------------- 
000017B4                          1084  *This needs to postincrement A5 as necessary.
000017B4  4279 00001DC6           1085  READ_SOURCE_DATA        CLR         CURRENT_SRC_DATA
000017BA  4279 00001DC2           1086                          CLR         CURRENT_DATA
000017C0  0C39 0007 00001DBD      1087                          CMP.B       #CONST_ADDR_MISC_MD,CURRENT_SRC_MD ; check the source mode
000017C8  6700 0004               1088                          BEQ         CONFIRM_READ_SRC_DATA              ; see if we have a source mode that requires additional data.               
000017CC  4E75                    1089                          RTS
000017CE                          1090                          
000017CE  4239 00001DBC           1091  CONFIRM_READ_SRC_DATA   CLR.B       CURRENT_REG
000017D4  13F9 00001DBE 00001DBC  1092                          MOVE.B      CURRENT_SRC_REG,CURRENT_REG
000017DE  6100 0048               1093                          BSR         CONFIRM_READ_DATA
000017E2  23F9 00001DC2 00001DC6  1094                          MOVE.L      CURRENT_DATA,CURRENT_SRC_DATA
000017EC  4E75                    1095                          RTS
000017EE                          1096   
000017EE                          1097  *----------------------Read additional destination data associated with the current word (if necessary).----------------- 
000017EE                          1098  *This needs to postincrement A5 as necessary.                       
000017EE  4279 00001DCA           1099  READ_DEST_DATA          CLR         CURRENT_DEST_DATA
000017F4  4279 00001DC2           1100                          CLR         CURRENT_DATA
000017FA  0C39 0007 00001DBF      1101                          CMP.B       #CONST_ADDR_MISC_MD,CURRENT_DEST_MD  ; check the destination mode.
00001802  6700 0004               1102                          BEQ         CONFIRM_READ_DEST_DATA               ; see if we have a destination mode that requires additional data.                  
00001806  4E75                    1103                          RTS
00001808                          1104                                              
00001808  4239 00001DBC           1105  CONFIRM_READ_DEST_DATA  CLR.B       CURRENT_REG
0000180E  13F9 00001DC0 00001DBC  1106                          MOVE.B      CURRENT_DEST_REG,CURRENT_REG
00001818  6100 000E               1107                          BSR         CONFIRM_READ_DATA
0000181C  23F9 00001DC2 00001DCA  1108                          MOVE.L      CURRENT_DATA,CURRENT_DEST_DATA
00001826  4E75                    1109                          RTS
00001828                          1110  
00001828                          1111  *-----------------------Read some additional data.----------------------------------------------------------
00001828                          1112        ; This same subroutine is used for reading source and destination data.
00001828                          1113        ; By this point, CURRENT_REG holds whatever register we currently care about. (could also use CURRENT_REG)         
00001828  0C39 0002 00001DBC      1114  CONFIRM_READ_DATA       CMP.B       #CONST_COUNTR_DISPLC_REG,CURRENT_REG      ; see if we are reading counter w/ displacement
00001830  6700 0034               1115                          BEQ         READ_COUNTR_DISPLC_DATA
00001834                          1116                     
00001834  0C39 0003 00001DBC      1117                          CMP.B       #CONST_COUNTR_INDEX_REG,CURRENT_REG       ; see if we are reading counter w/ index
0000183C  6700 002A               1118                          BEQ         READ_COUNTR_INDEX_DATA
00001840                          1119                          
00001840  0C39 0000 00001DBC      1120                          CMP.B       #CONST_ABS_SHORT_REG,CURRENT_REG          ; see if we are reading absolute short address
00001848  6700 0020               1121                          BEQ         READ_ABS_SHORT_DATA
0000184C                          1122                          
0000184C  0C39 0001 00001DBC      1123                          CMP.B       #CONST_ABS_LONG_REG,CURRENT_REG           ; see if we are reading absolute long address
00001854  6700 001C               1124                          BEQ         READ_ABS_LONG_DATA 
00001858                          1125                          
00001858  0C39 0004 00001DBC      1126                          CMP.B       #CONST_IMMEDIATE_REG,CURRENT_REG          ; see if we are reading immediate data
00001860  6700 0018               1127                          BEQ         READ_IMMEDIATE_DATA
00001864                          1128       
00001864  4E75                    1129                          RTS
00001866                          1130                          
00001866                          1131  ; TODO: each of these SRs should increment A5 by the proper amount while also storing the correct data in CURRENT_DATA.
00001866  4E75                    1132  READ_COUNTR_DISPLC_DATA RTS ; TODO: read data for counter w/ displacement (d16,PC)
00001868                          1133  
00001868  4E75                    1134  READ_COUNTR_INDEX_DATA  RTS ; TODO: read data for counter w/ index        (d16,PC,Xn)
0000186A                          1135  
0000186A                          1136  *-----------------------Read additional absolute word address---------------------------
0000186A  33DD 00001DC2           1137  READ_ABS_SHORT_DATA     MOVE.W      (A5)+,CURRENT_DATA ; read data for absolute short address  (xxx).W
00001870  4E75                    1138                          RTS
00001872                          1139                          
00001872                          1140  *-----------------------Read additional absolute long address---------------------------
00001872  23DD 00001DC2           1141  READ_ABS_LONG_DATA      MOVE.L      (A5)+,CURRENT_DATA ; read data for absolute long address   (xxx).L
00001878  4E75                    1142                          RTS 
0000187A                          1143  
0000187A                          1144  *-----------------------Read additional immediate data---------------------------
0000187A  0C39 0000 00001DBA      1145  READ_IMMEDIATE_DATA     CMP.B       #BYTE_SIZE,CURRENT_OP_SIZE   ; see if we are reading immediate byte data
00001882  6700 001C               1146                          BEQ         READ_IMMEDIATE_DATA_W
00001886                          1147                          
00001886  0C39 0001 00001DBA      1148                          CMP.B       #WORD_SIZE,CURRENT_OP_SIZE   ; see if we are reading immediate word data
0000188E  6700 0010               1149                          BEQ         READ_IMMEDIATE_DATA_W
00001892                          1150                          
00001892  0C39 0002 00001DBA      1151                          CMP.B       #LONG_SIZE,CURRENT_OP_SIZE   ; see if we are reading immediate long data
0000189A  6700 0012               1152                          BEQ         READ_IMMEDIATE_DATA_L
0000189E                          1153                          ;TODO: error case goes here
0000189E  4E75                    1154                          RTS
000018A0                          1155  
000018A0  4279 00001DC2           1156  READ_IMMEDIATE_DATA_W   CLR         CURRENT_DATA
000018A6  33DD 00001DC2           1157                          MOVE.W      (A5)+,CURRENT_DATA
000018AC  4E75                    1158                          RTS
000018AE                          1159                          
000018AE  4279 00001DC2           1160  READ_IMMEDIATE_DATA_L   CLR         CURRENT_DATA
000018B4  23DD 00001DC2           1161                          MOVE.L      (A5)+,CURRENT_DATA
000018BA  4E75                    1162                          RTS
000018BC                          1163                          
000018BC                          1164  *----------------------Display the source for the current instruction.-----------------
000018BC                          1165  *by this point, error checking should already be done and CURRENT_SRC_MD and CURRENT_SRC_REG should have the data we need.
000018BC  4239 00001DBB           1166  DISPLAY_SOURCE          CLR.B       CURRENT_MD
000018C2  4239 00001DBC           1167                          CLR.B       CURRENT_REG
000018C8  42B9 00001DC2           1168                          CLR.L       CURRENT_DATA
000018CE                          1169                          
000018CE  13F9 00001DBD 00001DBB  1170                          MOVE.B      CURRENT_SRC_MD,CURRENT_MD
000018D8  13F9 00001DBE 00001DBC  1171                          MOVE.B      CURRENT_SRC_REG,CURRENT_REG    
000018E2  23F9 00001DC6 00001DC2  1172                          MOVE.L      CURRENT_SRC_DATA,CURRENT_DATA
000018EC  6100 003A               1173                          BSR         CHECK_ADDRESSING_MODES   
000018F0  4E75                    1174                          RTS  
000018F2                          1175                          
000018F2                          1176  *----------------------Display the destination for the current instruction.-----------------
000018F2                          1177  *by this point, error checking should already be done and CURRENT_DEST_MD and CURRENT_DEST_REG should have the data we need.
000018F2  4239 00001DBB           1178  DISPLAY_DEST            CLR.B       CURRENT_MD
000018F8  4239 00001DBC           1179                          CLR.B       CURRENT_REG
000018FE  42B9 00001DC2           1180                          CLR.L       CURRENT_DATA
00001904                          1181                          
00001904  13F9 00001DBF 00001DBB  1182                          MOVE.B      CURRENT_DEST_MD,CURRENT_MD
0000190E  13F9 00001DC0 00001DBC  1183                          MOVE.B      CURRENT_DEST_REG,CURRENT_REG    
00001918  23F9 00001DCA 00001DC2  1184                          MOVE.L      CURRENT_DEST_DATA,CURRENT_DATA
00001922  6100 0004               1185                          BSR         CHECK_ADDRESSING_MODES     
00001926  4E75                    1186                          RTS  
00001928                          1187                          
00001928                          1188  
00001928                          1189                          
00001928                          1190  *-----------------------Mode checks (for displaying)---------
00001928                          1191  *these do not care whether the mode is for source or destination.
00001928  0C39 0000 00001DBB      1192  CHECK_ADDRESSING_MODES  CMP.B       #CONST_DATA_REG_MD,CURRENT_MD   ; check for CURRENT_MD = ...0000
00001930  6700 0058               1193                          BEQ         DISPLAY_DATA_REG
00001934  0C39 0001 00001DBB      1194                          CMP.B       #CONST_ADDR_REG_MD,CURRENT_MD    ; check for CURRENT_MD = ...0001
0000193C  6700 006C               1195                          BEQ         DISPLAY_ADDR_REG
00001940  0C39 0002 00001DBB      1196                          CMP.B       #CONST_ADDR_IND_MD,CURRENT_MD    ; check for CURRENT_MD = ...0010
00001948  6700 0080               1197                          BEQ         DISPLAY_ADDR_IND
0000194C  0C39 0003 00001DBB      1198                          CMP.B       #CONST_ADDR_INCR_MD,CURRENT_MD   ; check for CURRENT_MD = ...0011
00001954  6700 00AC               1199                          BEQ         DISPLAY_ADDR_INCR
00001958  0C39 0004 00001DBB      1200                          CMP.B       #CONST_ADDR_DECR_MD,CURRENT_MD   ; check for CURRENT_MD = ...0100
00001960  6700 00E4               1201                          BEQ         DISPLAY_ADDR_DECR
00001964  0C39 0005 00001DBB      1202                          CMP.B       #CONST_ADDR_DISPLC_MD,CURRENT_MD ; check for CURRENT_MD = ...0101
0000196C  6700 011C               1203                          BEQ         DISPLAY_ADDR_DISPLC
00001970  0C39 0006 00001DBB      1204                          CMP.B       #CONST_ADDR_INDEX_MD,CURRENT_MD  ; check for CURRENT_MD = ...0110
00001978  6700 0112               1205                          BEQ         DISPLAY_ADDR_INDEX
0000197C  0C39 0007 00001DBB      1206                          CMP.B       #CONST_ADDR_MISC_MD,CURRENT_MD   ; check for CURRENT_MD = ...0111
00001984  6700 0108               1207                          BEQ         CHECK_MISC_ADDRESSINGS
00001988                          1208                          ;TODO: error cases? 
00001988  4E75                    1209                          RTS
0000198A                          1210  
0000198A                          1211  ; case for displaying data register.          
0000198A  43F9 00001D5E           1212  DISPLAY_DATA_REG        LEA         MSG_D,A1               ; print out 'D' (later, send this to dislpay buffer)
00001990  103C 000E               1213                          MOVE.B      #14,D0
00001994  4E4F                    1214                          TRAP        #15
00001996                          1215                          
00001996  4241                    1216                          CLR         D1
00001998  1239 00001DBC           1217                          MOVE.B      (CURRENT_REG),D1      ; print out the number of the data register.
0000199E  143C 0010               1218                          MOVE.B      #16,D2
000019A2  103C 000F               1219                          MOVE.B      #15,D0
000019A6  4E4F                    1220                          TRAP        #15
000019A8                          1221                          
000019A8  4E75                    1222                          RTS
000019AA                          1223  
000019AA                          1224  ; case for displaying address register. 
000019AA  43F9 00001D60           1225  DISPLAY_ADDR_REG        LEA         MSG_A,A1               ; print out 'A'
000019B0  103C 000E               1226                          MOVE.B      #14,D0
000019B4  4E4F                    1227                          TRAP        #15
000019B6                          1228                          
000019B6  4241                    1229                          CLR         D1
000019B8  1239 00001DBC           1230                          MOVE.B      (CURRENT_REG),D1       ; print out the number of the data register.
000019BE  143C 0010               1231                          MOVE.B      #16,D2
000019C2  103C 000F               1232                          MOVE.B      #15,D0
000019C6  4E4F                    1233                          TRAP        #15
000019C8                          1234                          
000019C8  4E75                    1235                          RTS
000019CA                          1236  
000019CA                          1237  ; case for displaying address register indirect.                        
000019CA  43F9 00001B45           1238  DISPLAY_ADDR_IND        LEA         OPEN_PARENS,A1         ; print out '(' (later, send this to dislpay buffer)
000019D0  103C 000E               1239                          MOVE.B      #14,D0
000019D4  4E4F                    1240                          TRAP        #15
000019D6                          1241                          
000019D6  43F9 00001D60           1242                          LEA         MSG_A,A1               ; print out 'A'
000019DC  103C 000E               1243                          MOVE.B      #14,D0
000019E0  4E4F                    1244                          TRAP        #15
000019E2                          1245                          
000019E2  4241                    1246                          CLR         D1
000019E4  1239 00001DBC           1247                          MOVE.B      (CURRENT_REG),D1      ; print out the number of the data register.
000019EA  143C 0010               1248                          MOVE.B      #16,D2
000019EE  103C 000F               1249                          MOVE.B      #15,D0
000019F2  4E4F                    1250                          TRAP        #15
000019F4                          1251                          
000019F4  43F9 00001B47           1252                          LEA         CLOSE_PARENS,A1       ; print out ')'
000019FA  103C 000E               1253                          MOVE.B      #14,D0
000019FE  4E4F                    1254                          TRAP        #15
00001A00                          1255                          
00001A00  4E75                    1256                          RTS
00001A02                          1257  
00001A02                          1258  ; case for displaying address indirect postincrement.
00001A02  43F9 00001B45           1259  DISPLAY_ADDR_INCR       LEA         OPEN_PARENS,A1        ; print out '(' (later, send this to dislpay buffer)
00001A08  103C 000E               1260                          MOVE.B      #14,D0
00001A0C  4E4F                    1261                          TRAP        #15
00001A0E                          1262                          
00001A0E  43F9 00001D60           1263                          LEA         MSG_A,A1              ; print out 'A'
00001A14  103C 000E               1264                          MOVE.B      #14,D0
00001A18  4E4F                    1265                          TRAP        #15
00001A1A                          1266                          
00001A1A  4241                    1267                          CLR         D1
00001A1C  1239 00001DBC           1268                          MOVE.B      (CURRENT_REG),D1      ; print out the number of the data register.
00001A22  143C 0010               1269                          MOVE.B      #16,D2
00001A26  103C 000F               1270                          MOVE.B      #15,D0
00001A2A  4E4F                    1271                          TRAP        #15
00001A2C                          1272                          
00001A2C  43F9 00001B47           1273                          LEA         CLOSE_PARENS,A1       ; print out ')'
00001A32  103C 000E               1274                          MOVE.B      #14,D0
00001A36  4E4F                    1275                          TRAP        #15
00001A38                          1276                          
00001A38  43F9 00001B49           1277                          LEA         PLUS,A1               ; print out '+'
00001A3E  103C 000E               1278                          MOVE.B      #14,D0
00001A42  4E4F                    1279                          TRAP        #15
00001A44                          1280                          
00001A44  4E75                    1281                          RTS
00001A46                          1282                          
00001A46                          1283  ; case for displaying address indirect preedecrement mode.
00001A46  43F9 00001B4B           1284  DISPLAY_ADDR_DECR       LEA         MINUS,A1               ; print out '-'
00001A4C  103C 000E               1285                          MOVE.B      #14,D0
00001A50  4E4F                    1286                          TRAP        #15                                           
00001A52                          1287  
00001A52  43F9 00001B45           1288                          LEA         OPEN_PARENS,A1        ; print out '(' (later, send this to dislpay buffer)
00001A58  103C 000E               1289                          MOVE.B      #14,D0
00001A5C  4E4F                    1290                          TRAP        #15
00001A5E                          1291                          
00001A5E  43F9 00001D60           1292                          LEA         MSG_A,A1              ; print out 'A'
00001A64  103C 000E               1293                          MOVE.B      #14,D0
00001A68  4E4F                    1294                          TRAP        #15
00001A6A                          1295                          
00001A6A  4241                    1296                          CLR         D1
00001A6C  1239 00001DBC           1297                          MOVE.B      (CURRENT_REG),D1      ; print out the number of the data register.
00001A72  143C 0010               1298                          MOVE.B      #16,D2
00001A76  103C 000F               1299                          MOVE.B      #15,D0
00001A7A  4E4F                    1300                          TRAP        #15
00001A7C                          1301                          
00001A7C  43F9 00001B47           1302                          LEA         CLOSE_PARENS,A1       ; print out ')'
00001A82  103C 000E               1303                          MOVE.B      #14,D0
00001A86  4E4F                    1304                          TRAP        #15
00001A88                          1305                          
00001A88  4E75                    1306                          RTS     
00001A8A                          1307  
00001A8A                          1308  DISPLAY_ADDR_DISPLC     ;TODO: case for source mode is address with displacement mode.
00001A8A  4E75                    1309                          RTS    
00001A8C                          1310  
00001A8C                          1311  DISPLAY_ADDR_INDEX      ;TODO: case for source mode is address with index mode.
00001A8C  4E75                    1312                          RTS 
00001A8E                          1313  
00001A8E                          1314  *-----------------------Register checks (for displaying only)---------
00001A8E                          1315  *these do not care whether the register is for source or destination.
00001A8E                          1316  *not for cases where reg is simply a number (like D5, A5, (A5), etc),
00001A8E                          1317  *only for miscellaneous addressings where mode is 111.                        
00001A8E  0C39 0002 00001DBC      1318  CHECK_MISC_ADDRESSINGS  CMP.B       #CONST_COUNTR_DISPLC_REG,CURRENT_REG
00001A96  6700 0034               1319                          BEQ         DISPLAY_COUNTR_DISPLC
00001A9A                          1320                          
00001A9A  0C39 0003 00001DBC      1321                          CMP.B       #CONST_COUNTR_INDEX_REG,CURRENT_REG
00001AA2  6700 002A               1322                          BEQ         DISPLAY_COUNTR_INDEX
00001AA6                          1323                          
00001AA6  0C39 0000 00001DBC      1324                          CMP.B       #CONST_ABS_SHORT_REG,CURRENT_REG
00001AAE  6700 0020               1325                          BEQ         DISPLAY_ABS_SHORT
00001AB2                          1326                          
00001AB2  0C39 0001 00001DBC      1327                          CMP.B       #CONST_ABS_LONG_REG,CURRENT_REG
00001ABA  6700 0034               1328                          BEQ         DISPLAY_ABS_LONG
00001ABE                          1329                          
00001ABE  0C39 0004 00001DBC      1330                          CMP.B       #CONST_IMMEDIATE_REG,CURRENT_REG
00001AC6  6700 0048               1331                          BEQ         DISPLAY_IMMEDIATE
00001ACA                          1332                          
00001ACA                          1333                          ; TODO: error case?
00001ACA                          1334                          
00001ACA  4E75                    1335                          RTS
00001ACC                          1336                          
00001ACC  4E75                    1337  DISPLAY_COUNTR_DISPLC   RTS         ;TODO   
00001ACE                          1338  
00001ACE  4E75                    1339  DISPLAY_COUNTR_INDEX    RTS         ;TODO   
00001AD0                          1340  
00001AD0  43F9 00001B3F           1341  DISPLAY_ABS_SHORT       LEA         DOLLAR,A1             ; print out '$'. 
00001AD6  103C 000E               1342                          MOVE.B      #14,D0
00001ADA  4E4F                    1343                          TRAP        #15
00001ADC                          1344  
00001ADC  4241                    1345                          CLR         D1
00001ADE  3239 00001DC2           1346                          MOVE.W      (CURRENT_DATA),D1     ; print out the absolute short address we are concerned with in hex. 
00001AE4  143C 0010               1347                          MOVE.B      #16,D2
00001AE8  103C 000F               1348                          MOVE.B      #15,D0
00001AEC  4E4F                    1349                          TRAP        #15
00001AEE                          1350                          
00001AEE  4E75                    1351                          RTS 
00001AF0                          1352  
00001AF0  43F9 00001B3F           1353  DISPLAY_ABS_LONG        LEA         DOLLAR,A1             ; print out '$'. 
00001AF6  103C 000E               1354                          MOVE.B      #14,D0
00001AFA  4E4F                    1355                          TRAP        #15
00001AFC                          1356  
00001AFC  4241                    1357                          CLR         D1
00001AFE  2239 00001DC2           1358                          MOVE.L      (CURRENT_DATA),D1     ; print out the absolute long address we are concerned with in hex. 
00001B04  143C 0010               1359                          MOVE.B      #16,D2
00001B08  103C 000F               1360                          MOVE.B      #15,D0
00001B0C  4E4F                    1361                          TRAP        #15
00001B0E                          1362                          
00001B0E  4E75                    1363                          RTS 
00001B10                          1364  
00001B10  43F9 00001B43           1365  DISPLAY_IMMEDIATE       LEA         HASH,A1               ; print out '#'. (NOTE: should send this to display buffer instead.)
00001B16  103C 000E               1366                          MOVE.B      #14,D0
00001B1A  4E4F                    1367                          TRAP        #15
00001B1C                          1368                          
00001B1C  43F9 00001B3F           1369                          LEA         DOLLAR,A1             ; print out '$'. (this saves time since we can more easily find the hex value of the immediate data.)
00001B22  103C 000E               1370                          MOVE.B      #14,D0
00001B26  4E4F                    1371                          TRAP        #15
00001B28                          1372                          
00001B28  3239 00001DC2           1373                          MOVE.W      (CURRENT_DATA),D1     ; print out the immediate data we are concerned with in hex. 
00001B2E  143C 0010               1374                          MOVE.B      #16,D2
00001B32  103C 000F               1375                          MOVE.B      #15,D0
00001B36  4E4F                    1376                          TRAP        #15
00001B38                          1377                          
00001B38  4E75                    1378                          RTS
00001B3A                          1379                          
00001B3A                          1380  *###################### END EA ##################################
00001B3A                          1381  *############# BEGIN VARIABLES/CONSTANTS #########################
00001B3A                          1382  *** Variables and Constants are kept here ***
00001B3A                          1383  
00001B3A                          1384  *output characters
00001B3A  =0000000D               1385  CR                      EQU         $0D
00001B3A  =0000000A               1386  LF                      EQU         $0A
00001B3A= 0D 0A 00                1387  RETURN                  DC.B        CR,LF,0
00001B3D= 20 00                   1388  SPACE                   DC.B        ' ',0
00001B3F= 24 00                   1389  DOLLAR                  DC.B        '$',0
00001B41= 2C 00                   1390  COMMA                   DC.B        ',',0
00001B43= 23 00                   1391  HASH                    DC.B        '#',0
00001B45= 28 00                   1392  OPEN_PARENS             DC.B        '(',0
00001B47= 29 00                   1393  CLOSE_PARENS            DC.B        ')',0
00001B49= 2B 00                   1394  PLUS                    DC.B        '+',0
00001B4B= 2D 00                   1395  MINUS                   DC.B        '-',0
00001B4D                          1396  
00001B4D                          1397  *output messages
00001B4D                          1398      ;TODO: consider also giving the user the range of valid start/end addresses
00001B4D= 50 6C 65 61 73 65 ...   1399  START_ADDR_MSG          DC.B        'Please enter a starting hex address to read from.',CR,LF,0
00001B81= 50 6C 65 61 73 65 ...   1400  END_ADDR_MSG            DC.B        'Please enter an ending hex address to read from.',CR,LF,0
00001BB4                          1401  
00001BB4= 4E 6F 74 20 61 20 ...   1402  INVALID_LEN_MSG         DC.B        'Not a valid length for input address.',CR,LF
00001BDB= 50 6C 65 61 73 65 ...   1403                          DC.B        'Please enter a valid-length address.',CR,LF,0
00001C02= 4E 6F 74 20 61 20 ...   1404  INVALID_ADDR_MSG        DC.B        'Not a valid address.',CR,LF
00001C18= 50 6C 65 61 73 65 ...   1405                          DC.B        'Please enter a valid address.',CR,LF,0
00001C38= 4E 6F 74 20 61 20 ...   1406  INVALID_END_ADDR_MSG    DC.B        'Not a valid end address.',CR,LF
00001C52= 50 6C 65 61 73 65 ...   1407                          DC.B        'Please enter an end address after the start address.',CR,LF,0
00001C89                          1408                        
00001C89= 4E 6F 74 20 61 20 ...   1409  INVALID_ADDR_L_MSG      DC.B        'Not a valid address (too low).',CR,LF
00001CA9= 50 6C 65 61 73 65 ...   1410                          DC.B        'Please enter a valid address.',CR,LF,0
00001CC9                          1411                          
00001CC9= 4E 6F 74 20 61 20 ...   1412  INVALID_ADDR_H_MSG      DC.B        'Not a valid address (too high).',CR,LF
00001CEA= 50 6C 65 61 73 65 ...   1413                          DC.B        'Please enter a valid address.',CR,LF,0
00001D0A                          1414                          
00001D0A= 44 6F 6E 65 20 72 ...   1415  DONE_READING_MSG        DC.B        'Done reading the program.',CR,LF,0
00001D26                          1416  
00001D26                          1417  *output instruction names (OPcodes)
00001D26                          1418      ;sizes
00001D26= 2E 42 00                1419  BYTE_SIZE_MSG           DC.B        '.B',0
00001D29= 2E 57 00                1420  WORD_SIZE_MSG           DC.B        '.W',0
00001D2C= 2E 4C 00                1421  LONG_SIZE_MSG           DC.B        '.L',0
00001D2F                          1422  
00001D2F                          1423      ;constants
00001D2F= 52 45 53 45 54 00       1424  RESET_MSG               DC.B        'RESET',0
00001D35= 4E 4F 50 00             1425  NOP_MSG                 DC.B        'NOP',0
00001D39= 53 54 4F 50 00          1426  STOP_MSG                DC.B        'STOP',0
00001D3E                          1427      ;moves
00001D3E= 4D 4F 56 45 00          1428  MOVE_MSG                DC.B        'MOVE',0
00001D43= 4D 4F 56 45 2E 42 00    1429  MOVE_B_MSG              DC.B        'MOVE.B',0
00001D4A= 4D 4F 56 45 2E 57 00    1430  MOVE_W_MSG              DC.B        'MOVE.W',0
00001D51= 4D 4F 56 45 2E 4C 00    1431  MOVE_L_MSG              DC.B        'MOVE.L',0
00001D58                          1432  
00001D58= 4D 4F 56 45 51 00       1433  MOVEQ_MSG               DC.B        'MOVEQ',0
00001D5E                          1434  
00001D5E                          1435  *other output instruction message constants
00001D5E= 44 00                   1436  MSG_D                   DC.B        'D',0
00001D60= 41 00                   1437  MSG_A                   DC.B        'A',0
00001D62                          1438  
00001D62                          1439  *storage locations for input
00001D62                          1440  START_ADDR_IN           DS.B        20
00001D76                          1441  
00001D76                          1442  *other I/O-related variables/constants
00001D76  =00000001               1443  INPUTTING_START         SET         1 ;if 1, we are inputting start address. If 0, we are inputting end address.
00001D76                          1444  OPCODE_BUFFER           DS.L        1 ; can hold at most 4 characters
00001D7A                          1445  SIZE_BUFFER             DS.W        1 ;cand hold at most 2 characters
00001D7C                          1446  DISPLAY_BUFFER          DS.W        5
00001D86= 52 65 73 74 61 72 ...   1447  RESTART_PROMPT_MSG      DC.B        'Restart? (y/n)',0
00001D95= 54 68 61 74 20 69 ...   1448  RESTART_ERROR_STR       DC.B        'That is not a valid response.',CR,LF,0
00001DB5= 0D 0A 00                1449  NEWLINE                 DC.B        CR,LF,0
00001DB8                          1450  
00001DB8                          1451  *EA/OPcode parsed instruction variables/constants
00001DB8                          1452  CURRENT_WORD            DS.W        1 ; current first 16 bits of an instruction.
00001DBA                          1453  CURRENT_OP_SIZE         DS.B        1 ; current operation size. Byte = 01, Word = 11, Long = 10
00001DBB                          1454  
00001DBB                          1455  CURRENT_MD              DS.B        1 ; current mode we are concerened with (ex: 000 for data register mode.)
00001DBC                          1456  CURRENT_REG             DS.B        1 ; current register number we are concerned with(address, data, etc) that we are looking at. Ex: D0,A5,etc
00001DBD                          1457  
00001DBD                          1458  CURRENT_SRC_MD          DS.B        1 ; current source mode
00001DBE                          1459  CURRENT_SRC_REG         DS.B        1 ; current source register
00001DBF                          1460  CURRENT_DEST_MD         DS.B        1 ; current desination mode
00001DC0                          1461  CURRENT_DEST_REG        DS.B        1 ; current desination register
00001DC1                          1462  
00001DC2                          1463  CURRENT_DATA            DS.L        1 ; current addition data we are concerned with
00001DC6                          1464  CURRENT_SRC_DATA        DS.L        1 ; current additional data for source (like absolute addresses, immediate data, etc)
00001DCA                          1465  CURRENT_DEST_DATA       DS.L        1 ; current additional data for destination (like absolute addresses, immediate data, etc) 
00001DCE                          1466  
00001DCE                          1467  *size constants
00001DCE  =00000000               1468  BYTE_SIZE                EQU         $00 ; 0000 0000
00001DCE  =00000001               1469  WORD_SIZE                EQU         $01 ; 0000 0001
00001DCE  =00000002               1470  LONG_SIZE                EQU         $02 ; 0000 0010
00001DCE                          1471  
00001DCE  =00000001               1472  BYTE_SIZE_M              EQU         $01 ; 0000 0001
00001DCE  =00000003               1473  WORD_SIZE_M              EQU         $03 ; 0000 0011
00001DCE  =00000002               1474  LONG_SIZE_M              EQU         $02 ; 0000 0010
00001DCE                          1475  
00001DCE                          1476  *address constants
00001DCE  =00003000               1477  MIN_ADDRESS             EQU         $00003000
00001DCE  =0FFF0000               1478  MAX_ADDRESS             EQU         $0FFF0000
00001DCE                          1479  
00001DCE                          1480  *address variables
00001DCE  =00007000               1481  TEST_ORIGIN             SET         $00007000
00001DCE  =00007000               1482  NEXT_ADDR               SET         TEST_ORIGIN
00001DCE  =00009000               1483  END_ADDR                SET         $00009000
00001DCE                          1484  
00001DCE                          1485  *filters for isolating parts of a hexa instruction. X means 'unknown' and can be 0 or one after ANDI filter.
00001DCE                          1486  *To filter an instruction, ANDI it with the desired filter.
00001DCE                          1487  *note: I'm not sure if it matters much whether you have the 4 leading 0s in these filters, but I don't want to
00001DCE                          1488  *risk changing it. Therefore, some filters have leading 0s and some do not.
00001DCE                          1489      * general filters
00001DCE  =0000C000               1490  FILT_2BIT_1             EQU         $0000C000   ;first 2 bits:                          XX00 0000 0000 0000
00001DCE  =0000F000               1491  FILT_NIB_1              EQU         $0000F000   ;first nibble:                          XXXX 0000 0000 0000
00001DCE  =00000F00               1492  FILT_NIB_2              EQU         $00000F00   ;second nibble:                         0000 XXXX 0000 0000
00001DCE  =00000800               1493  FILT_BIT_5              EQU         $00000800   ;5th bit:                               0000 X000 0000 0000
00001DCE  =00000100               1494  FILT_BIT_8              EQU         $00000100   ;8th bit:                               0000 000X 0000 0000
00001DCE                          1495  
00001DCE                          1496      * source/destination filters (not applicable for bidirectional operations)
00001DCE  =00000E00               1497  FILT_DEST_REG           EQU         $00000E00   ;destination register:                  0000 XXX0 0000 0000
00001DCE  =000001C0               1498  FILT_DEST_MD            EQU         $000001C0   ;destination mode:                      0000 000X XX00 0000
00001DCE  =00000038               1499  FILT_SRC_MD             EQU         $00000038   ;source mode:                           0000 0000 00XX X000
00001DCE  =00000007               1500  FILT_SRC_REG            EQU         $00000007   ;source register:                       0000 0000 0000 0XXX
00001DCE                          1501  
00001DCE                          1502      * move filters
00001DCE  =00003000               1503  FILT_MOVE_SIZE          EQU         $00003000   ;Size of a move operation:              00XX 0000 0000 0000
00001DCE  =0000FB80               1504  FILT_MOVEM              EQU         $FB80       ; check for a MOVEM instruction:        XXXX X0XX X000 0000
00001DCE                          1505  
00001DCE                          1506      * filters for BRA, BSR, BCC, and MOVEQ (the same filter, but named differently for clarity.)
00001DCE  =000000FF               1507  FILT_DISPLACEMENT       EQU         $00FF       ;Displacment of branch instruction:     0000 0000 XXXX XXXX
00001DCE  =000000FF               1508  FILT_MOVEQ_DATA         EQU         $00FF       ;Data of MOVEQ instruction:             0000 0000 XXXX XXXX
00001DCE                          1509  
00001DCE                          1510      * EXT filter
00001DCE  =0000FFB8               1511  FILT_EXT                EQU         $FFB8       ; check for an EXT instruction:         XXXX XXXX X0XX X000
00001DCE                          1512  
00001DCE                          1513      
00001DCE                          1514  
00001DCE                          1515  * constants for comparing with filtered instructions. X means 'don't care' (and will be set to 0 by previous filter)
00001DCE                          1516  *(These do not represent the complete insturctions.)
00001DCE                          1517  *(Also note that repetition is allowed for clarity's sake, so two constants can share a value.)
00001DCE                          1518      * general filters
00001DCE  =00000000               1519  CONST_ALL_0             EQU         $0000    ; all 0s:                               0000 0000 0000 0000
00001DCE  =00004000               1520  CONST_NIB1_0100         EQU         $4000    ; first nibble is 0100                  0100 XXXX XXXX XXXX
00001DCE  =00000800               1521  CONST_NIB2_1000         EQU         $0800    ; second nibble is 1000                 XXXX 1000 XXXX XXXX
00001DCE  =00000A00               1522  CONST_NIB2_1010         EQU         $0A00    ; second nibble is 1010                 XXXX 1010 XXXX XXXX
00001DCE  =00000E00               1523  CONST_NIB2_1110         EQU         $0E00    ; second nibble is 1110                 XXXX 1110 XXXX XXXX
00001DCE                          1524  
00001DCE                          1525  * Immediate operation constants
00001DCE                          1526      * ANDI
00001DCE  =00000000               1527  CONST_ORI_DEST_REG      EQU         $0000    ; confirm ORI                           XXXX 000X XXXX XXXX
00001DCE                          1528      * ANDI
00001DCE  =00000200               1529  CONST_ANDI_DEST_REG     EQU         $0200    ; confirm ANDI                          XXXX 001X XXXX XXXX
00001DCE                          1530      * SUBI
00001DCE  =00000400               1531  CONST_SUBI_DEST_REG     EQU         $0400    ; confirm SUBI                          XXXX 010X XXXX XXXX
00001DCE                          1532      * ADDI
00001DCE  =00000600               1533  CONST_ADDI_DEST_REG     EQU         $0600    ; confirm ADDI                          XXXX 011X XXXX XXXX
00001DCE                          1534      * EORI
00001DCE  =00000A00               1535  CONST_EORI_DEST_REG     EQU         $0A00    ; confirm EORI                          XXXX 101X XXXX XXXX
00001DCE                          1536      * CMPI
00001DCE  =00000C00               1537  CONST_CMPI_DEST_REG     EQU         $0C00    ; confirm CMPI                          XXXX 110X XXXX XXXX
00001DCE                          1538  
00001DCE                          1539  * Constants for matching based on 2nd nibble
00001DCE                          1540      *NEGX
00001DCE  =00000000               1541  CONST_NEGX_OP           EQU         $0000    ; confirm NEGX                          XXXX 0000 XXXX XXXX
00001DCE                          1542      *CLR
00001DCE  =00000200               1543  CONST_CLR_OP            EQU         $0200    ; confirm CLR                           XXXX 0010 XXXX XXXX
00001DCE                          1544      *NEG
00001DCE  =00000400               1545  CONST_NEG_OP            EQU         $0400    ; confirm NEG                           XXXX 0100 XXXX XXXX
00001DCE                          1546      *NOT
00001DCE  =00000600               1547  CONST_NOT_OP            EQU         $0600    ; confirm NOT                           XXXX 0110 XXXX XXXX
00001DCE                          1548  
00001DCE                          1549  * EXT constant
00001DCE  =00004880               1550  CONST_EXT               EQU         $4880    ; confirm EXT                           0100 1000 1X00 0XXX
00001DCE                          1551  
00001DCE                          1552  * Other constants
00001DCE                          1553      * BTST,BCHG,BCLR,BSET
00001DCE  =00000800               1554  CONST_B_OP              EQU         $0800    ; BTST,BCHG,BCLR,BSET                   XXXX 100X XXXX XXXX
00001DCE                          1555  
00001DCE                          1556      * MOVE
00001DCE  =00001000               1557  CONST_MOVE_B            EQU         $1000    ; MOVE.B (use first nib)                0001 XXXX XXXX XXXX
00001DCE  =00003000               1558  CONST_MOVE_W            EQU         $3000    ; MOVE.W (use first nib)                0011 XXXX XXXX XXXX
00001DCE  =00002000               1559  CONST_MOVE_L            EQU         $2000    ; MOVE.L (use first nib)                0010 XXXX XXXX XXXX
00001DCE                          1560  
00001DCE                          1561      * MOVEQ
00001DCE  =00007000               1562  CONST_MOVEQ             EQU         $7000    ; MOVEQ.L (use first nib)               0111 XXXX XXXX XXXX    
00001DCE                          1563           
00001DCE                          1564      * MOVEM                      
00001DCE  =00008880               1565  CONST_MOVEM             EQU         $8880    ; confirm MOVEM (use FILT_MOVEM)        0100 1X00 1XXX XXXX            
00001DCE                          1566           
00001DCE                          1567  * Mode/register constants
00001DCE                          1568  
00001DCE                          1569      * Mode values
00001DCE  =00000000               1570  CONST_DATA_REG_MD       EQU         $00      ; Data register mode:     Dn            XXXX X000
00001DCE  =00000001               1571  CONST_ADDR_REG_MD       EQU         $01      ; Address register mode:  An            XXXX X001
00001DCE  =00000002               1572  CONST_ADDR_IND_MD       EQU         $02      ; Address indirect mode:  (An)          XXXX X010
00001DCE  =00000003               1573  CONST_ADDR_INCR_MD      EQU         $03      ; Address postincr. mode: (An)+         XXXX X011
00001DCE  =00000004               1574  CONST_ADDR_DECR_MD      EQU         $04      ; Address predecr. mode:  -(An)         XXXX X100
00001DCE  =00000005               1575  CONST_ADDR_DISPLC_MD    EQU         $05      ; Address w/ displacement:(d16,An)      XXXX X101
00001DCE  =00000006               1576  CONST_ADDR_INDEX_MD     EQU         $06      ; Address w/ index:       (d8,PC,Xn)    XXXX X110
00001DCE  =00000007               1577  CONST_ADDR_MISC_MD      EQU         $07      ; Various other addressing modes        XXXX X111
00001DCE                          1578  
00001DCE                          1579      * Constant register values (should not be necessary for register numbers like D5)
00001DCE  =00000002               1580  CONST_COUNTR_DISPLC_REG EQU         $02      ; Counter w/ displacement:(d16,PC)      XXXX X010
00001DCE  =00000003               1581  CONST_COUNTR_INDEX_REG  EQU         $03      ; Counter w/ index:       (d16,PC,Xn)   XXXX X011
00001DCE  =00000000               1582  CONST_ABS_SHORT_REG     EQU         $00      ; Absolute word:          (xxx).W       XXXX X000
00001DCE  =00000001               1583  CONST_ABS_LONG_REG      EQU         $01      ; Absolute long:          (xxx).L       XXXX X001
00001DCE  =00000004               1584  CONST_IMMEDIATE_REG     EQU         $04      ; Immediate data:         #imm          XXXX X100
00001DCE                          1585  
00001DCE                          1586  *full OPcode contstants
00001DCE  =00004E70               1587  RESET_CODE              EQU         $4E70   ; RESET                                 0100 1110 0111 0001
00001DCE  =00004E71               1588  NOP_CODE                EQU         $4E71   ; NOP                                   0100 1110 0111 0001
00001DCE  =00004E72               1589  STOP_CODE               EQU         $4E72   ; STOP                                  0100 1110 0111 0010
00001DCE                          1590  
00001DCE                          1591    
00001DCE                          1592  *############# END VARIABLES/CONSTANTS #########################
00001DCE                          1593  
00001DCE                          1594      END START        ; last line of source, very end of the program

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDI_FOUND          1728
ANDI_FOUND          1720
ASCII_TO_HEX        10FE
BEGIN_READ          132C
BLANK_THE_SCREEN    103C
BYTE_SIZE           0
BYTE_SIZE_M         1
BYTE_SIZE_MSG       1D26
CHECK_ADDRESSING_MODES  1928
CHECK_CONSTANTS     13CC
CHECK_DONE_READING  1352
CHECK_EXT           158E
CHECK_MISC_ADDRESSINGS  1A8E
CHECK_MOVE          1552
CHECK_MOVEM         15A4
CHECK_MOVEQ         1578
CHECK_NIB1_0000     1450
CHECK_NIB1_0100     1466
CHECK_NON_CONSTANTS  1434
CLOSE_PARENS        1B47
CLR_FOUND           1738
CMPI_FOUND          1730
COMMA               1B41
CONFIRMED_NEXT_OP   1340
CONFIRM_0000_XXX0   1494
CONFIRM_0100_0XXX   14EE
CONFIRM_0100_1000   1546
CONFIRM_0100_1010   154A
CONFIRM_0100_1110   154E
CONFIRM_0100_1XXX   151E
CONFIRM_DONE        135A
CONFIRM_NIB1_0000   147C
CONFIRM_NIB1_0100   14D2
CONFIRM_READ_DATA   1828
CONFIRM_READ_DEST_DATA  1808
CONFIRM_READ_SRC_DATA  17CE
CONST_ABS_LONG_REG  1
CONST_ABS_SHORT_REG  0
CONST_ADDI_DEST_REG  600
CONST_ADDR_DECR_MD  4
CONST_ADDR_DISPLC_MD  5
CONST_ADDR_INCR_MD  3
CONST_ADDR_INDEX_MD  6
CONST_ADDR_IND_MD   2
CONST_ADDR_MISC_MD  7
CONST_ADDR_REG_MD   1
CONST_ALL_0         0
CONST_ANDI_DEST_REG  200
CONST_B_OP          800
CONST_CLR_OP        200
CONST_CMPI_DEST_REG  C00
CONST_COUNTR_DISPLC_REG  2
CONST_COUNTR_INDEX_REG  3
CONST_DATA_REG_MD   0
CONST_EORI_DEST_REG  A00
CONST_EXT           4880
CONST_IMMEDIATE_REG  4
CONST_MOVEM         8880
CONST_MOVEQ         7000
CONST_MOVE_B        1000
CONST_MOVE_L        2000
CONST_MOVE_W        3000
CONST_NEGX_OP       0
CONST_NEG_OP        400
CONST_NIB1_0100     4000
CONST_NIB2_1000     800
CONST_NIB2_1010     A00
CONST_NIB2_1110     E00
CONST_NOT_OP        600
CONST_ORI_DEST_REG  0
CONST_SUBI_DEST_REG  400
CONVERSION_DONE     12FA
COUNT_INPUT_DIGITS  1090
CR                  D
CURRENT_DATA        1DC2
CURRENT_DEST_DATA   1DCA
CURRENT_DEST_MD     1DBF
CURRENT_DEST_REG    1DC0
CURRENT_MD          1DBB
CURRENT_OP_SIZE     1DBA
CURRENT_REG         1DBC
CURRENT_SRC_DATA    1DC6
CURRENT_SRC_MD      1DBD
CURRENT_SRC_REG     1DBE
CURRENT_WORD        1DB8
DIG_CONV_DONE_1     1128
DIG_CONV_DONE_2     115C
DIG_CONV_DONE_3     1194
DIG_CONV_DONE_4     11CC
DIG_CONV_DONE_5     1204
DIG_CONV_DONE_6     123C
DIG_CONV_DONE_7     1274
DIG_CONV_DONE_8     12AC
DISPLAY_ABS_LONG    1AF0
DISPLAY_ABS_SHORT   1AD0
DISPLAY_ADDR_DECR   1A46
DISPLAY_ADDR_DISPLC  1A8A
DISPLAY_ADDR_INCR   1A02
DISPLAY_ADDR_IND    19CA
DISPLAY_ADDR_INDEX  1A8C
DISPLAY_ADDR_REG    19AA
DISPLAY_BUFFER      1D7C
DISPLAY_COUNTR_DISPLC  1ACC
DISPLAY_COUNTR_INDEX  1ACE
DISPLAY_CURRENT_ADDRESS  13A6
DISPLAY_DATA_REG    198A
DISPLAY_DEST        18F2
DISPLAY_IMMEDIATE   1B10
DISPLAY_MOVEQ_DATA  16D8
DISPLAY_MOVE_DATA   1664
DISPLAY_SOURCE      18BC
DOLLAR              1B3F
DONE_READING        1392
DONE_READING_MSG    1D0A
END_ADDR            9000
END_ADDR_MSG        1B81
EORI_FOUND          172C
EXT_FOUND           1714
FILT_2BIT_1         C000
FILT_BIT_5          800
FILT_BIT_8          100
FILT_DEST_MD        1C0
FILT_DEST_REG       E00
FILT_DISPLACEMENT   FF
FILT_EXT            FFB8
FILT_MOVEM          FB80
FILT_MOVEQ_DATA     FF
FILT_MOVE_SIZE      3000
FILT_NIB_1          F000
FILT_NIB_2          F00
FILT_SRC_MD         38
FILT_SRC_REG        7
GO_TO_NEXT_OP       133C
HASH                1B43
INPUTTING_START     1
INVALID_ADDR_HIGH   12EA
INVALID_ADDR_H_MSG  1CC9
INVALID_ADDR_INPUT  12BA
INVALID_ADDR_LOW    12DA
INVALID_ADDR_L_MSG  1C89
INVALID_ADDR_MSG    1C02
INVALID_END_ADDR    12CA
INVALID_END_ADDR_MSG  1C38
INVALID_LEN_MSG     1BB4
LF                  A
LONG_SIZE           2
LONG_SIZE_M         2
LONG_SIZE_MSG       1D2C
MAX_ADDRESS         FFF0000
MINUS               1B4B
MIN_ADDRESS         3000
MOVEM_FOUND         1718
MOVEQ_FOUND         1686
MOVEQ_MSG           1D58
MOVE_B_FOUND        15BA
MOVE_B_MSG          1D43
MOVE_L_FOUND        161A
MOVE_L_MSG          1D51
MOVE_MSG            1D3E
MOVE_W_FOUND        15EA
MOVE_W_MSG          1D4A
MSG_A               1D60
MSG_D               1D5E
NEGX_FOUND          1734
NEG_FOUND           173C
NEWLINE             1DB5
NEXT_ADDR           7000
NOP_CODE            4E71
NOP_FOUND           1412
NOP_MSG             1D35
NOT_FOUND           1740
OPCODE_BUFFER       1D76
OPEN_PARENS         1B45
ORI_FOUND           171C
PARSE_MOVEQ_DATA    16B6
PARSE_MOVE_DATA     164A
PLUS                1B49
PREPARE_DISPLAY     1338
PROMPT_INPUT        1008
READ_ABS_LONG_DATA  1872
READ_ABS_SHORT_DATA  186A
READ_COUNTR_DISPLC_DATA  1866
READ_COUNTR_INDEX_DATA  1868
READ_CURRENT_OP     13A2
READ_DEST_DATA      17EE
READ_DEST_MODE      1762
READ_DEST_REG       1744
READ_IMMEDIATE_DATA  187A
READ_IMMEDIATE_DATA_L  18AE
READ_IMMEDIATE_DATA_W  18A0
READ_MOVEQ_DATA     16FA
READ_SOURCE_DATA    17B4
READ_SOURCE_MODE    177E
READ_SOURCE_REG     179A
RESET_CODE          4E70
RESET_FOUND         13F4
RESET_MSG           1D2F
RESTART_ERROR_STR   1D95
RESTART_PROMPT_MSG  1D86
RETURN              1B3A
SET_END_ADDR        1322
SET_START_ADDR      131C
SIZE_BUFFER         1D7A
SPACE               1B3D
START               1000
START_ADDR_IN       1D62
START_ADDR_MSG      1B4D
STOP                1004
STOP_CODE           4E72
STOP_FOUND          1430
STOP_MSG            1D39
SUBI_FOUND          1724
TAKE_USER_INPUT     107E
TAKE_USER_IN_E      106A
TAKE_USER_IN_S      1056
TEST_ORIGIN         7000
USER_RESTART_IN_ERR  1384
VALID_ADDR          1310
WORD_SIZE           1
WORD_SIZE_M         3
WORD_SIZE_MSG       1D29
